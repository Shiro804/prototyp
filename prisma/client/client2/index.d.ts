
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model SimulationRecord
 * 
 */
export type SimulationRecord = $Result.DefaultSelection<Prisma.$SimulationRecordPayload>
/**
 * Model KpiRecord
 * 
 */
export type KpiRecord = $Result.DefaultSelection<Prisma.$KpiRecordPayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>
/**
 * Model Machine
 * 
 */
export type Machine = $Result.DefaultSelection<Prisma.$MachinePayload>
/**
 * Model Worker
 * 
 */
export type Worker = $Result.DefaultSelection<Prisma.$WorkerPayload>
/**
 * Model WorkerRole
 * 
 */
export type WorkerRole = $Result.DefaultSelection<Prisma.$WorkerRolePayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model InventoryEntry
 * 
 */
export type InventoryEntry = $Result.DefaultSelection<Prisma.$InventoryEntryPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model ProcessStep
 * 
 */
export type ProcessStep = $Result.DefaultSelection<Prisma.$ProcessStepPayload>
/**
 * Model Recipe
 * 
 */
export type Recipe = $Result.DefaultSelection<Prisma.$RecipePayload>
/**
 * Model RecipeInput
 * 
 */
export type RecipeInput = $Result.DefaultSelection<Prisma.$RecipeInputPayload>
/**
 * Model RecipeOutput
 * 
 */
export type RecipeOutput = $Result.DefaultSelection<Prisma.$RecipeOutputPayload>
/**
 * Model LogEntry
 * 
 */
export type LogEntry = $Result.DefaultSelection<Prisma.$LogEntryPayload>
/**
 * Model Sensor
 * 
 */
export type Sensor = $Result.DefaultSelection<Prisma.$SensorPayload>
/**
 * Model FilterEntry
 * 
 */
export type FilterEntry = $Result.DefaultSelection<Prisma.$FilterEntryPayload>
/**
 * Model Filter
 * 
 */
export type Filter = $Result.DefaultSelection<Prisma.$FilterPayload>
/**
 * Model TransportSystem
 * 
 */
export type TransportSystem = $Result.DefaultSelection<Prisma.$TransportSystemPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more SimulationRecords
 * const simulationRecords = await prisma.simulationRecord.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more SimulationRecords
   * const simulationRecords = await prisma.simulationRecord.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.simulationRecord`: Exposes CRUD operations for the **SimulationRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SimulationRecords
    * const simulationRecords = await prisma.simulationRecord.findMany()
    * ```
    */
  get simulationRecord(): Prisma.SimulationRecordDelegate<ExtArgs>;

  /**
   * `prisma.kpiRecord`: Exposes CRUD operations for the **KpiRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KpiRecords
    * const kpiRecords = await prisma.kpiRecord.findMany()
    * ```
    */
  get kpiRecord(): Prisma.KpiRecordDelegate<ExtArgs>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs>;

  /**
   * `prisma.machine`: Exposes CRUD operations for the **Machine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Machines
    * const machines = await prisma.machine.findMany()
    * ```
    */
  get machine(): Prisma.MachineDelegate<ExtArgs>;

  /**
   * `prisma.worker`: Exposes CRUD operations for the **Worker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workers
    * const workers = await prisma.worker.findMany()
    * ```
    */
  get worker(): Prisma.WorkerDelegate<ExtArgs>;

  /**
   * `prisma.workerRole`: Exposes CRUD operations for the **WorkerRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkerRoles
    * const workerRoles = await prisma.workerRole.findMany()
    * ```
    */
  get workerRole(): Prisma.WorkerRoleDelegate<ExtArgs>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs>;

  /**
   * `prisma.inventoryEntry`: Exposes CRUD operations for the **InventoryEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryEntries
    * const inventoryEntries = await prisma.inventoryEntry.findMany()
    * ```
    */
  get inventoryEntry(): Prisma.InventoryEntryDelegate<ExtArgs>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs>;

  /**
   * `prisma.processStep`: Exposes CRUD operations for the **ProcessStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessSteps
    * const processSteps = await prisma.processStep.findMany()
    * ```
    */
  get processStep(): Prisma.ProcessStepDelegate<ExtArgs>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<ExtArgs>;

  /**
   * `prisma.recipeInput`: Exposes CRUD operations for the **RecipeInput** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeInputs
    * const recipeInputs = await prisma.recipeInput.findMany()
    * ```
    */
  get recipeInput(): Prisma.RecipeInputDelegate<ExtArgs>;

  /**
   * `prisma.recipeOutput`: Exposes CRUD operations for the **RecipeOutput** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeOutputs
    * const recipeOutputs = await prisma.recipeOutput.findMany()
    * ```
    */
  get recipeOutput(): Prisma.RecipeOutputDelegate<ExtArgs>;

  /**
   * `prisma.logEntry`: Exposes CRUD operations for the **LogEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogEntries
    * const logEntries = await prisma.logEntry.findMany()
    * ```
    */
  get logEntry(): Prisma.LogEntryDelegate<ExtArgs>;

  /**
   * `prisma.sensor`: Exposes CRUD operations for the **Sensor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sensors
    * const sensors = await prisma.sensor.findMany()
    * ```
    */
  get sensor(): Prisma.SensorDelegate<ExtArgs>;

  /**
   * `prisma.filterEntry`: Exposes CRUD operations for the **FilterEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FilterEntries
    * const filterEntries = await prisma.filterEntry.findMany()
    * ```
    */
  get filterEntry(): Prisma.FilterEntryDelegate<ExtArgs>;

  /**
   * `prisma.filter`: Exposes CRUD operations for the **Filter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Filters
    * const filters = await prisma.filter.findMany()
    * ```
    */
  get filter(): Prisma.FilterDelegate<ExtArgs>;

  /**
   * `prisma.transportSystem`: Exposes CRUD operations for the **TransportSystem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransportSystems
    * const transportSystems = await prisma.transportSystem.findMany()
    * ```
    */
  get transportSystem(): Prisma.TransportSystemDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.19.1
   * Query Engine version: 69d742ee20b815d88e17e54db4a2a7a3b30324e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    SimulationRecord: 'SimulationRecord',
    KpiRecord: 'KpiRecord',
    Resource: 'Resource',
    Machine: 'Machine',
    Worker: 'Worker',
    WorkerRole: 'WorkerRole',
    Inventory: 'Inventory',
    InventoryEntry: 'InventoryEntry',
    Location: 'Location',
    ProcessStep: 'ProcessStep',
    Recipe: 'Recipe',
    RecipeInput: 'RecipeInput',
    RecipeOutput: 'RecipeOutput',
    LogEntry: 'LogEntry',
    Sensor: 'Sensor',
    FilterEntry: 'FilterEntry',
    Filter: 'Filter',
    TransportSystem: 'TransportSystem',
    Order: 'Order'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db2?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "simulationRecord" | "kpiRecord" | "resource" | "machine" | "worker" | "workerRole" | "inventory" | "inventoryEntry" | "location" | "processStep" | "recipe" | "recipeInput" | "recipeOutput" | "logEntry" | "sensor" | "filterEntry" | "filter" | "transportSystem" | "order"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      SimulationRecord: {
        payload: Prisma.$SimulationRecordPayload<ExtArgs>
        fields: Prisma.SimulationRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimulationRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimulationRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationRecordPayload>
          }
          findFirst: {
            args: Prisma.SimulationRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimulationRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationRecordPayload>
          }
          findMany: {
            args: Prisma.SimulationRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationRecordPayload>[]
          }
          create: {
            args: Prisma.SimulationRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationRecordPayload>
          }
          createMany: {
            args: Prisma.SimulationRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimulationRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationRecordPayload>[]
          }
          delete: {
            args: Prisma.SimulationRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationRecordPayload>
          }
          update: {
            args: Prisma.SimulationRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationRecordPayload>
          }
          deleteMany: {
            args: Prisma.SimulationRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimulationRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SimulationRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationRecordPayload>
          }
          aggregate: {
            args: Prisma.SimulationRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimulationRecord>
          }
          groupBy: {
            args: Prisma.SimulationRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimulationRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimulationRecordCountArgs<ExtArgs>
            result: $Utils.Optional<SimulationRecordCountAggregateOutputType> | number
          }
        }
      }
      KpiRecord: {
        payload: Prisma.$KpiRecordPayload<ExtArgs>
        fields: Prisma.KpiRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KpiRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KpiRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiRecordPayload>
          }
          findFirst: {
            args: Prisma.KpiRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KpiRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiRecordPayload>
          }
          findMany: {
            args: Prisma.KpiRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiRecordPayload>[]
          }
          create: {
            args: Prisma.KpiRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiRecordPayload>
          }
          createMany: {
            args: Prisma.KpiRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KpiRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiRecordPayload>[]
          }
          delete: {
            args: Prisma.KpiRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiRecordPayload>
          }
          update: {
            args: Prisma.KpiRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiRecordPayload>
          }
          deleteMany: {
            args: Prisma.KpiRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KpiRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KpiRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiRecordPayload>
          }
          aggregate: {
            args: Prisma.KpiRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKpiRecord>
          }
          groupBy: {
            args: Prisma.KpiRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<KpiRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.KpiRecordCountArgs<ExtArgs>
            result: $Utils.Optional<KpiRecordCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      Machine: {
        payload: Prisma.$MachinePayload<ExtArgs>
        fields: Prisma.MachineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MachineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MachineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          findFirst: {
            args: Prisma.MachineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MachineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          findMany: {
            args: Prisma.MachineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>[]
          }
          create: {
            args: Prisma.MachineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          createMany: {
            args: Prisma.MachineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MachineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>[]
          }
          delete: {
            args: Prisma.MachineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          update: {
            args: Prisma.MachineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          deleteMany: {
            args: Prisma.MachineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MachineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MachineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          aggregate: {
            args: Prisma.MachineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMachine>
          }
          groupBy: {
            args: Prisma.MachineGroupByArgs<ExtArgs>
            result: $Utils.Optional<MachineGroupByOutputType>[]
          }
          count: {
            args: Prisma.MachineCountArgs<ExtArgs>
            result: $Utils.Optional<MachineCountAggregateOutputType> | number
          }
        }
      }
      Worker: {
        payload: Prisma.$WorkerPayload<ExtArgs>
        fields: Prisma.WorkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findFirst: {
            args: Prisma.WorkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findMany: {
            args: Prisma.WorkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          create: {
            args: Prisma.WorkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          createMany: {
            args: Prisma.WorkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          delete: {
            args: Prisma.WorkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          update: {
            args: Prisma.WorkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          deleteMany: {
            args: Prisma.WorkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          aggregate: {
            args: Prisma.WorkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorker>
          }
          groupBy: {
            args: Prisma.WorkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkerCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerCountAggregateOutputType> | number
          }
        }
      }
      WorkerRole: {
        payload: Prisma.$WorkerRolePayload<ExtArgs>
        fields: Prisma.WorkerRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRolePayload>
          }
          findFirst: {
            args: Prisma.WorkerRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRolePayload>
          }
          findMany: {
            args: Prisma.WorkerRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRolePayload>[]
          }
          create: {
            args: Prisma.WorkerRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRolePayload>
          }
          createMany: {
            args: Prisma.WorkerRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkerRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRolePayload>[]
          }
          delete: {
            args: Prisma.WorkerRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRolePayload>
          }
          update: {
            args: Prisma.WorkerRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRolePayload>
          }
          deleteMany: {
            args: Prisma.WorkerRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkerRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRolePayload>
          }
          aggregate: {
            args: Prisma.WorkerRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkerRole>
          }
          groupBy: {
            args: Prisma.WorkerRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkerRoleCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerRoleCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      InventoryEntry: {
        payload: Prisma.$InventoryEntryPayload<ExtArgs>
        fields: Prisma.InventoryEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryEntryPayload>
          }
          findFirst: {
            args: Prisma.InventoryEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryEntryPayload>
          }
          findMany: {
            args: Prisma.InventoryEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryEntryPayload>[]
          }
          create: {
            args: Prisma.InventoryEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryEntryPayload>
          }
          createMany: {
            args: Prisma.InventoryEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryEntryPayload>[]
          }
          delete: {
            args: Prisma.InventoryEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryEntryPayload>
          }
          update: {
            args: Prisma.InventoryEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryEntryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryEntryPayload>
          }
          aggregate: {
            args: Prisma.InventoryEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryEntry>
          }
          groupBy: {
            args: Prisma.InventoryEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryEntryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryEntryCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      ProcessStep: {
        payload: Prisma.$ProcessStepPayload<ExtArgs>
        fields: Prisma.ProcessStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          findFirst: {
            args: Prisma.ProcessStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          findMany: {
            args: Prisma.ProcessStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>[]
          }
          create: {
            args: Prisma.ProcessStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          createMany: {
            args: Prisma.ProcessStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>[]
          }
          delete: {
            args: Prisma.ProcessStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          update: {
            args: Prisma.ProcessStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          deleteMany: {
            args: Prisma.ProcessStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          aggregate: {
            args: Prisma.ProcessStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessStep>
          }
          groupBy: {
            args: Prisma.ProcessStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessStepCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessStepCountAggregateOutputType> | number
          }
        }
      }
      Recipe: {
        payload: Prisma.$RecipePayload<ExtArgs>
        fields: Prisma.RecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findFirst: {
            args: Prisma.RecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findMany: {
            args: Prisma.RecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          create: {
            args: Prisma.RecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          createMany: {
            args: Prisma.RecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          delete: {
            args: Prisma.RecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          update: {
            args: Prisma.RecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          deleteMany: {
            args: Prisma.RecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          aggregate: {
            args: Prisma.RecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipe>
          }
          groupBy: {
            args: Prisma.RecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeCountAggregateOutputType> | number
          }
        }
      }
      RecipeInput: {
        payload: Prisma.$RecipeInputPayload<ExtArgs>
        fields: Prisma.RecipeInputFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeInputFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInputPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeInputFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInputPayload>
          }
          findFirst: {
            args: Prisma.RecipeInputFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInputPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeInputFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInputPayload>
          }
          findMany: {
            args: Prisma.RecipeInputFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInputPayload>[]
          }
          create: {
            args: Prisma.RecipeInputCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInputPayload>
          }
          createMany: {
            args: Prisma.RecipeInputCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeInputCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInputPayload>[]
          }
          delete: {
            args: Prisma.RecipeInputDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInputPayload>
          }
          update: {
            args: Prisma.RecipeInputUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInputPayload>
          }
          deleteMany: {
            args: Prisma.RecipeInputDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeInputUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecipeInputUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInputPayload>
          }
          aggregate: {
            args: Prisma.RecipeInputAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipeInput>
          }
          groupBy: {
            args: Prisma.RecipeInputGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeInputGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeInputCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeInputCountAggregateOutputType> | number
          }
        }
      }
      RecipeOutput: {
        payload: Prisma.$RecipeOutputPayload<ExtArgs>
        fields: Prisma.RecipeOutputFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeOutputFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeOutputPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeOutputFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeOutputPayload>
          }
          findFirst: {
            args: Prisma.RecipeOutputFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeOutputPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeOutputFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeOutputPayload>
          }
          findMany: {
            args: Prisma.RecipeOutputFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeOutputPayload>[]
          }
          create: {
            args: Prisma.RecipeOutputCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeOutputPayload>
          }
          createMany: {
            args: Prisma.RecipeOutputCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeOutputCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeOutputPayload>[]
          }
          delete: {
            args: Prisma.RecipeOutputDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeOutputPayload>
          }
          update: {
            args: Prisma.RecipeOutputUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeOutputPayload>
          }
          deleteMany: {
            args: Prisma.RecipeOutputDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeOutputUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecipeOutputUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeOutputPayload>
          }
          aggregate: {
            args: Prisma.RecipeOutputAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipeOutput>
          }
          groupBy: {
            args: Prisma.RecipeOutputGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeOutputGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeOutputCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeOutputCountAggregateOutputType> | number
          }
        }
      }
      LogEntry: {
        payload: Prisma.$LogEntryPayload<ExtArgs>
        fields: Prisma.LogEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          findFirst: {
            args: Prisma.LogEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          findMany: {
            args: Prisma.LogEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>[]
          }
          create: {
            args: Prisma.LogEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          createMany: {
            args: Prisma.LogEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>[]
          }
          delete: {
            args: Prisma.LogEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          update: {
            args: Prisma.LogEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          deleteMany: {
            args: Prisma.LogEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          aggregate: {
            args: Prisma.LogEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogEntry>
          }
          groupBy: {
            args: Prisma.LogEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LogEntryCountAggregateOutputType> | number
          }
        }
      }
      Sensor: {
        payload: Prisma.$SensorPayload<ExtArgs>
        fields: Prisma.SensorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SensorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SensorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          findFirst: {
            args: Prisma.SensorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SensorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          findMany: {
            args: Prisma.SensorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>[]
          }
          create: {
            args: Prisma.SensorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          createMany: {
            args: Prisma.SensorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SensorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>[]
          }
          delete: {
            args: Prisma.SensorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          update: {
            args: Prisma.SensorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          deleteMany: {
            args: Prisma.SensorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SensorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SensorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          aggregate: {
            args: Prisma.SensorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSensor>
          }
          groupBy: {
            args: Prisma.SensorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SensorGroupByOutputType>[]
          }
          count: {
            args: Prisma.SensorCountArgs<ExtArgs>
            result: $Utils.Optional<SensorCountAggregateOutputType> | number
          }
        }
      }
      FilterEntry: {
        payload: Prisma.$FilterEntryPayload<ExtArgs>
        fields: Prisma.FilterEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FilterEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FilterEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterEntryPayload>
          }
          findFirst: {
            args: Prisma.FilterEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FilterEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterEntryPayload>
          }
          findMany: {
            args: Prisma.FilterEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterEntryPayload>[]
          }
          create: {
            args: Prisma.FilterEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterEntryPayload>
          }
          createMany: {
            args: Prisma.FilterEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FilterEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterEntryPayload>[]
          }
          delete: {
            args: Prisma.FilterEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterEntryPayload>
          }
          update: {
            args: Prisma.FilterEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterEntryPayload>
          }
          deleteMany: {
            args: Prisma.FilterEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FilterEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FilterEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterEntryPayload>
          }
          aggregate: {
            args: Prisma.FilterEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFilterEntry>
          }
          groupBy: {
            args: Prisma.FilterEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilterEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.FilterEntryCountArgs<ExtArgs>
            result: $Utils.Optional<FilterEntryCountAggregateOutputType> | number
          }
        }
      }
      Filter: {
        payload: Prisma.$FilterPayload<ExtArgs>
        fields: Prisma.FilterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FilterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FilterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>
          }
          findFirst: {
            args: Prisma.FilterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FilterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>
          }
          findMany: {
            args: Prisma.FilterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>[]
          }
          create: {
            args: Prisma.FilterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>
          }
          createMany: {
            args: Prisma.FilterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FilterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>[]
          }
          delete: {
            args: Prisma.FilterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>
          }
          update: {
            args: Prisma.FilterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>
          }
          deleteMany: {
            args: Prisma.FilterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FilterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FilterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilterPayload>
          }
          aggregate: {
            args: Prisma.FilterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFilter>
          }
          groupBy: {
            args: Prisma.FilterGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilterGroupByOutputType>[]
          }
          count: {
            args: Prisma.FilterCountArgs<ExtArgs>
            result: $Utils.Optional<FilterCountAggregateOutputType> | number
          }
        }
      }
      TransportSystem: {
        payload: Prisma.$TransportSystemPayload<ExtArgs>
        fields: Prisma.TransportSystemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransportSystemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSystemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransportSystemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSystemPayload>
          }
          findFirst: {
            args: Prisma.TransportSystemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSystemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransportSystemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSystemPayload>
          }
          findMany: {
            args: Prisma.TransportSystemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSystemPayload>[]
          }
          create: {
            args: Prisma.TransportSystemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSystemPayload>
          }
          createMany: {
            args: Prisma.TransportSystemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransportSystemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSystemPayload>[]
          }
          delete: {
            args: Prisma.TransportSystemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSystemPayload>
          }
          update: {
            args: Prisma.TransportSystemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSystemPayload>
          }
          deleteMany: {
            args: Prisma.TransportSystemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransportSystemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransportSystemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportSystemPayload>
          }
          aggregate: {
            args: Prisma.TransportSystemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransportSystem>
          }
          groupBy: {
            args: Prisma.TransportSystemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransportSystemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransportSystemCountArgs<ExtArgs>
            result: $Utils.Optional<TransportSystemCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SimulationRecordCountOutputType
   */

  export type SimulationRecordCountOutputType = {
    kpis: number
  }

  export type SimulationRecordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpis?: boolean | SimulationRecordCountOutputTypeCountKpisArgs
  }

  // Custom InputTypes
  /**
   * SimulationRecordCountOutputType without action
   */
  export type SimulationRecordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationRecordCountOutputType
     */
    select?: SimulationRecordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SimulationRecordCountOutputType without action
   */
  export type SimulationRecordCountOutputTypeCountKpisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiRecordWhereInput
  }


  /**
   * Count Type WorkerCountOutputType
   */

  export type WorkerCountOutputType = {
    workerRoles: number
  }

  export type WorkerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workerRoles?: boolean | WorkerCountOutputTypeCountWorkerRolesArgs
  }

  // Custom InputTypes
  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerCountOutputType
     */
    select?: WorkerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeCountWorkerRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerRoleWhereInput
  }


  /**
   * Count Type WorkerRoleCountOutputType
   */

  export type WorkerRoleCountOutputType = {
    workers: number
  }

  export type WorkerRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workers?: boolean | WorkerRoleCountOutputTypeCountWorkersArgs
  }

  // Custom InputTypes
  /**
   * WorkerRoleCountOutputType without action
   */
  export type WorkerRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRoleCountOutputType
     */
    select?: WorkerRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkerRoleCountOutputType without action
   */
  export type WorkerRoleCountOutputTypeCountWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
  }


  /**
   * Count Type InventoryCountOutputType
   */

  export type InventoryCountOutputType = {
    entries: number
  }

  export type InventoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | InventoryCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCountOutputType
     */
    select?: InventoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryEntryWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    processSteps: number
    resources: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processSteps?: boolean | LocationCountOutputTypeCountProcessStepsArgs
    resources?: boolean | LocationCountOutputTypeCountResourcesArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountProcessStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessStepWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }


  /**
   * Count Type ProcessStepCountOutputType
   */

  export type ProcessStepCountOutputType = {
    orders: number
    resources: number
    sensors: number
    inputs: number
    outputs: number
  }

  export type ProcessStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ProcessStepCountOutputTypeCountOrdersArgs
    resources?: boolean | ProcessStepCountOutputTypeCountResourcesArgs
    sensors?: boolean | ProcessStepCountOutputTypeCountSensorsArgs
    inputs?: boolean | ProcessStepCountOutputTypeCountInputsArgs
    outputs?: boolean | ProcessStepCountOutputTypeCountOutputsArgs
  }

  // Custom InputTypes
  /**
   * ProcessStepCountOutputType without action
   */
  export type ProcessStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepCountOutputType
     */
    select?: ProcessStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcessStepCountOutputType without action
   */
  export type ProcessStepCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * ProcessStepCountOutputType without action
   */
  export type ProcessStepCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }

  /**
   * ProcessStepCountOutputType without action
   */
  export type ProcessStepCountOutputTypeCountSensorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SensorWhereInput
  }

  /**
   * ProcessStepCountOutputType without action
   */
  export type ProcessStepCountOutputTypeCountInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportSystemWhereInput
  }

  /**
   * ProcessStepCountOutputType without action
   */
  export type ProcessStepCountOutputTypeCountOutputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportSystemWhereInput
  }


  /**
   * Count Type RecipeCountOutputType
   */

  export type RecipeCountOutputType = {
    processSteps: number
    inputs: number
    outputs: number
  }

  export type RecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processSteps?: boolean | RecipeCountOutputTypeCountProcessStepsArgs
    inputs?: boolean | RecipeCountOutputTypeCountInputsArgs
    outputs?: boolean | RecipeCountOutputTypeCountOutputsArgs
  }

  // Custom InputTypes
  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     */
    select?: RecipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountProcessStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessStepWhereInput
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeInputWhereInput
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountOutputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeOutputWhereInput
  }


  /**
   * Count Type SensorCountOutputType
   */

  export type SensorCountOutputType = {
    logEntries: number
  }

  export type SensorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logEntries?: boolean | SensorCountOutputTypeCountLogEntriesArgs
  }

  // Custom InputTypes
  /**
   * SensorCountOutputType without action
   */
  export type SensorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorCountOutputType
     */
    select?: SensorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SensorCountOutputType without action
   */
  export type SensorCountOutputTypeCountLogEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogEntryWhereInput
  }


  /**
   * Count Type FilterCountOutputType
   */

  export type FilterCountOutputType = {
    entries: number
  }

  export type FilterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | FilterCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * FilterCountOutputType without action
   */
  export type FilterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilterCountOutputType
     */
    select?: FilterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FilterCountOutputType without action
   */
  export type FilterCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilterEntryWhereInput
  }


  /**
   * Count Type TransportSystemCountOutputType
   */

  export type TransportSystemCountOutputType = {
    orders: number
    sensors: number
    resources: number
  }

  export type TransportSystemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | TransportSystemCountOutputTypeCountOrdersArgs
    sensors?: boolean | TransportSystemCountOutputTypeCountSensorsArgs
    resources?: boolean | TransportSystemCountOutputTypeCountResourcesArgs
  }

  // Custom InputTypes
  /**
   * TransportSystemCountOutputType without action
   */
  export type TransportSystemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystemCountOutputType
     */
    select?: TransportSystemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransportSystemCountOutputType without action
   */
  export type TransportSystemCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * TransportSystemCountOutputType without action
   */
  export type TransportSystemCountOutputTypeCountSensorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SensorWhereInput
  }

  /**
   * TransportSystemCountOutputType without action
   */
  export type TransportSystemCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    inventoryEntries: number
    processSteps: number
    transportSystems: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryEntries?: boolean | OrderCountOutputTypeCountInventoryEntriesArgs
    processSteps?: boolean | OrderCountOutputTypeCountProcessStepsArgs
    transportSystems?: boolean | OrderCountOutputTypeCountTransportSystemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountInventoryEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryEntryWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountProcessStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessStepWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountTransportSystemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportSystemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model SimulationRecord
   */

  export type AggregateSimulationRecord = {
    _count: SimulationRecordCountAggregateOutputType | null
    _avg: SimulationRecordAvgAggregateOutputType | null
    _sum: SimulationRecordSumAggregateOutputType | null
    _min: SimulationRecordMinAggregateOutputType | null
    _max: SimulationRecordMaxAggregateOutputType | null
  }

  export type SimulationRecordAvgAggregateOutputType = {
    id: number | null
  }

  export type SimulationRecordSumAggregateOutputType = {
    id: number | null
  }

  export type SimulationRecordMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
  }

  export type SimulationRecordMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
  }

  export type SimulationRecordCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    _all: number
  }


  export type SimulationRecordAvgAggregateInputType = {
    id?: true
  }

  export type SimulationRecordSumAggregateInputType = {
    id?: true
  }

  export type SimulationRecordMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
  }

  export type SimulationRecordMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
  }

  export type SimulationRecordCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    _all?: true
  }

  export type SimulationRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimulationRecord to aggregate.
     */
    where?: SimulationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationRecords to fetch.
     */
    orderBy?: SimulationRecordOrderByWithRelationInput | SimulationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimulationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SimulationRecords
    **/
    _count?: true | SimulationRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SimulationRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SimulationRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimulationRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimulationRecordMaxAggregateInputType
  }

  export type GetSimulationRecordAggregateType<T extends SimulationRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateSimulationRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimulationRecord[P]>
      : GetScalarType<T[P], AggregateSimulationRecord[P]>
  }




  export type SimulationRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationRecordWhereInput
    orderBy?: SimulationRecordOrderByWithAggregationInput | SimulationRecordOrderByWithAggregationInput[]
    by: SimulationRecordScalarFieldEnum[] | SimulationRecordScalarFieldEnum
    having?: SimulationRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimulationRecordCountAggregateInputType | true
    _avg?: SimulationRecordAvgAggregateInputType
    _sum?: SimulationRecordSumAggregateInputType
    _min?: SimulationRecordMinAggregateInputType
    _max?: SimulationRecordMaxAggregateInputType
  }

  export type SimulationRecordGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: string
    _count: SimulationRecordCountAggregateOutputType | null
    _avg: SimulationRecordAvgAggregateOutputType | null
    _sum: SimulationRecordSumAggregateOutputType | null
    _min: SimulationRecordMinAggregateOutputType | null
    _max: SimulationRecordMaxAggregateOutputType | null
  }

  type GetSimulationRecordGroupByPayload<T extends SimulationRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimulationRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimulationRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimulationRecordGroupByOutputType[P]>
            : GetScalarType<T[P], SimulationRecordGroupByOutputType[P]>
        }
      >
    >


  export type SimulationRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    kpis?: boolean | SimulationRecord$kpisArgs<ExtArgs>
    _count?: boolean | SimulationRecordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulationRecord"]>

  export type SimulationRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
  }, ExtArgs["result"]["simulationRecord"]>

  export type SimulationRecordSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
  }

  export type SimulationRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpis?: boolean | SimulationRecord$kpisArgs<ExtArgs>
    _count?: boolean | SimulationRecordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SimulationRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SimulationRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SimulationRecord"
    objects: {
      kpis: Prisma.$KpiRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      name: string
    }, ExtArgs["result"]["simulationRecord"]>
    composites: {}
  }

  type SimulationRecordGetPayload<S extends boolean | null | undefined | SimulationRecordDefaultArgs> = $Result.GetResult<Prisma.$SimulationRecordPayload, S>

  type SimulationRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SimulationRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SimulationRecordCountAggregateInputType | true
    }

  export interface SimulationRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SimulationRecord'], meta: { name: 'SimulationRecord' } }
    /**
     * Find zero or one SimulationRecord that matches the filter.
     * @param {SimulationRecordFindUniqueArgs} args - Arguments to find a SimulationRecord
     * @example
     * // Get one SimulationRecord
     * const simulationRecord = await prisma.simulationRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimulationRecordFindUniqueArgs>(args: SelectSubset<T, SimulationRecordFindUniqueArgs<ExtArgs>>): Prisma__SimulationRecordClient<$Result.GetResult<Prisma.$SimulationRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SimulationRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SimulationRecordFindUniqueOrThrowArgs} args - Arguments to find a SimulationRecord
     * @example
     * // Get one SimulationRecord
     * const simulationRecord = await prisma.simulationRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimulationRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, SimulationRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimulationRecordClient<$Result.GetResult<Prisma.$SimulationRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SimulationRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationRecordFindFirstArgs} args - Arguments to find a SimulationRecord
     * @example
     * // Get one SimulationRecord
     * const simulationRecord = await prisma.simulationRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimulationRecordFindFirstArgs>(args?: SelectSubset<T, SimulationRecordFindFirstArgs<ExtArgs>>): Prisma__SimulationRecordClient<$Result.GetResult<Prisma.$SimulationRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SimulationRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationRecordFindFirstOrThrowArgs} args - Arguments to find a SimulationRecord
     * @example
     * // Get one SimulationRecord
     * const simulationRecord = await prisma.simulationRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimulationRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, SimulationRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimulationRecordClient<$Result.GetResult<Prisma.$SimulationRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SimulationRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SimulationRecords
     * const simulationRecords = await prisma.simulationRecord.findMany()
     * 
     * // Get first 10 SimulationRecords
     * const simulationRecords = await prisma.simulationRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simulationRecordWithIdOnly = await prisma.simulationRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SimulationRecordFindManyArgs>(args?: SelectSubset<T, SimulationRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SimulationRecord.
     * @param {SimulationRecordCreateArgs} args - Arguments to create a SimulationRecord.
     * @example
     * // Create one SimulationRecord
     * const SimulationRecord = await prisma.simulationRecord.create({
     *   data: {
     *     // ... data to create a SimulationRecord
     *   }
     * })
     * 
     */
    create<T extends SimulationRecordCreateArgs>(args: SelectSubset<T, SimulationRecordCreateArgs<ExtArgs>>): Prisma__SimulationRecordClient<$Result.GetResult<Prisma.$SimulationRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SimulationRecords.
     * @param {SimulationRecordCreateManyArgs} args - Arguments to create many SimulationRecords.
     * @example
     * // Create many SimulationRecords
     * const simulationRecord = await prisma.simulationRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimulationRecordCreateManyArgs>(args?: SelectSubset<T, SimulationRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SimulationRecords and returns the data saved in the database.
     * @param {SimulationRecordCreateManyAndReturnArgs} args - Arguments to create many SimulationRecords.
     * @example
     * // Create many SimulationRecords
     * const simulationRecord = await prisma.simulationRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SimulationRecords and only return the `id`
     * const simulationRecordWithIdOnly = await prisma.simulationRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimulationRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, SimulationRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SimulationRecord.
     * @param {SimulationRecordDeleteArgs} args - Arguments to delete one SimulationRecord.
     * @example
     * // Delete one SimulationRecord
     * const SimulationRecord = await prisma.simulationRecord.delete({
     *   where: {
     *     // ... filter to delete one SimulationRecord
     *   }
     * })
     * 
     */
    delete<T extends SimulationRecordDeleteArgs>(args: SelectSubset<T, SimulationRecordDeleteArgs<ExtArgs>>): Prisma__SimulationRecordClient<$Result.GetResult<Prisma.$SimulationRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SimulationRecord.
     * @param {SimulationRecordUpdateArgs} args - Arguments to update one SimulationRecord.
     * @example
     * // Update one SimulationRecord
     * const simulationRecord = await prisma.simulationRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimulationRecordUpdateArgs>(args: SelectSubset<T, SimulationRecordUpdateArgs<ExtArgs>>): Prisma__SimulationRecordClient<$Result.GetResult<Prisma.$SimulationRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SimulationRecords.
     * @param {SimulationRecordDeleteManyArgs} args - Arguments to filter SimulationRecords to delete.
     * @example
     * // Delete a few SimulationRecords
     * const { count } = await prisma.simulationRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimulationRecordDeleteManyArgs>(args?: SelectSubset<T, SimulationRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimulationRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SimulationRecords
     * const simulationRecord = await prisma.simulationRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimulationRecordUpdateManyArgs>(args: SelectSubset<T, SimulationRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SimulationRecord.
     * @param {SimulationRecordUpsertArgs} args - Arguments to update or create a SimulationRecord.
     * @example
     * // Update or create a SimulationRecord
     * const simulationRecord = await prisma.simulationRecord.upsert({
     *   create: {
     *     // ... data to create a SimulationRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SimulationRecord we want to update
     *   }
     * })
     */
    upsert<T extends SimulationRecordUpsertArgs>(args: SelectSubset<T, SimulationRecordUpsertArgs<ExtArgs>>): Prisma__SimulationRecordClient<$Result.GetResult<Prisma.$SimulationRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SimulationRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationRecordCountArgs} args - Arguments to filter SimulationRecords to count.
     * @example
     * // Count the number of SimulationRecords
     * const count = await prisma.simulationRecord.count({
     *   where: {
     *     // ... the filter for the SimulationRecords we want to count
     *   }
     * })
    **/
    count<T extends SimulationRecordCountArgs>(
      args?: Subset<T, SimulationRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimulationRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SimulationRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimulationRecordAggregateArgs>(args: Subset<T, SimulationRecordAggregateArgs>): Prisma.PrismaPromise<GetSimulationRecordAggregateType<T>>

    /**
     * Group by SimulationRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimulationRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimulationRecordGroupByArgs['orderBy'] }
        : { orderBy?: SimulationRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimulationRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimulationRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SimulationRecord model
   */
  readonly fields: SimulationRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SimulationRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimulationRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kpis<T extends SimulationRecord$kpisArgs<ExtArgs> = {}>(args?: Subset<T, SimulationRecord$kpisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SimulationRecord model
   */ 
  interface SimulationRecordFieldRefs {
    readonly id: FieldRef<"SimulationRecord", 'Int'>
    readonly createdAt: FieldRef<"SimulationRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"SimulationRecord", 'DateTime'>
    readonly name: FieldRef<"SimulationRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SimulationRecord findUnique
   */
  export type SimulationRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationRecord
     */
    select?: SimulationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationRecordInclude<ExtArgs> | null
    /**
     * Filter, which SimulationRecord to fetch.
     */
    where: SimulationRecordWhereUniqueInput
  }

  /**
   * SimulationRecord findUniqueOrThrow
   */
  export type SimulationRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationRecord
     */
    select?: SimulationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationRecordInclude<ExtArgs> | null
    /**
     * Filter, which SimulationRecord to fetch.
     */
    where: SimulationRecordWhereUniqueInput
  }

  /**
   * SimulationRecord findFirst
   */
  export type SimulationRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationRecord
     */
    select?: SimulationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationRecordInclude<ExtArgs> | null
    /**
     * Filter, which SimulationRecord to fetch.
     */
    where?: SimulationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationRecords to fetch.
     */
    orderBy?: SimulationRecordOrderByWithRelationInput | SimulationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimulationRecords.
     */
    cursor?: SimulationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimulationRecords.
     */
    distinct?: SimulationRecordScalarFieldEnum | SimulationRecordScalarFieldEnum[]
  }

  /**
   * SimulationRecord findFirstOrThrow
   */
  export type SimulationRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationRecord
     */
    select?: SimulationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationRecordInclude<ExtArgs> | null
    /**
     * Filter, which SimulationRecord to fetch.
     */
    where?: SimulationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationRecords to fetch.
     */
    orderBy?: SimulationRecordOrderByWithRelationInput | SimulationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimulationRecords.
     */
    cursor?: SimulationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimulationRecords.
     */
    distinct?: SimulationRecordScalarFieldEnum | SimulationRecordScalarFieldEnum[]
  }

  /**
   * SimulationRecord findMany
   */
  export type SimulationRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationRecord
     */
    select?: SimulationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationRecordInclude<ExtArgs> | null
    /**
     * Filter, which SimulationRecords to fetch.
     */
    where?: SimulationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationRecords to fetch.
     */
    orderBy?: SimulationRecordOrderByWithRelationInput | SimulationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SimulationRecords.
     */
    cursor?: SimulationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationRecords.
     */
    skip?: number
    distinct?: SimulationRecordScalarFieldEnum | SimulationRecordScalarFieldEnum[]
  }

  /**
   * SimulationRecord create
   */
  export type SimulationRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationRecord
     */
    select?: SimulationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a SimulationRecord.
     */
    data: XOR<SimulationRecordCreateInput, SimulationRecordUncheckedCreateInput>
  }

  /**
   * SimulationRecord createMany
   */
  export type SimulationRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SimulationRecords.
     */
    data: SimulationRecordCreateManyInput | SimulationRecordCreateManyInput[]
  }

  /**
   * SimulationRecord createManyAndReturn
   */
  export type SimulationRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationRecord
     */
    select?: SimulationRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SimulationRecords.
     */
    data: SimulationRecordCreateManyInput | SimulationRecordCreateManyInput[]
  }

  /**
   * SimulationRecord update
   */
  export type SimulationRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationRecord
     */
    select?: SimulationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a SimulationRecord.
     */
    data: XOR<SimulationRecordUpdateInput, SimulationRecordUncheckedUpdateInput>
    /**
     * Choose, which SimulationRecord to update.
     */
    where: SimulationRecordWhereUniqueInput
  }

  /**
   * SimulationRecord updateMany
   */
  export type SimulationRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SimulationRecords.
     */
    data: XOR<SimulationRecordUpdateManyMutationInput, SimulationRecordUncheckedUpdateManyInput>
    /**
     * Filter which SimulationRecords to update
     */
    where?: SimulationRecordWhereInput
  }

  /**
   * SimulationRecord upsert
   */
  export type SimulationRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationRecord
     */
    select?: SimulationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the SimulationRecord to update in case it exists.
     */
    where: SimulationRecordWhereUniqueInput
    /**
     * In case the SimulationRecord found by the `where` argument doesn't exist, create a new SimulationRecord with this data.
     */
    create: XOR<SimulationRecordCreateInput, SimulationRecordUncheckedCreateInput>
    /**
     * In case the SimulationRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimulationRecordUpdateInput, SimulationRecordUncheckedUpdateInput>
  }

  /**
   * SimulationRecord delete
   */
  export type SimulationRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationRecord
     */
    select?: SimulationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationRecordInclude<ExtArgs> | null
    /**
     * Filter which SimulationRecord to delete.
     */
    where: SimulationRecordWhereUniqueInput
  }

  /**
   * SimulationRecord deleteMany
   */
  export type SimulationRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimulationRecords to delete
     */
    where?: SimulationRecordWhereInput
  }

  /**
   * SimulationRecord.kpis
   */
  export type SimulationRecord$kpisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiRecord
     */
    select?: KpiRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiRecordInclude<ExtArgs> | null
    where?: KpiRecordWhereInput
    orderBy?: KpiRecordOrderByWithRelationInput | KpiRecordOrderByWithRelationInput[]
    cursor?: KpiRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiRecordScalarFieldEnum | KpiRecordScalarFieldEnum[]
  }

  /**
   * SimulationRecord without action
   */
  export type SimulationRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationRecord
     */
    select?: SimulationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationRecordInclude<ExtArgs> | null
  }


  /**
   * Model KpiRecord
   */

  export type AggregateKpiRecord = {
    _count: KpiRecordCountAggregateOutputType | null
    _avg: KpiRecordAvgAggregateOutputType | null
    _sum: KpiRecordSumAggregateOutputType | null
    _min: KpiRecordMinAggregateOutputType | null
    _max: KpiRecordMaxAggregateOutputType | null
  }

  export type KpiRecordAvgAggregateOutputType = {
    id: number | null
    value: number | null
    simulationId: number | null
  }

  export type KpiRecordSumAggregateOutputType = {
    id: number | null
    value: number | null
    simulationId: number | null
  }

  export type KpiRecordMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    key: string | null
    value: number | null
    name: string | null
    simulationId: number | null
  }

  export type KpiRecordMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    key: string | null
    value: number | null
    name: string | null
    simulationId: number | null
  }

  export type KpiRecordCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    key: number
    value: number
    name: number
    simulationId: number
    _all: number
  }


  export type KpiRecordAvgAggregateInputType = {
    id?: true
    value?: true
    simulationId?: true
  }

  export type KpiRecordSumAggregateInputType = {
    id?: true
    value?: true
    simulationId?: true
  }

  export type KpiRecordMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    key?: true
    value?: true
    name?: true
    simulationId?: true
  }

  export type KpiRecordMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    key?: true
    value?: true
    name?: true
    simulationId?: true
  }

  export type KpiRecordCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    key?: true
    value?: true
    name?: true
    simulationId?: true
    _all?: true
  }

  export type KpiRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KpiRecord to aggregate.
     */
    where?: KpiRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiRecords to fetch.
     */
    orderBy?: KpiRecordOrderByWithRelationInput | KpiRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KpiRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KpiRecords
    **/
    _count?: true | KpiRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KpiRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KpiRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KpiRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KpiRecordMaxAggregateInputType
  }

  export type GetKpiRecordAggregateType<T extends KpiRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateKpiRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKpiRecord[P]>
      : GetScalarType<T[P], AggregateKpiRecord[P]>
  }




  export type KpiRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiRecordWhereInput
    orderBy?: KpiRecordOrderByWithAggregationInput | KpiRecordOrderByWithAggregationInput[]
    by: KpiRecordScalarFieldEnum[] | KpiRecordScalarFieldEnum
    having?: KpiRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KpiRecordCountAggregateInputType | true
    _avg?: KpiRecordAvgAggregateInputType
    _sum?: KpiRecordSumAggregateInputType
    _min?: KpiRecordMinAggregateInputType
    _max?: KpiRecordMaxAggregateInputType
  }

  export type KpiRecordGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    key: string
    value: number
    name: string | null
    simulationId: number
    _count: KpiRecordCountAggregateOutputType | null
    _avg: KpiRecordAvgAggregateOutputType | null
    _sum: KpiRecordSumAggregateOutputType | null
    _min: KpiRecordMinAggregateOutputType | null
    _max: KpiRecordMaxAggregateOutputType | null
  }

  type GetKpiRecordGroupByPayload<T extends KpiRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KpiRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KpiRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KpiRecordGroupByOutputType[P]>
            : GetScalarType<T[P], KpiRecordGroupByOutputType[P]>
        }
      >
    >


  export type KpiRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    key?: boolean
    value?: boolean
    name?: boolean
    simulationId?: boolean
    simulation?: boolean | SimulationRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kpiRecord"]>

  export type KpiRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    key?: boolean
    value?: boolean
    name?: boolean
    simulationId?: boolean
    simulation?: boolean | SimulationRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kpiRecord"]>

  export type KpiRecordSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    key?: boolean
    value?: boolean
    name?: boolean
    simulationId?: boolean
  }

  export type KpiRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationRecordDefaultArgs<ExtArgs>
  }
  export type KpiRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationRecordDefaultArgs<ExtArgs>
  }

  export type $KpiRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KpiRecord"
    objects: {
      simulation: Prisma.$SimulationRecordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      key: string
      value: number
      name: string | null
      simulationId: number
    }, ExtArgs["result"]["kpiRecord"]>
    composites: {}
  }

  type KpiRecordGetPayload<S extends boolean | null | undefined | KpiRecordDefaultArgs> = $Result.GetResult<Prisma.$KpiRecordPayload, S>

  type KpiRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KpiRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KpiRecordCountAggregateInputType | true
    }

  export interface KpiRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KpiRecord'], meta: { name: 'KpiRecord' } }
    /**
     * Find zero or one KpiRecord that matches the filter.
     * @param {KpiRecordFindUniqueArgs} args - Arguments to find a KpiRecord
     * @example
     * // Get one KpiRecord
     * const kpiRecord = await prisma.kpiRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KpiRecordFindUniqueArgs>(args: SelectSubset<T, KpiRecordFindUniqueArgs<ExtArgs>>): Prisma__KpiRecordClient<$Result.GetResult<Prisma.$KpiRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KpiRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KpiRecordFindUniqueOrThrowArgs} args - Arguments to find a KpiRecord
     * @example
     * // Get one KpiRecord
     * const kpiRecord = await prisma.kpiRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KpiRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, KpiRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KpiRecordClient<$Result.GetResult<Prisma.$KpiRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KpiRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiRecordFindFirstArgs} args - Arguments to find a KpiRecord
     * @example
     * // Get one KpiRecord
     * const kpiRecord = await prisma.kpiRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KpiRecordFindFirstArgs>(args?: SelectSubset<T, KpiRecordFindFirstArgs<ExtArgs>>): Prisma__KpiRecordClient<$Result.GetResult<Prisma.$KpiRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KpiRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiRecordFindFirstOrThrowArgs} args - Arguments to find a KpiRecord
     * @example
     * // Get one KpiRecord
     * const kpiRecord = await prisma.kpiRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KpiRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, KpiRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__KpiRecordClient<$Result.GetResult<Prisma.$KpiRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KpiRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KpiRecords
     * const kpiRecords = await prisma.kpiRecord.findMany()
     * 
     * // Get first 10 KpiRecords
     * const kpiRecords = await prisma.kpiRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kpiRecordWithIdOnly = await prisma.kpiRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KpiRecordFindManyArgs>(args?: SelectSubset<T, KpiRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KpiRecord.
     * @param {KpiRecordCreateArgs} args - Arguments to create a KpiRecord.
     * @example
     * // Create one KpiRecord
     * const KpiRecord = await prisma.kpiRecord.create({
     *   data: {
     *     // ... data to create a KpiRecord
     *   }
     * })
     * 
     */
    create<T extends KpiRecordCreateArgs>(args: SelectSubset<T, KpiRecordCreateArgs<ExtArgs>>): Prisma__KpiRecordClient<$Result.GetResult<Prisma.$KpiRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KpiRecords.
     * @param {KpiRecordCreateManyArgs} args - Arguments to create many KpiRecords.
     * @example
     * // Create many KpiRecords
     * const kpiRecord = await prisma.kpiRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KpiRecordCreateManyArgs>(args?: SelectSubset<T, KpiRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KpiRecords and returns the data saved in the database.
     * @param {KpiRecordCreateManyAndReturnArgs} args - Arguments to create many KpiRecords.
     * @example
     * // Create many KpiRecords
     * const kpiRecord = await prisma.kpiRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KpiRecords and only return the `id`
     * const kpiRecordWithIdOnly = await prisma.kpiRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KpiRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, KpiRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KpiRecord.
     * @param {KpiRecordDeleteArgs} args - Arguments to delete one KpiRecord.
     * @example
     * // Delete one KpiRecord
     * const KpiRecord = await prisma.kpiRecord.delete({
     *   where: {
     *     // ... filter to delete one KpiRecord
     *   }
     * })
     * 
     */
    delete<T extends KpiRecordDeleteArgs>(args: SelectSubset<T, KpiRecordDeleteArgs<ExtArgs>>): Prisma__KpiRecordClient<$Result.GetResult<Prisma.$KpiRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KpiRecord.
     * @param {KpiRecordUpdateArgs} args - Arguments to update one KpiRecord.
     * @example
     * // Update one KpiRecord
     * const kpiRecord = await prisma.kpiRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KpiRecordUpdateArgs>(args: SelectSubset<T, KpiRecordUpdateArgs<ExtArgs>>): Prisma__KpiRecordClient<$Result.GetResult<Prisma.$KpiRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KpiRecords.
     * @param {KpiRecordDeleteManyArgs} args - Arguments to filter KpiRecords to delete.
     * @example
     * // Delete a few KpiRecords
     * const { count } = await prisma.kpiRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KpiRecordDeleteManyArgs>(args?: SelectSubset<T, KpiRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KpiRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KpiRecords
     * const kpiRecord = await prisma.kpiRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KpiRecordUpdateManyArgs>(args: SelectSubset<T, KpiRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KpiRecord.
     * @param {KpiRecordUpsertArgs} args - Arguments to update or create a KpiRecord.
     * @example
     * // Update or create a KpiRecord
     * const kpiRecord = await prisma.kpiRecord.upsert({
     *   create: {
     *     // ... data to create a KpiRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KpiRecord we want to update
     *   }
     * })
     */
    upsert<T extends KpiRecordUpsertArgs>(args: SelectSubset<T, KpiRecordUpsertArgs<ExtArgs>>): Prisma__KpiRecordClient<$Result.GetResult<Prisma.$KpiRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KpiRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiRecordCountArgs} args - Arguments to filter KpiRecords to count.
     * @example
     * // Count the number of KpiRecords
     * const count = await prisma.kpiRecord.count({
     *   where: {
     *     // ... the filter for the KpiRecords we want to count
     *   }
     * })
    **/
    count<T extends KpiRecordCountArgs>(
      args?: Subset<T, KpiRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KpiRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KpiRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KpiRecordAggregateArgs>(args: Subset<T, KpiRecordAggregateArgs>): Prisma.PrismaPromise<GetKpiRecordAggregateType<T>>

    /**
     * Group by KpiRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KpiRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KpiRecordGroupByArgs['orderBy'] }
        : { orderBy?: KpiRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KpiRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKpiRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KpiRecord model
   */
  readonly fields: KpiRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KpiRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KpiRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    simulation<T extends SimulationRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SimulationRecordDefaultArgs<ExtArgs>>): Prisma__SimulationRecordClient<$Result.GetResult<Prisma.$SimulationRecordPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KpiRecord model
   */ 
  interface KpiRecordFieldRefs {
    readonly id: FieldRef<"KpiRecord", 'Int'>
    readonly createdAt: FieldRef<"KpiRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"KpiRecord", 'DateTime'>
    readonly key: FieldRef<"KpiRecord", 'String'>
    readonly value: FieldRef<"KpiRecord", 'Float'>
    readonly name: FieldRef<"KpiRecord", 'String'>
    readonly simulationId: FieldRef<"KpiRecord", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * KpiRecord findUnique
   */
  export type KpiRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiRecord
     */
    select?: KpiRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiRecordInclude<ExtArgs> | null
    /**
     * Filter, which KpiRecord to fetch.
     */
    where: KpiRecordWhereUniqueInput
  }

  /**
   * KpiRecord findUniqueOrThrow
   */
  export type KpiRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiRecord
     */
    select?: KpiRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiRecordInclude<ExtArgs> | null
    /**
     * Filter, which KpiRecord to fetch.
     */
    where: KpiRecordWhereUniqueInput
  }

  /**
   * KpiRecord findFirst
   */
  export type KpiRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiRecord
     */
    select?: KpiRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiRecordInclude<ExtArgs> | null
    /**
     * Filter, which KpiRecord to fetch.
     */
    where?: KpiRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiRecords to fetch.
     */
    orderBy?: KpiRecordOrderByWithRelationInput | KpiRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KpiRecords.
     */
    cursor?: KpiRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KpiRecords.
     */
    distinct?: KpiRecordScalarFieldEnum | KpiRecordScalarFieldEnum[]
  }

  /**
   * KpiRecord findFirstOrThrow
   */
  export type KpiRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiRecord
     */
    select?: KpiRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiRecordInclude<ExtArgs> | null
    /**
     * Filter, which KpiRecord to fetch.
     */
    where?: KpiRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiRecords to fetch.
     */
    orderBy?: KpiRecordOrderByWithRelationInput | KpiRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KpiRecords.
     */
    cursor?: KpiRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KpiRecords.
     */
    distinct?: KpiRecordScalarFieldEnum | KpiRecordScalarFieldEnum[]
  }

  /**
   * KpiRecord findMany
   */
  export type KpiRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiRecord
     */
    select?: KpiRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiRecordInclude<ExtArgs> | null
    /**
     * Filter, which KpiRecords to fetch.
     */
    where?: KpiRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiRecords to fetch.
     */
    orderBy?: KpiRecordOrderByWithRelationInput | KpiRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KpiRecords.
     */
    cursor?: KpiRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiRecords.
     */
    skip?: number
    distinct?: KpiRecordScalarFieldEnum | KpiRecordScalarFieldEnum[]
  }

  /**
   * KpiRecord create
   */
  export type KpiRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiRecord
     */
    select?: KpiRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a KpiRecord.
     */
    data: XOR<KpiRecordCreateInput, KpiRecordUncheckedCreateInput>
  }

  /**
   * KpiRecord createMany
   */
  export type KpiRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KpiRecords.
     */
    data: KpiRecordCreateManyInput | KpiRecordCreateManyInput[]
  }

  /**
   * KpiRecord createManyAndReturn
   */
  export type KpiRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiRecord
     */
    select?: KpiRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KpiRecords.
     */
    data: KpiRecordCreateManyInput | KpiRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KpiRecord update
   */
  export type KpiRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiRecord
     */
    select?: KpiRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a KpiRecord.
     */
    data: XOR<KpiRecordUpdateInput, KpiRecordUncheckedUpdateInput>
    /**
     * Choose, which KpiRecord to update.
     */
    where: KpiRecordWhereUniqueInput
  }

  /**
   * KpiRecord updateMany
   */
  export type KpiRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KpiRecords.
     */
    data: XOR<KpiRecordUpdateManyMutationInput, KpiRecordUncheckedUpdateManyInput>
    /**
     * Filter which KpiRecords to update
     */
    where?: KpiRecordWhereInput
  }

  /**
   * KpiRecord upsert
   */
  export type KpiRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiRecord
     */
    select?: KpiRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the KpiRecord to update in case it exists.
     */
    where: KpiRecordWhereUniqueInput
    /**
     * In case the KpiRecord found by the `where` argument doesn't exist, create a new KpiRecord with this data.
     */
    create: XOR<KpiRecordCreateInput, KpiRecordUncheckedCreateInput>
    /**
     * In case the KpiRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KpiRecordUpdateInput, KpiRecordUncheckedUpdateInput>
  }

  /**
   * KpiRecord delete
   */
  export type KpiRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiRecord
     */
    select?: KpiRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiRecordInclude<ExtArgs> | null
    /**
     * Filter which KpiRecord to delete.
     */
    where: KpiRecordWhereUniqueInput
  }

  /**
   * KpiRecord deleteMany
   */
  export type KpiRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KpiRecords to delete
     */
    where?: KpiRecordWhereInput
  }

  /**
   * KpiRecord without action
   */
  export type KpiRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiRecord
     */
    select?: KpiRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiRecordInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceAvgAggregateOutputType = {
    id: number | null
    locationId: number | null
    processStepId: number | null
    transportSystemId: number | null
    faultyRate: number | null
  }

  export type ResourceSumAggregateOutputType = {
    id: number | null
    locationId: number | null
    processStepId: number | null
    transportSystemId: number | null
    faultyRate: number | null
  }

  export type ResourceMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    active: boolean | null
    mandatory: boolean | null
    productionResource: boolean | null
    inventoryResource: boolean | null
    locationId: number | null
    processStepId: number | null
    transportSystemId: number | null
    faulty: boolean | null
    faultyRate: number | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    active: boolean | null
    mandatory: boolean | null
    productionResource: boolean | null
    inventoryResource: boolean | null
    locationId: number | null
    processStepId: number | null
    transportSystemId: number | null
    faulty: boolean | null
    faultyRate: number | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    active: number
    mandatory: number
    productionResource: number
    inventoryResource: number
    locationId: number
    processStepId: number
    transportSystemId: number
    faulty: number
    faultyRate: number
    _all: number
  }


  export type ResourceAvgAggregateInputType = {
    id?: true
    locationId?: true
    processStepId?: true
    transportSystemId?: true
    faultyRate?: true
  }

  export type ResourceSumAggregateInputType = {
    id?: true
    locationId?: true
    processStepId?: true
    transportSystemId?: true
    faultyRate?: true
  }

  export type ResourceMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    active?: true
    mandatory?: true
    productionResource?: true
    inventoryResource?: true
    locationId?: true
    processStepId?: true
    transportSystemId?: true
    faulty?: true
    faultyRate?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    active?: true
    mandatory?: true
    productionResource?: true
    inventoryResource?: true
    locationId?: true
    processStepId?: true
    transportSystemId?: true
    faulty?: true
    faultyRate?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    active?: true
    mandatory?: true
    productionResource?: true
    inventoryResource?: true
    locationId?: true
    processStepId?: true
    transportSystemId?: true
    faulty?: true
    faultyRate?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _avg?: ResourceAvgAggregateInputType
    _sum?: ResourceSumAggregateInputType
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: string | null
    active: boolean
    mandatory: boolean
    productionResource: boolean
    inventoryResource: boolean
    locationId: number
    processStepId: number | null
    transportSystemId: number | null
    faulty: boolean | null
    faultyRate: number
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    locationId?: boolean
    processStepId?: boolean
    transportSystemId?: boolean
    faulty?: boolean
    faultyRate?: boolean
    Machine?: boolean | Resource$MachineArgs<ExtArgs>
    processStep?: boolean | Resource$processStepArgs<ExtArgs>
    transportSystem?: boolean | Resource$transportSystemArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    Worker?: boolean | Resource$WorkerArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    locationId?: boolean
    processStepId?: boolean
    transportSystemId?: boolean
    faulty?: boolean
    faultyRate?: boolean
    processStep?: boolean | Resource$processStepArgs<ExtArgs>
    transportSystem?: boolean | Resource$transportSystemArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    locationId?: boolean
    processStepId?: boolean
    transportSystemId?: boolean
    faulty?: boolean
    faultyRate?: boolean
  }

  export type ResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Machine?: boolean | Resource$MachineArgs<ExtArgs>
    processStep?: boolean | Resource$processStepArgs<ExtArgs>
    transportSystem?: boolean | Resource$transportSystemArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    Worker?: boolean | Resource$WorkerArgs<ExtArgs>
  }
  export type ResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processStep?: boolean | Resource$processStepArgs<ExtArgs>
    transportSystem?: boolean | Resource$transportSystemArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {
      Machine: Prisma.$MachinePayload<ExtArgs> | null
      processStep: Prisma.$ProcessStepPayload<ExtArgs> | null
      transportSystem: Prisma.$TransportSystemPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs>
      Worker: Prisma.$WorkerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      name: string | null
      active: boolean
      mandatory: boolean
      productionResource: boolean
      inventoryResource: boolean
      locationId: number
      processStepId: number | null
      transportSystemId: number | null
      faulty: boolean | null
      faultyRate: number
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {ResourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Machine<T extends Resource$MachineArgs<ExtArgs> = {}>(args?: Subset<T, Resource$MachineArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    processStep<T extends Resource$processStepArgs<ExtArgs> = {}>(args?: Subset<T, Resource$processStepArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transportSystem<T extends Resource$transportSystemArgs<ExtArgs> = {}>(args?: Subset<T, Resource$transportSystemArgs<ExtArgs>>): Prisma__TransportSystemClient<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Worker<T extends Resource$WorkerArgs<ExtArgs> = {}>(args?: Subset<T, Resource$WorkerArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */ 
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'Int'>
    readonly createdAt: FieldRef<"Resource", 'DateTime'>
    readonly updatedAt: FieldRef<"Resource", 'DateTime'>
    readonly name: FieldRef<"Resource", 'String'>
    readonly active: FieldRef<"Resource", 'Boolean'>
    readonly mandatory: FieldRef<"Resource", 'Boolean'>
    readonly productionResource: FieldRef<"Resource", 'Boolean'>
    readonly inventoryResource: FieldRef<"Resource", 'Boolean'>
    readonly locationId: FieldRef<"Resource", 'Int'>
    readonly processStepId: FieldRef<"Resource", 'Int'>
    readonly transportSystemId: FieldRef<"Resource", 'Int'>
    readonly faulty: FieldRef<"Resource", 'Boolean'>
    readonly faultyRate: FieldRef<"Resource", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
  }

  /**
   * Resource createManyAndReturn
   */
  export type ResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
  }

  /**
   * Resource.Machine
   */
  export type Resource$MachineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    where?: MachineWhereInput
  }

  /**
   * Resource.processStep
   */
  export type Resource$processStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
  }

  /**
   * Resource.transportSystem
   */
  export type Resource$transportSystemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    where?: TransportSystemWhereInput
  }

  /**
   * Resource.Worker
   */
  export type Resource$WorkerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
  }


  /**
   * Model Machine
   */

  export type AggregateMachine = {
    _count: MachineCountAggregateOutputType | null
    _avg: MachineAvgAggregateOutputType | null
    _sum: MachineSumAggregateOutputType | null
    _min: MachineMinAggregateOutputType | null
    _max: MachineMaxAggregateOutputType | null
  }

  export type MachineAvgAggregateOutputType = {
    id: number | null
    resourceId: number | null
  }

  export type MachineSumAggregateOutputType = {
    id: number | null
    resourceId: number | null
  }

  export type MachineMinAggregateOutputType = {
    id: number | null
    resourceId: number | null
  }

  export type MachineMaxAggregateOutputType = {
    id: number | null
    resourceId: number | null
  }

  export type MachineCountAggregateOutputType = {
    id: number
    resourceId: number
    _all: number
  }


  export type MachineAvgAggregateInputType = {
    id?: true
    resourceId?: true
  }

  export type MachineSumAggregateInputType = {
    id?: true
    resourceId?: true
  }

  export type MachineMinAggregateInputType = {
    id?: true
    resourceId?: true
  }

  export type MachineMaxAggregateInputType = {
    id?: true
    resourceId?: true
  }

  export type MachineCountAggregateInputType = {
    id?: true
    resourceId?: true
    _all?: true
  }

  export type MachineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Machine to aggregate.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Machines
    **/
    _count?: true | MachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MachineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MachineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineMaxAggregateInputType
  }

  export type GetMachineAggregateType<T extends MachineAggregateArgs> = {
        [P in keyof T & keyof AggregateMachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachine[P]>
      : GetScalarType<T[P], AggregateMachine[P]>
  }




  export type MachineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineWhereInput
    orderBy?: MachineOrderByWithAggregationInput | MachineOrderByWithAggregationInput[]
    by: MachineScalarFieldEnum[] | MachineScalarFieldEnum
    having?: MachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineCountAggregateInputType | true
    _avg?: MachineAvgAggregateInputType
    _sum?: MachineSumAggregateInputType
    _min?: MachineMinAggregateInputType
    _max?: MachineMaxAggregateInputType
  }

  export type MachineGroupByOutputType = {
    id: number
    resourceId: number
    _count: MachineCountAggregateOutputType | null
    _avg: MachineAvgAggregateOutputType | null
    _sum: MachineSumAggregateOutputType | null
    _min: MachineMinAggregateOutputType | null
    _max: MachineMaxAggregateOutputType | null
  }

  type GetMachineGroupByPayload<T extends MachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineGroupByOutputType[P]>
            : GetScalarType<T[P], MachineGroupByOutputType[P]>
        }
      >
    >


  export type MachineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceId?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machine"]>

  export type MachineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceId?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machine"]>

  export type MachineSelectScalar = {
    id?: boolean
    resourceId?: boolean
  }

  export type MachineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type MachineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }

  export type $MachinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Machine"
    objects: {
      resource: Prisma.$ResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      resourceId: number
    }, ExtArgs["result"]["machine"]>
    composites: {}
  }

  type MachineGetPayload<S extends boolean | null | undefined | MachineDefaultArgs> = $Result.GetResult<Prisma.$MachinePayload, S>

  type MachineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MachineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MachineCountAggregateInputType | true
    }

  export interface MachineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Machine'], meta: { name: 'Machine' } }
    /**
     * Find zero or one Machine that matches the filter.
     * @param {MachineFindUniqueArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MachineFindUniqueArgs>(args: SelectSubset<T, MachineFindUniqueArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Machine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MachineFindUniqueOrThrowArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MachineFindUniqueOrThrowArgs>(args: SelectSubset<T, MachineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Machine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindFirstArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MachineFindFirstArgs>(args?: SelectSubset<T, MachineFindFirstArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Machine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindFirstOrThrowArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MachineFindFirstOrThrowArgs>(args?: SelectSubset<T, MachineFindFirstOrThrowArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Machines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Machines
     * const machines = await prisma.machine.findMany()
     * 
     * // Get first 10 Machines
     * const machines = await prisma.machine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineWithIdOnly = await prisma.machine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MachineFindManyArgs>(args?: SelectSubset<T, MachineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Machine.
     * @param {MachineCreateArgs} args - Arguments to create a Machine.
     * @example
     * // Create one Machine
     * const Machine = await prisma.machine.create({
     *   data: {
     *     // ... data to create a Machine
     *   }
     * })
     * 
     */
    create<T extends MachineCreateArgs>(args: SelectSubset<T, MachineCreateArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Machines.
     * @param {MachineCreateManyArgs} args - Arguments to create many Machines.
     * @example
     * // Create many Machines
     * const machine = await prisma.machine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MachineCreateManyArgs>(args?: SelectSubset<T, MachineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Machines and returns the data saved in the database.
     * @param {MachineCreateManyAndReturnArgs} args - Arguments to create many Machines.
     * @example
     * // Create many Machines
     * const machine = await prisma.machine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Machines and only return the `id`
     * const machineWithIdOnly = await prisma.machine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MachineCreateManyAndReturnArgs>(args?: SelectSubset<T, MachineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Machine.
     * @param {MachineDeleteArgs} args - Arguments to delete one Machine.
     * @example
     * // Delete one Machine
     * const Machine = await prisma.machine.delete({
     *   where: {
     *     // ... filter to delete one Machine
     *   }
     * })
     * 
     */
    delete<T extends MachineDeleteArgs>(args: SelectSubset<T, MachineDeleteArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Machine.
     * @param {MachineUpdateArgs} args - Arguments to update one Machine.
     * @example
     * // Update one Machine
     * const machine = await prisma.machine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MachineUpdateArgs>(args: SelectSubset<T, MachineUpdateArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Machines.
     * @param {MachineDeleteManyArgs} args - Arguments to filter Machines to delete.
     * @example
     * // Delete a few Machines
     * const { count } = await prisma.machine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MachineDeleteManyArgs>(args?: SelectSubset<T, MachineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Machines
     * const machine = await prisma.machine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MachineUpdateManyArgs>(args: SelectSubset<T, MachineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Machine.
     * @param {MachineUpsertArgs} args - Arguments to update or create a Machine.
     * @example
     * // Update or create a Machine
     * const machine = await prisma.machine.upsert({
     *   create: {
     *     // ... data to create a Machine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Machine we want to update
     *   }
     * })
     */
    upsert<T extends MachineUpsertArgs>(args: SelectSubset<T, MachineUpsertArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineCountArgs} args - Arguments to filter Machines to count.
     * @example
     * // Count the number of Machines
     * const count = await prisma.machine.count({
     *   where: {
     *     // ... the filter for the Machines we want to count
     *   }
     * })
    **/
    count<T extends MachineCountArgs>(
      args?: Subset<T, MachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Machine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineAggregateArgs>(args: Subset<T, MachineAggregateArgs>): Prisma.PrismaPromise<GetMachineAggregateType<T>>

    /**
     * Group by Machine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineGroupByArgs['orderBy'] }
        : { orderBy?: MachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Machine model
   */
  readonly fields: MachineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Machine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MachineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Machine model
   */ 
  interface MachineFieldRefs {
    readonly id: FieldRef<"Machine", 'Int'>
    readonly resourceId: FieldRef<"Machine", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Machine findUnique
   */
  export type MachineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine findUniqueOrThrow
   */
  export type MachineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine findFirst
   */
  export type MachineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Machines.
     */
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine findFirstOrThrow
   */
  export type MachineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Machines.
     */
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine findMany
   */
  export type MachineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machines to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine create
   */
  export type MachineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The data needed to create a Machine.
     */
    data: XOR<MachineCreateInput, MachineUncheckedCreateInput>
  }

  /**
   * Machine createMany
   */
  export type MachineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Machines.
     */
    data: MachineCreateManyInput | MachineCreateManyInput[]
  }

  /**
   * Machine createManyAndReturn
   */
  export type MachineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Machines.
     */
    data: MachineCreateManyInput | MachineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Machine update
   */
  export type MachineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The data needed to update a Machine.
     */
    data: XOR<MachineUpdateInput, MachineUncheckedUpdateInput>
    /**
     * Choose, which Machine to update.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine updateMany
   */
  export type MachineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Machines.
     */
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyInput>
    /**
     * Filter which Machines to update
     */
    where?: MachineWhereInput
  }

  /**
   * Machine upsert
   */
  export type MachineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The filter to search for the Machine to update in case it exists.
     */
    where: MachineWhereUniqueInput
    /**
     * In case the Machine found by the `where` argument doesn't exist, create a new Machine with this data.
     */
    create: XOR<MachineCreateInput, MachineUncheckedCreateInput>
    /**
     * In case the Machine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineUpdateInput, MachineUncheckedUpdateInput>
  }

  /**
   * Machine delete
   */
  export type MachineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter which Machine to delete.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine deleteMany
   */
  export type MachineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Machines to delete
     */
    where?: MachineWhereInput
  }

  /**
   * Machine without action
   */
  export type MachineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
  }


  /**
   * Model Worker
   */

  export type AggregateWorker = {
    _count: WorkerCountAggregateOutputType | null
    _avg: WorkerAvgAggregateOutputType | null
    _sum: WorkerSumAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  export type WorkerAvgAggregateOutputType = {
    id: number | null
    resourceId: number | null
  }

  export type WorkerSumAggregateOutputType = {
    id: number | null
    resourceId: number | null
  }

  export type WorkerMinAggregateOutputType = {
    id: number | null
    workerNumber: string | null
    fullName: string | null
    address: string | null
    resourceId: number | null
  }

  export type WorkerMaxAggregateOutputType = {
    id: number | null
    workerNumber: string | null
    fullName: string | null
    address: string | null
    resourceId: number | null
  }

  export type WorkerCountAggregateOutputType = {
    id: number
    workerNumber: number
    fullName: number
    address: number
    resourceId: number
    _all: number
  }


  export type WorkerAvgAggregateInputType = {
    id?: true
    resourceId?: true
  }

  export type WorkerSumAggregateInputType = {
    id?: true
    resourceId?: true
  }

  export type WorkerMinAggregateInputType = {
    id?: true
    workerNumber?: true
    fullName?: true
    address?: true
    resourceId?: true
  }

  export type WorkerMaxAggregateInputType = {
    id?: true
    workerNumber?: true
    fullName?: true
    address?: true
    resourceId?: true
  }

  export type WorkerCountAggregateInputType = {
    id?: true
    workerNumber?: true
    fullName?: true
    address?: true
    resourceId?: true
    _all?: true
  }

  export type WorkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Worker to aggregate.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workers
    **/
    _count?: true | WorkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerMaxAggregateInputType
  }

  export type GetWorkerAggregateType<T extends WorkerAggregateArgs> = {
        [P in keyof T & keyof AggregateWorker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorker[P]>
      : GetScalarType<T[P], AggregateWorker[P]>
  }




  export type WorkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithAggregationInput | WorkerOrderByWithAggregationInput[]
    by: WorkerScalarFieldEnum[] | WorkerScalarFieldEnum
    having?: WorkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerCountAggregateInputType | true
    _avg?: WorkerAvgAggregateInputType
    _sum?: WorkerSumAggregateInputType
    _min?: WorkerMinAggregateInputType
    _max?: WorkerMaxAggregateInputType
  }

  export type WorkerGroupByOutputType = {
    id: number
    workerNumber: string
    fullName: string
    address: string
    resourceId: number
    _count: WorkerCountAggregateOutputType | null
    _avg: WorkerAvgAggregateOutputType | null
    _sum: WorkerSumAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  type GetWorkerGroupByPayload<T extends WorkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerGroupByOutputType[P]>
        }
      >
    >


  export type WorkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workerNumber?: boolean
    fullName?: boolean
    address?: boolean
    resourceId?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    workerRoles?: boolean | Worker$workerRolesArgs<ExtArgs>
    _count?: boolean | WorkerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workerNumber?: boolean
    fullName?: boolean
    address?: boolean
    resourceId?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectScalar = {
    id?: boolean
    workerNumber?: boolean
    fullName?: boolean
    address?: boolean
    resourceId?: boolean
  }

  export type WorkerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    workerRoles?: boolean | Worker$workerRolesArgs<ExtArgs>
    _count?: boolean | WorkerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }

  export type $WorkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Worker"
    objects: {
      resource: Prisma.$ResourcePayload<ExtArgs>
      workerRoles: Prisma.$WorkerRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      workerNumber: string
      fullName: string
      address: string
      resourceId: number
    }, ExtArgs["result"]["worker"]>
    composites: {}
  }

  type WorkerGetPayload<S extends boolean | null | undefined | WorkerDefaultArgs> = $Result.GetResult<Prisma.$WorkerPayload, S>

  type WorkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkerCountAggregateInputType | true
    }

  export interface WorkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Worker'], meta: { name: 'Worker' } }
    /**
     * Find zero or one Worker that matches the filter.
     * @param {WorkerFindUniqueArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerFindUniqueArgs>(args: SelectSubset<T, WorkerFindUniqueArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Worker that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkerFindUniqueOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Worker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerFindFirstArgs>(args?: SelectSubset<T, WorkerFindFirstArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Worker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workers
     * const workers = await prisma.worker.findMany()
     * 
     * // Get first 10 Workers
     * const workers = await prisma.worker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerWithIdOnly = await prisma.worker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerFindManyArgs>(args?: SelectSubset<T, WorkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Worker.
     * @param {WorkerCreateArgs} args - Arguments to create a Worker.
     * @example
     * // Create one Worker
     * const Worker = await prisma.worker.create({
     *   data: {
     *     // ... data to create a Worker
     *   }
     * })
     * 
     */
    create<T extends WorkerCreateArgs>(args: SelectSubset<T, WorkerCreateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workers.
     * @param {WorkerCreateManyArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerCreateManyArgs>(args?: SelectSubset<T, WorkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workers and returns the data saved in the database.
     * @param {WorkerCreateManyAndReturnArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workers and only return the `id`
     * const workerWithIdOnly = await prisma.worker.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkerCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Worker.
     * @param {WorkerDeleteArgs} args - Arguments to delete one Worker.
     * @example
     * // Delete one Worker
     * const Worker = await prisma.worker.delete({
     *   where: {
     *     // ... filter to delete one Worker
     *   }
     * })
     * 
     */
    delete<T extends WorkerDeleteArgs>(args: SelectSubset<T, WorkerDeleteArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Worker.
     * @param {WorkerUpdateArgs} args - Arguments to update one Worker.
     * @example
     * // Update one Worker
     * const worker = await prisma.worker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerUpdateArgs>(args: SelectSubset<T, WorkerUpdateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workers.
     * @param {WorkerDeleteManyArgs} args - Arguments to filter Workers to delete.
     * @example
     * // Delete a few Workers
     * const { count } = await prisma.worker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerDeleteManyArgs>(args?: SelectSubset<T, WorkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workers
     * const worker = await prisma.worker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerUpdateManyArgs>(args: SelectSubset<T, WorkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Worker.
     * @param {WorkerUpsertArgs} args - Arguments to update or create a Worker.
     * @example
     * // Update or create a Worker
     * const worker = await prisma.worker.upsert({
     *   create: {
     *     // ... data to create a Worker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Worker we want to update
     *   }
     * })
     */
    upsert<T extends WorkerUpsertArgs>(args: SelectSubset<T, WorkerUpsertArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerCountArgs} args - Arguments to filter Workers to count.
     * @example
     * // Count the number of Workers
     * const count = await prisma.worker.count({
     *   where: {
     *     // ... the filter for the Workers we want to count
     *   }
     * })
    **/
    count<T extends WorkerCountArgs>(
      args?: Subset<T, WorkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerAggregateArgs>(args: Subset<T, WorkerAggregateArgs>): Prisma.PrismaPromise<GetWorkerAggregateType<T>>

    /**
     * Group by Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerGroupByArgs['orderBy'] }
        : { orderBy?: WorkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Worker model
   */
  readonly fields: WorkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Worker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workerRoles<T extends Worker$workerRolesArgs<ExtArgs> = {}>(args?: Subset<T, Worker$workerRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Worker model
   */ 
  interface WorkerFieldRefs {
    readonly id: FieldRef<"Worker", 'Int'>
    readonly workerNumber: FieldRef<"Worker", 'String'>
    readonly fullName: FieldRef<"Worker", 'String'>
    readonly address: FieldRef<"Worker", 'String'>
    readonly resourceId: FieldRef<"Worker", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Worker findUnique
   */
  export type WorkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findUniqueOrThrow
   */
  export type WorkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findFirst
   */
  export type WorkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findFirstOrThrow
   */
  export type WorkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findMany
   */
  export type WorkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Workers to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker create
   */
  export type WorkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to create a Worker.
     */
    data: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
  }

  /**
   * Worker createMany
   */
  export type WorkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
  }

  /**
   * Worker createManyAndReturn
   */
  export type WorkerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Worker update
   */
  export type WorkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to update a Worker.
     */
    data: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
    /**
     * Choose, which Worker to update.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker updateMany
   */
  export type WorkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workers.
     */
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyInput>
    /**
     * Filter which Workers to update
     */
    where?: WorkerWhereInput
  }

  /**
   * Worker upsert
   */
  export type WorkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The filter to search for the Worker to update in case it exists.
     */
    where: WorkerWhereUniqueInput
    /**
     * In case the Worker found by the `where` argument doesn't exist, create a new Worker with this data.
     */
    create: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
    /**
     * In case the Worker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
  }

  /**
   * Worker delete
   */
  export type WorkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter which Worker to delete.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker deleteMany
   */
  export type WorkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workers to delete
     */
    where?: WorkerWhereInput
  }

  /**
   * Worker.workerRoles
   */
  export type Worker$workerRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRole
     */
    select?: WorkerRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRoleInclude<ExtArgs> | null
    where?: WorkerRoleWhereInput
    orderBy?: WorkerRoleOrderByWithRelationInput | WorkerRoleOrderByWithRelationInput[]
    cursor?: WorkerRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerRoleScalarFieldEnum | WorkerRoleScalarFieldEnum[]
  }

  /**
   * Worker without action
   */
  export type WorkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
  }


  /**
   * Model WorkerRole
   */

  export type AggregateWorkerRole = {
    _count: WorkerRoleCountAggregateOutputType | null
    _avg: WorkerRoleAvgAggregateOutputType | null
    _sum: WorkerRoleSumAggregateOutputType | null
    _min: WorkerRoleMinAggregateOutputType | null
    _max: WorkerRoleMaxAggregateOutputType | null
  }

  export type WorkerRoleAvgAggregateOutputType = {
    id: number | null
  }

  export type WorkerRoleSumAggregateOutputType = {
    id: number | null
  }

  export type WorkerRoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type WorkerRoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type WorkerRoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type WorkerRoleAvgAggregateInputType = {
    id?: true
  }

  export type WorkerRoleSumAggregateInputType = {
    id?: true
  }

  export type WorkerRoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type WorkerRoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type WorkerRoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type WorkerRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerRole to aggregate.
     */
    where?: WorkerRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerRoles to fetch.
     */
    orderBy?: WorkerRoleOrderByWithRelationInput | WorkerRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkerRoles
    **/
    _count?: true | WorkerRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkerRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkerRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerRoleMaxAggregateInputType
  }

  export type GetWorkerRoleAggregateType<T extends WorkerRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkerRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkerRole[P]>
      : GetScalarType<T[P], AggregateWorkerRole[P]>
  }




  export type WorkerRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerRoleWhereInput
    orderBy?: WorkerRoleOrderByWithAggregationInput | WorkerRoleOrderByWithAggregationInput[]
    by: WorkerRoleScalarFieldEnum[] | WorkerRoleScalarFieldEnum
    having?: WorkerRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerRoleCountAggregateInputType | true
    _avg?: WorkerRoleAvgAggregateInputType
    _sum?: WorkerRoleSumAggregateInputType
    _min?: WorkerRoleMinAggregateInputType
    _max?: WorkerRoleMaxAggregateInputType
  }

  export type WorkerRoleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: WorkerRoleCountAggregateOutputType | null
    _avg: WorkerRoleAvgAggregateOutputType | null
    _sum: WorkerRoleSumAggregateOutputType | null
    _min: WorkerRoleMinAggregateOutputType | null
    _max: WorkerRoleMaxAggregateOutputType | null
  }

  type GetWorkerRoleGroupByPayload<T extends WorkerRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerRoleGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerRoleGroupByOutputType[P]>
        }
      >
    >


  export type WorkerRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    workers?: boolean | WorkerRole$workersArgs<ExtArgs>
    _count?: boolean | WorkerRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerRole"]>

  export type WorkerRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["workerRole"]>

  export type WorkerRoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type WorkerRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workers?: boolean | WorkerRole$workersArgs<ExtArgs>
    _count?: boolean | WorkerRoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkerRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkerRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkerRole"
    objects: {
      workers: Prisma.$WorkerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
    }, ExtArgs["result"]["workerRole"]>
    composites: {}
  }

  type WorkerRoleGetPayload<S extends boolean | null | undefined | WorkerRoleDefaultArgs> = $Result.GetResult<Prisma.$WorkerRolePayload, S>

  type WorkerRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkerRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkerRoleCountAggregateInputType | true
    }

  export interface WorkerRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkerRole'], meta: { name: 'WorkerRole' } }
    /**
     * Find zero or one WorkerRole that matches the filter.
     * @param {WorkerRoleFindUniqueArgs} args - Arguments to find a WorkerRole
     * @example
     * // Get one WorkerRole
     * const workerRole = await prisma.workerRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerRoleFindUniqueArgs>(args: SelectSubset<T, WorkerRoleFindUniqueArgs<ExtArgs>>): Prisma__WorkerRoleClient<$Result.GetResult<Prisma.$WorkerRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkerRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkerRoleFindUniqueOrThrowArgs} args - Arguments to find a WorkerRole
     * @example
     * // Get one WorkerRole
     * const workerRole = await prisma.workerRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerRoleClient<$Result.GetResult<Prisma.$WorkerRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkerRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerRoleFindFirstArgs} args - Arguments to find a WorkerRole
     * @example
     * // Get one WorkerRole
     * const workerRole = await prisma.workerRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerRoleFindFirstArgs>(args?: SelectSubset<T, WorkerRoleFindFirstArgs<ExtArgs>>): Prisma__WorkerRoleClient<$Result.GetResult<Prisma.$WorkerRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkerRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerRoleFindFirstOrThrowArgs} args - Arguments to find a WorkerRole
     * @example
     * // Get one WorkerRole
     * const workerRole = await prisma.workerRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerRoleClient<$Result.GetResult<Prisma.$WorkerRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkerRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkerRoles
     * const workerRoles = await prisma.workerRole.findMany()
     * 
     * // Get first 10 WorkerRoles
     * const workerRoles = await prisma.workerRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerRoleWithIdOnly = await prisma.workerRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerRoleFindManyArgs>(args?: SelectSubset<T, WorkerRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkerRole.
     * @param {WorkerRoleCreateArgs} args - Arguments to create a WorkerRole.
     * @example
     * // Create one WorkerRole
     * const WorkerRole = await prisma.workerRole.create({
     *   data: {
     *     // ... data to create a WorkerRole
     *   }
     * })
     * 
     */
    create<T extends WorkerRoleCreateArgs>(args: SelectSubset<T, WorkerRoleCreateArgs<ExtArgs>>): Prisma__WorkerRoleClient<$Result.GetResult<Prisma.$WorkerRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkerRoles.
     * @param {WorkerRoleCreateManyArgs} args - Arguments to create many WorkerRoles.
     * @example
     * // Create many WorkerRoles
     * const workerRole = await prisma.workerRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerRoleCreateManyArgs>(args?: SelectSubset<T, WorkerRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkerRoles and returns the data saved in the database.
     * @param {WorkerRoleCreateManyAndReturnArgs} args - Arguments to create many WorkerRoles.
     * @example
     * // Create many WorkerRoles
     * const workerRole = await prisma.workerRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkerRoles and only return the `id`
     * const workerRoleWithIdOnly = await prisma.workerRole.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkerRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkerRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkerRole.
     * @param {WorkerRoleDeleteArgs} args - Arguments to delete one WorkerRole.
     * @example
     * // Delete one WorkerRole
     * const WorkerRole = await prisma.workerRole.delete({
     *   where: {
     *     // ... filter to delete one WorkerRole
     *   }
     * })
     * 
     */
    delete<T extends WorkerRoleDeleteArgs>(args: SelectSubset<T, WorkerRoleDeleteArgs<ExtArgs>>): Prisma__WorkerRoleClient<$Result.GetResult<Prisma.$WorkerRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkerRole.
     * @param {WorkerRoleUpdateArgs} args - Arguments to update one WorkerRole.
     * @example
     * // Update one WorkerRole
     * const workerRole = await prisma.workerRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerRoleUpdateArgs>(args: SelectSubset<T, WorkerRoleUpdateArgs<ExtArgs>>): Prisma__WorkerRoleClient<$Result.GetResult<Prisma.$WorkerRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkerRoles.
     * @param {WorkerRoleDeleteManyArgs} args - Arguments to filter WorkerRoles to delete.
     * @example
     * // Delete a few WorkerRoles
     * const { count } = await prisma.workerRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerRoleDeleteManyArgs>(args?: SelectSubset<T, WorkerRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkerRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkerRoles
     * const workerRole = await prisma.workerRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerRoleUpdateManyArgs>(args: SelectSubset<T, WorkerRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkerRole.
     * @param {WorkerRoleUpsertArgs} args - Arguments to update or create a WorkerRole.
     * @example
     * // Update or create a WorkerRole
     * const workerRole = await prisma.workerRole.upsert({
     *   create: {
     *     // ... data to create a WorkerRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkerRole we want to update
     *   }
     * })
     */
    upsert<T extends WorkerRoleUpsertArgs>(args: SelectSubset<T, WorkerRoleUpsertArgs<ExtArgs>>): Prisma__WorkerRoleClient<$Result.GetResult<Prisma.$WorkerRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkerRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerRoleCountArgs} args - Arguments to filter WorkerRoles to count.
     * @example
     * // Count the number of WorkerRoles
     * const count = await prisma.workerRole.count({
     *   where: {
     *     // ... the filter for the WorkerRoles we want to count
     *   }
     * })
    **/
    count<T extends WorkerRoleCountArgs>(
      args?: Subset<T, WorkerRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkerRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerRoleAggregateArgs>(args: Subset<T, WorkerRoleAggregateArgs>): Prisma.PrismaPromise<GetWorkerRoleAggregateType<T>>

    /**
     * Group by WorkerRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerRoleGroupByArgs['orderBy'] }
        : { orderBy?: WorkerRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkerRole model
   */
  readonly fields: WorkerRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkerRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workers<T extends WorkerRole$workersArgs<ExtArgs> = {}>(args?: Subset<T, WorkerRole$workersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkerRole model
   */ 
  interface WorkerRoleFieldRefs {
    readonly id: FieldRef<"WorkerRole", 'Int'>
    readonly name: FieldRef<"WorkerRole", 'String'>
    readonly description: FieldRef<"WorkerRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkerRole findUnique
   */
  export type WorkerRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRole
     */
    select?: WorkerRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkerRole to fetch.
     */
    where: WorkerRoleWhereUniqueInput
  }

  /**
   * WorkerRole findUniqueOrThrow
   */
  export type WorkerRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRole
     */
    select?: WorkerRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkerRole to fetch.
     */
    where: WorkerRoleWhereUniqueInput
  }

  /**
   * WorkerRole findFirst
   */
  export type WorkerRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRole
     */
    select?: WorkerRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkerRole to fetch.
     */
    where?: WorkerRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerRoles to fetch.
     */
    orderBy?: WorkerRoleOrderByWithRelationInput | WorkerRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerRoles.
     */
    cursor?: WorkerRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerRoles.
     */
    distinct?: WorkerRoleScalarFieldEnum | WorkerRoleScalarFieldEnum[]
  }

  /**
   * WorkerRole findFirstOrThrow
   */
  export type WorkerRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRole
     */
    select?: WorkerRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkerRole to fetch.
     */
    where?: WorkerRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerRoles to fetch.
     */
    orderBy?: WorkerRoleOrderByWithRelationInput | WorkerRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerRoles.
     */
    cursor?: WorkerRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerRoles.
     */
    distinct?: WorkerRoleScalarFieldEnum | WorkerRoleScalarFieldEnum[]
  }

  /**
   * WorkerRole findMany
   */
  export type WorkerRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRole
     */
    select?: WorkerRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkerRoles to fetch.
     */
    where?: WorkerRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerRoles to fetch.
     */
    orderBy?: WorkerRoleOrderByWithRelationInput | WorkerRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkerRoles.
     */
    cursor?: WorkerRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerRoles.
     */
    skip?: number
    distinct?: WorkerRoleScalarFieldEnum | WorkerRoleScalarFieldEnum[]
  }

  /**
   * WorkerRole create
   */
  export type WorkerRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRole
     */
    select?: WorkerRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkerRole.
     */
    data: XOR<WorkerRoleCreateInput, WorkerRoleUncheckedCreateInput>
  }

  /**
   * WorkerRole createMany
   */
  export type WorkerRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkerRoles.
     */
    data: WorkerRoleCreateManyInput | WorkerRoleCreateManyInput[]
  }

  /**
   * WorkerRole createManyAndReturn
   */
  export type WorkerRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRole
     */
    select?: WorkerRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkerRoles.
     */
    data: WorkerRoleCreateManyInput | WorkerRoleCreateManyInput[]
  }

  /**
   * WorkerRole update
   */
  export type WorkerRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRole
     */
    select?: WorkerRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkerRole.
     */
    data: XOR<WorkerRoleUpdateInput, WorkerRoleUncheckedUpdateInput>
    /**
     * Choose, which WorkerRole to update.
     */
    where: WorkerRoleWhereUniqueInput
  }

  /**
   * WorkerRole updateMany
   */
  export type WorkerRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkerRoles.
     */
    data: XOR<WorkerRoleUpdateManyMutationInput, WorkerRoleUncheckedUpdateManyInput>
    /**
     * Filter which WorkerRoles to update
     */
    where?: WorkerRoleWhereInput
  }

  /**
   * WorkerRole upsert
   */
  export type WorkerRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRole
     */
    select?: WorkerRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkerRole to update in case it exists.
     */
    where: WorkerRoleWhereUniqueInput
    /**
     * In case the WorkerRole found by the `where` argument doesn't exist, create a new WorkerRole with this data.
     */
    create: XOR<WorkerRoleCreateInput, WorkerRoleUncheckedCreateInput>
    /**
     * In case the WorkerRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerRoleUpdateInput, WorkerRoleUncheckedUpdateInput>
  }

  /**
   * WorkerRole delete
   */
  export type WorkerRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRole
     */
    select?: WorkerRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRoleInclude<ExtArgs> | null
    /**
     * Filter which WorkerRole to delete.
     */
    where: WorkerRoleWhereUniqueInput
  }

  /**
   * WorkerRole deleteMany
   */
  export type WorkerRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerRoles to delete
     */
    where?: WorkerRoleWhereInput
  }

  /**
   * WorkerRole.workers
   */
  export type WorkerRole$workersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    cursor?: WorkerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * WorkerRole without action
   */
  export type WorkerRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRole
     */
    select?: WorkerRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRoleInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    id: number | null
    limit: number | null
  }

  export type InventorySumAggregateOutputType = {
    id: number | null
    limit: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    type: string | null
    limit: number | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    type: string | null
    limit: number | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    type: number
    limit: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    id?: true
    limit?: true
  }

  export type InventorySumAggregateInputType = {
    id?: true
    limit?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    limit?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    limit?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    limit?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    type: string
    limit: number
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    limit?: boolean
    entries?: boolean | Inventory$entriesArgs<ExtArgs>
    processStep?: boolean | Inventory$processStepArgs<ExtArgs>
    transportSystem?: boolean | Inventory$transportSystemArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    limit?: boolean
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    limit?: boolean
  }

  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | Inventory$entriesArgs<ExtArgs>
    processStep?: boolean | Inventory$processStepArgs<ExtArgs>
    transportSystem?: boolean | Inventory$transportSystemArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      entries: Prisma.$InventoryEntryPayload<ExtArgs>[]
      processStep: Prisma.$ProcessStepPayload<ExtArgs> | null
      transportSystem: Prisma.$TransportSystemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      type: string
      limit: number
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {InventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entries<T extends Inventory$entriesArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryEntryPayload<ExtArgs>, T, "findMany"> | Null>
    processStep<T extends Inventory$processStepArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$processStepArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transportSystem<T extends Inventory$transportSystemArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$transportSystemArgs<ExtArgs>>): Prisma__TransportSystemClient<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */ 
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'Int'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
    readonly type: FieldRef<"Inventory", 'String'>
    readonly limit: FieldRef<"Inventory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
  }

  /**
   * Inventory createManyAndReturn
   */
  export type InventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
  }

  /**
   * Inventory.entries
   */
  export type Inventory$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryEntry
     */
    select?: InventoryEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryEntryInclude<ExtArgs> | null
    where?: InventoryEntryWhereInput
    orderBy?: InventoryEntryOrderByWithRelationInput | InventoryEntryOrderByWithRelationInput[]
    cursor?: InventoryEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryEntryScalarFieldEnum | InventoryEntryScalarFieldEnum[]
  }

  /**
   * Inventory.processStep
   */
  export type Inventory$processStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
  }

  /**
   * Inventory.transportSystem
   */
  export type Inventory$transportSystemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    where?: TransportSystemWhereInput
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model InventoryEntry
   */

  export type AggregateInventoryEntry = {
    _count: InventoryEntryCountAggregateOutputType | null
    _avg: InventoryEntryAvgAggregateOutputType | null
    _sum: InventoryEntrySumAggregateOutputType | null
    _min: InventoryEntryMinAggregateOutputType | null
    _max: InventoryEntryMaxAggregateOutputType | null
  }

  export type InventoryEntryAvgAggregateOutputType = {
    id: number | null
    inventoryId: number | null
    orderId: number | null
  }

  export type InventoryEntrySumAggregateOutputType = {
    id: number | null
    inventoryId: number | null
    orderId: number | null
  }

  export type InventoryEntryMinAggregateOutputType = {
    id: number | null
    addedAt: Date | null
    material: string | null
    inventoryId: number | null
    orderId: number | null
  }

  export type InventoryEntryMaxAggregateOutputType = {
    id: number | null
    addedAt: Date | null
    material: string | null
    inventoryId: number | null
    orderId: number | null
  }

  export type InventoryEntryCountAggregateOutputType = {
    id: number
    addedAt: number
    material: number
    inventoryId: number
    orderId: number
    _all: number
  }


  export type InventoryEntryAvgAggregateInputType = {
    id?: true
    inventoryId?: true
    orderId?: true
  }

  export type InventoryEntrySumAggregateInputType = {
    id?: true
    inventoryId?: true
    orderId?: true
  }

  export type InventoryEntryMinAggregateInputType = {
    id?: true
    addedAt?: true
    material?: true
    inventoryId?: true
    orderId?: true
  }

  export type InventoryEntryMaxAggregateInputType = {
    id?: true
    addedAt?: true
    material?: true
    inventoryId?: true
    orderId?: true
  }

  export type InventoryEntryCountAggregateInputType = {
    id?: true
    addedAt?: true
    material?: true
    inventoryId?: true
    orderId?: true
    _all?: true
  }

  export type InventoryEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryEntry to aggregate.
     */
    where?: InventoryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryEntries to fetch.
     */
    orderBy?: InventoryEntryOrderByWithRelationInput | InventoryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryEntries
    **/
    _count?: true | InventoryEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryEntryMaxAggregateInputType
  }

  export type GetInventoryEntryAggregateType<T extends InventoryEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryEntry[P]>
      : GetScalarType<T[P], AggregateInventoryEntry[P]>
  }




  export type InventoryEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryEntryWhereInput
    orderBy?: InventoryEntryOrderByWithAggregationInput | InventoryEntryOrderByWithAggregationInput[]
    by: InventoryEntryScalarFieldEnum[] | InventoryEntryScalarFieldEnum
    having?: InventoryEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryEntryCountAggregateInputType | true
    _avg?: InventoryEntryAvgAggregateInputType
    _sum?: InventoryEntrySumAggregateInputType
    _min?: InventoryEntryMinAggregateInputType
    _max?: InventoryEntryMaxAggregateInputType
  }

  export type InventoryEntryGroupByOutputType = {
    id: number
    addedAt: Date
    material: string
    inventoryId: number
    orderId: number | null
    _count: InventoryEntryCountAggregateOutputType | null
    _avg: InventoryEntryAvgAggregateOutputType | null
    _sum: InventoryEntrySumAggregateOutputType | null
    _min: InventoryEntryMinAggregateOutputType | null
    _max: InventoryEntryMaxAggregateOutputType | null
  }

  type GetInventoryEntryGroupByPayload<T extends InventoryEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryEntryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryEntryGroupByOutputType[P]>
        }
      >
    >


  export type InventoryEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addedAt?: boolean
    material?: boolean
    inventoryId?: boolean
    orderId?: boolean
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    Order?: boolean | InventoryEntry$OrderArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryEntry"]>

  export type InventoryEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addedAt?: boolean
    material?: boolean
    inventoryId?: boolean
    orderId?: boolean
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    Order?: boolean | InventoryEntry$OrderArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryEntry"]>

  export type InventoryEntrySelectScalar = {
    id?: boolean
    addedAt?: boolean
    material?: boolean
    inventoryId?: boolean
    orderId?: boolean
  }

  export type InventoryEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    Order?: boolean | InventoryEntry$OrderArgs<ExtArgs>
  }
  export type InventoryEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    Order?: boolean | InventoryEntry$OrderArgs<ExtArgs>
  }

  export type $InventoryEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryEntry"
    objects: {
      inventory: Prisma.$InventoryPayload<ExtArgs>
      Order: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      addedAt: Date
      material: string
      inventoryId: number
      orderId: number | null
    }, ExtArgs["result"]["inventoryEntry"]>
    composites: {}
  }

  type InventoryEntryGetPayload<S extends boolean | null | undefined | InventoryEntryDefaultArgs> = $Result.GetResult<Prisma.$InventoryEntryPayload, S>

  type InventoryEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryEntryCountAggregateInputType | true
    }

  export interface InventoryEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryEntry'], meta: { name: 'InventoryEntry' } }
    /**
     * Find zero or one InventoryEntry that matches the filter.
     * @param {InventoryEntryFindUniqueArgs} args - Arguments to find a InventoryEntry
     * @example
     * // Get one InventoryEntry
     * const inventoryEntry = await prisma.inventoryEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryEntryFindUniqueArgs>(args: SelectSubset<T, InventoryEntryFindUniqueArgs<ExtArgs>>): Prisma__InventoryEntryClient<$Result.GetResult<Prisma.$InventoryEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryEntryFindUniqueOrThrowArgs} args - Arguments to find a InventoryEntry
     * @example
     * // Get one InventoryEntry
     * const inventoryEntry = await prisma.inventoryEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryEntryClient<$Result.GetResult<Prisma.$InventoryEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryEntryFindFirstArgs} args - Arguments to find a InventoryEntry
     * @example
     * // Get one InventoryEntry
     * const inventoryEntry = await prisma.inventoryEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryEntryFindFirstArgs>(args?: SelectSubset<T, InventoryEntryFindFirstArgs<ExtArgs>>): Prisma__InventoryEntryClient<$Result.GetResult<Prisma.$InventoryEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryEntryFindFirstOrThrowArgs} args - Arguments to find a InventoryEntry
     * @example
     * // Get one InventoryEntry
     * const inventoryEntry = await prisma.inventoryEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryEntryClient<$Result.GetResult<Prisma.$InventoryEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryEntries
     * const inventoryEntries = await prisma.inventoryEntry.findMany()
     * 
     * // Get first 10 InventoryEntries
     * const inventoryEntries = await prisma.inventoryEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryEntryWithIdOnly = await prisma.inventoryEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryEntryFindManyArgs>(args?: SelectSubset<T, InventoryEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryEntry.
     * @param {InventoryEntryCreateArgs} args - Arguments to create a InventoryEntry.
     * @example
     * // Create one InventoryEntry
     * const InventoryEntry = await prisma.inventoryEntry.create({
     *   data: {
     *     // ... data to create a InventoryEntry
     *   }
     * })
     * 
     */
    create<T extends InventoryEntryCreateArgs>(args: SelectSubset<T, InventoryEntryCreateArgs<ExtArgs>>): Prisma__InventoryEntryClient<$Result.GetResult<Prisma.$InventoryEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryEntries.
     * @param {InventoryEntryCreateManyArgs} args - Arguments to create many InventoryEntries.
     * @example
     * // Create many InventoryEntries
     * const inventoryEntry = await prisma.inventoryEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryEntryCreateManyArgs>(args?: SelectSubset<T, InventoryEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryEntries and returns the data saved in the database.
     * @param {InventoryEntryCreateManyAndReturnArgs} args - Arguments to create many InventoryEntries.
     * @example
     * // Create many InventoryEntries
     * const inventoryEntry = await prisma.inventoryEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryEntries and only return the `id`
     * const inventoryEntryWithIdOnly = await prisma.inventoryEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InventoryEntry.
     * @param {InventoryEntryDeleteArgs} args - Arguments to delete one InventoryEntry.
     * @example
     * // Delete one InventoryEntry
     * const InventoryEntry = await prisma.inventoryEntry.delete({
     *   where: {
     *     // ... filter to delete one InventoryEntry
     *   }
     * })
     * 
     */
    delete<T extends InventoryEntryDeleteArgs>(args: SelectSubset<T, InventoryEntryDeleteArgs<ExtArgs>>): Prisma__InventoryEntryClient<$Result.GetResult<Prisma.$InventoryEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryEntry.
     * @param {InventoryEntryUpdateArgs} args - Arguments to update one InventoryEntry.
     * @example
     * // Update one InventoryEntry
     * const inventoryEntry = await prisma.inventoryEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryEntryUpdateArgs>(args: SelectSubset<T, InventoryEntryUpdateArgs<ExtArgs>>): Prisma__InventoryEntryClient<$Result.GetResult<Prisma.$InventoryEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryEntries.
     * @param {InventoryEntryDeleteManyArgs} args - Arguments to filter InventoryEntries to delete.
     * @example
     * // Delete a few InventoryEntries
     * const { count } = await prisma.inventoryEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryEntryDeleteManyArgs>(args?: SelectSubset<T, InventoryEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryEntries
     * const inventoryEntry = await prisma.inventoryEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryEntryUpdateManyArgs>(args: SelectSubset<T, InventoryEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryEntry.
     * @param {InventoryEntryUpsertArgs} args - Arguments to update or create a InventoryEntry.
     * @example
     * // Update or create a InventoryEntry
     * const inventoryEntry = await prisma.inventoryEntry.upsert({
     *   create: {
     *     // ... data to create a InventoryEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryEntry we want to update
     *   }
     * })
     */
    upsert<T extends InventoryEntryUpsertArgs>(args: SelectSubset<T, InventoryEntryUpsertArgs<ExtArgs>>): Prisma__InventoryEntryClient<$Result.GetResult<Prisma.$InventoryEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryEntryCountArgs} args - Arguments to filter InventoryEntries to count.
     * @example
     * // Count the number of InventoryEntries
     * const count = await prisma.inventoryEntry.count({
     *   where: {
     *     // ... the filter for the InventoryEntries we want to count
     *   }
     * })
    **/
    count<T extends InventoryEntryCountArgs>(
      args?: Subset<T, InventoryEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryEntryAggregateArgs>(args: Subset<T, InventoryEntryAggregateArgs>): Prisma.PrismaPromise<GetInventoryEntryAggregateType<T>>

    /**
     * Group by InventoryEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryEntryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryEntry model
   */
  readonly fields: InventoryEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Order<T extends InventoryEntry$OrderArgs<ExtArgs> = {}>(args?: Subset<T, InventoryEntry$OrderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryEntry model
   */ 
  interface InventoryEntryFieldRefs {
    readonly id: FieldRef<"InventoryEntry", 'Int'>
    readonly addedAt: FieldRef<"InventoryEntry", 'DateTime'>
    readonly material: FieldRef<"InventoryEntry", 'String'>
    readonly inventoryId: FieldRef<"InventoryEntry", 'Int'>
    readonly orderId: FieldRef<"InventoryEntry", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * InventoryEntry findUnique
   */
  export type InventoryEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryEntry
     */
    select?: InventoryEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryEntryInclude<ExtArgs> | null
    /**
     * Filter, which InventoryEntry to fetch.
     */
    where: InventoryEntryWhereUniqueInput
  }

  /**
   * InventoryEntry findUniqueOrThrow
   */
  export type InventoryEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryEntry
     */
    select?: InventoryEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryEntryInclude<ExtArgs> | null
    /**
     * Filter, which InventoryEntry to fetch.
     */
    where: InventoryEntryWhereUniqueInput
  }

  /**
   * InventoryEntry findFirst
   */
  export type InventoryEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryEntry
     */
    select?: InventoryEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryEntryInclude<ExtArgs> | null
    /**
     * Filter, which InventoryEntry to fetch.
     */
    where?: InventoryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryEntries to fetch.
     */
    orderBy?: InventoryEntryOrderByWithRelationInput | InventoryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryEntries.
     */
    cursor?: InventoryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryEntries.
     */
    distinct?: InventoryEntryScalarFieldEnum | InventoryEntryScalarFieldEnum[]
  }

  /**
   * InventoryEntry findFirstOrThrow
   */
  export type InventoryEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryEntry
     */
    select?: InventoryEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryEntryInclude<ExtArgs> | null
    /**
     * Filter, which InventoryEntry to fetch.
     */
    where?: InventoryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryEntries to fetch.
     */
    orderBy?: InventoryEntryOrderByWithRelationInput | InventoryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryEntries.
     */
    cursor?: InventoryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryEntries.
     */
    distinct?: InventoryEntryScalarFieldEnum | InventoryEntryScalarFieldEnum[]
  }

  /**
   * InventoryEntry findMany
   */
  export type InventoryEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryEntry
     */
    select?: InventoryEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryEntryInclude<ExtArgs> | null
    /**
     * Filter, which InventoryEntries to fetch.
     */
    where?: InventoryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryEntries to fetch.
     */
    orderBy?: InventoryEntryOrderByWithRelationInput | InventoryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryEntries.
     */
    cursor?: InventoryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryEntries.
     */
    skip?: number
    distinct?: InventoryEntryScalarFieldEnum | InventoryEntryScalarFieldEnum[]
  }

  /**
   * InventoryEntry create
   */
  export type InventoryEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryEntry
     */
    select?: InventoryEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryEntry.
     */
    data: XOR<InventoryEntryCreateInput, InventoryEntryUncheckedCreateInput>
  }

  /**
   * InventoryEntry createMany
   */
  export type InventoryEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryEntries.
     */
    data: InventoryEntryCreateManyInput | InventoryEntryCreateManyInput[]
  }

  /**
   * InventoryEntry createManyAndReturn
   */
  export type InventoryEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryEntry
     */
    select?: InventoryEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InventoryEntries.
     */
    data: InventoryEntryCreateManyInput | InventoryEntryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryEntry update
   */
  export type InventoryEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryEntry
     */
    select?: InventoryEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryEntry.
     */
    data: XOR<InventoryEntryUpdateInput, InventoryEntryUncheckedUpdateInput>
    /**
     * Choose, which InventoryEntry to update.
     */
    where: InventoryEntryWhereUniqueInput
  }

  /**
   * InventoryEntry updateMany
   */
  export type InventoryEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryEntries.
     */
    data: XOR<InventoryEntryUpdateManyMutationInput, InventoryEntryUncheckedUpdateManyInput>
    /**
     * Filter which InventoryEntries to update
     */
    where?: InventoryEntryWhereInput
  }

  /**
   * InventoryEntry upsert
   */
  export type InventoryEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryEntry
     */
    select?: InventoryEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryEntry to update in case it exists.
     */
    where: InventoryEntryWhereUniqueInput
    /**
     * In case the InventoryEntry found by the `where` argument doesn't exist, create a new InventoryEntry with this data.
     */
    create: XOR<InventoryEntryCreateInput, InventoryEntryUncheckedCreateInput>
    /**
     * In case the InventoryEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryEntryUpdateInput, InventoryEntryUncheckedUpdateInput>
  }

  /**
   * InventoryEntry delete
   */
  export type InventoryEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryEntry
     */
    select?: InventoryEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryEntryInclude<ExtArgs> | null
    /**
     * Filter which InventoryEntry to delete.
     */
    where: InventoryEntryWhereUniqueInput
  }

  /**
   * InventoryEntry deleteMany
   */
  export type InventoryEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryEntries to delete
     */
    where?: InventoryEntryWhereInput
  }

  /**
   * InventoryEntry.Order
   */
  export type InventoryEntry$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * InventoryEntry without action
   */
  export type InventoryEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryEntry
     */
    select?: InventoryEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryEntryInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number | null
  }

  export type LocationSumAggregateOutputType = {
    id: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    description: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: string
    description: string | null
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    processSteps?: boolean | Location$processStepsArgs<ExtArgs>
    resources?: boolean | Location$resourcesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
  }

  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processSteps?: boolean | Location$processStepsArgs<ExtArgs>
    resources?: boolean | Location$resourcesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      processSteps: Prisma.$ProcessStepPayload<ExtArgs>[]
      resources: Prisma.$ResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      name: string
      description: string | null
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    processSteps<T extends Location$processStepsArgs<ExtArgs> = {}>(args?: Subset<T, Location$processStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findMany"> | Null>
    resources<T extends Location$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, Location$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'Int'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
    readonly name: FieldRef<"Location", 'String'>
    readonly description: FieldRef<"Location", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
  }

  /**
   * Location.processSteps
   */
  export type Location$processStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    cursor?: ProcessStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * Location.resources
   */
  export type Location$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model ProcessStep
   */

  export type AggregateProcessStep = {
    _count: ProcessStepCountAggregateOutputType | null
    _avg: ProcessStepAvgAggregateOutputType | null
    _sum: ProcessStepSumAggregateOutputType | null
    _min: ProcessStepMinAggregateOutputType | null
    _max: ProcessStepMaxAggregateOutputType | null
  }

  export type ProcessStepAvgAggregateOutputType = {
    id: number | null
    inputSpeed: number | null
    outputSpeed: number | null
    recipeRate: number | null
    duration: number | null
    locationId: number | null
    inventoryId: number | null
    recipeId: number | null
    errorRate: number | null
  }

  export type ProcessStepSumAggregateOutputType = {
    id: number | null
    inputSpeed: number | null
    outputSpeed: number | null
    recipeRate: number | null
    duration: number | null
    locationId: number | null
    inventoryId: number | null
    recipeId: number | null
    errorRate: number | null
  }

  export type ProcessStepMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    status: string | null
    active: boolean | null
    inputSpeed: number | null
    outputSpeed: number | null
    recipeRate: number | null
    duration: number | null
    locationId: number | null
    inventoryId: number | null
    recipeId: number | null
    errorRate: number | null
  }

  export type ProcessStepMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    status: string | null
    active: boolean | null
    inputSpeed: number | null
    outputSpeed: number | null
    recipeRate: number | null
    duration: number | null
    locationId: number | null
    inventoryId: number | null
    recipeId: number | null
    errorRate: number | null
  }

  export type ProcessStepCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    status: number
    active: number
    inputSpeed: number
    outputSpeed: number
    recipeRate: number
    duration: number
    locationId: number
    inventoryId: number
    recipeId: number
    errorRate: number
    _all: number
  }


  export type ProcessStepAvgAggregateInputType = {
    id?: true
    inputSpeed?: true
    outputSpeed?: true
    recipeRate?: true
    duration?: true
    locationId?: true
    inventoryId?: true
    recipeId?: true
    errorRate?: true
  }

  export type ProcessStepSumAggregateInputType = {
    id?: true
    inputSpeed?: true
    outputSpeed?: true
    recipeRate?: true
    duration?: true
    locationId?: true
    inventoryId?: true
    recipeId?: true
    errorRate?: true
  }

  export type ProcessStepMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    status?: true
    active?: true
    inputSpeed?: true
    outputSpeed?: true
    recipeRate?: true
    duration?: true
    locationId?: true
    inventoryId?: true
    recipeId?: true
    errorRate?: true
  }

  export type ProcessStepMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    status?: true
    active?: true
    inputSpeed?: true
    outputSpeed?: true
    recipeRate?: true
    duration?: true
    locationId?: true
    inventoryId?: true
    recipeId?: true
    errorRate?: true
  }

  export type ProcessStepCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    status?: true
    active?: true
    inputSpeed?: true
    outputSpeed?: true
    recipeRate?: true
    duration?: true
    locationId?: true
    inventoryId?: true
    recipeId?: true
    errorRate?: true
    _all?: true
  }

  export type ProcessStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessStep to aggregate.
     */
    where?: ProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSteps to fetch.
     */
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessSteps
    **/
    _count?: true | ProcessStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessStepMaxAggregateInputType
  }

  export type GetProcessStepAggregateType<T extends ProcessStepAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessStep[P]>
      : GetScalarType<T[P], AggregateProcessStep[P]>
  }




  export type ProcessStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessStepWhereInput
    orderBy?: ProcessStepOrderByWithAggregationInput | ProcessStepOrderByWithAggregationInput[]
    by: ProcessStepScalarFieldEnum[] | ProcessStepScalarFieldEnum
    having?: ProcessStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessStepCountAggregateInputType | true
    _avg?: ProcessStepAvgAggregateInputType
    _sum?: ProcessStepSumAggregateInputType
    _min?: ProcessStepMinAggregateInputType
    _max?: ProcessStepMaxAggregateInputType
  }

  export type ProcessStepGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: string
    status: string
    active: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate: number
    duration: number
    locationId: number
    inventoryId: number
    recipeId: number | null
    errorRate: number | null
    _count: ProcessStepCountAggregateOutputType | null
    _avg: ProcessStepAvgAggregateOutputType | null
    _sum: ProcessStepSumAggregateOutputType | null
    _min: ProcessStepMinAggregateOutputType | null
    _max: ProcessStepMaxAggregateOutputType | null
  }

  type GetProcessStepGroupByPayload<T extends ProcessStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessStepGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessStepGroupByOutputType[P]>
        }
      >
    >


  export type ProcessStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    status?: boolean
    active?: boolean
    inputSpeed?: boolean
    outputSpeed?: boolean
    recipeRate?: boolean
    duration?: boolean
    locationId?: boolean
    inventoryId?: boolean
    recipeId?: boolean
    errorRate?: boolean
    orders?: boolean | ProcessStep$ordersArgs<ExtArgs>
    recipe?: boolean | ProcessStep$recipeArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    resources?: boolean | ProcessStep$resourcesArgs<ExtArgs>
    sensors?: boolean | ProcessStep$sensorsArgs<ExtArgs>
    inputs?: boolean | ProcessStep$inputsArgs<ExtArgs>
    outputs?: boolean | ProcessStep$outputsArgs<ExtArgs>
    _count?: boolean | ProcessStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processStep"]>

  export type ProcessStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    status?: boolean
    active?: boolean
    inputSpeed?: boolean
    outputSpeed?: boolean
    recipeRate?: boolean
    duration?: boolean
    locationId?: boolean
    inventoryId?: boolean
    recipeId?: boolean
    errorRate?: boolean
    recipe?: boolean | ProcessStep$recipeArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processStep"]>

  export type ProcessStepSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    status?: boolean
    active?: boolean
    inputSpeed?: boolean
    outputSpeed?: boolean
    recipeRate?: boolean
    duration?: boolean
    locationId?: boolean
    inventoryId?: boolean
    recipeId?: boolean
    errorRate?: boolean
  }

  export type ProcessStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ProcessStep$ordersArgs<ExtArgs>
    recipe?: boolean | ProcessStep$recipeArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    resources?: boolean | ProcessStep$resourcesArgs<ExtArgs>
    sensors?: boolean | ProcessStep$sensorsArgs<ExtArgs>
    inputs?: boolean | ProcessStep$inputsArgs<ExtArgs>
    outputs?: boolean | ProcessStep$outputsArgs<ExtArgs>
    _count?: boolean | ProcessStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcessStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | ProcessStep$recipeArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $ProcessStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessStep"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      recipe: Prisma.$RecipePayload<ExtArgs> | null
      inventory: Prisma.$InventoryPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
      resources: Prisma.$ResourcePayload<ExtArgs>[]
      sensors: Prisma.$SensorPayload<ExtArgs>[]
      inputs: Prisma.$TransportSystemPayload<ExtArgs>[]
      outputs: Prisma.$TransportSystemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      name: string
      status: string
      active: boolean
      inputSpeed: number
      outputSpeed: number
      recipeRate: number
      duration: number
      locationId: number
      inventoryId: number
      recipeId: number | null
      errorRate: number | null
    }, ExtArgs["result"]["processStep"]>
    composites: {}
  }

  type ProcessStepGetPayload<S extends boolean | null | undefined | ProcessStepDefaultArgs> = $Result.GetResult<Prisma.$ProcessStepPayload, S>

  type ProcessStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessStepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessStepCountAggregateInputType | true
    }

  export interface ProcessStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessStep'], meta: { name: 'ProcessStep' } }
    /**
     * Find zero or one ProcessStep that matches the filter.
     * @param {ProcessStepFindUniqueArgs} args - Arguments to find a ProcessStep
     * @example
     * // Get one ProcessStep
     * const processStep = await prisma.processStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessStepFindUniqueArgs>(args: SelectSubset<T, ProcessStepFindUniqueArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProcessStep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcessStepFindUniqueOrThrowArgs} args - Arguments to find a ProcessStep
     * @example
     * // Get one ProcessStep
     * const processStep = await prisma.processStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessStepFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProcessStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepFindFirstArgs} args - Arguments to find a ProcessStep
     * @example
     * // Get one ProcessStep
     * const processStep = await prisma.processStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessStepFindFirstArgs>(args?: SelectSubset<T, ProcessStepFindFirstArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProcessStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepFindFirstOrThrowArgs} args - Arguments to find a ProcessStep
     * @example
     * // Get one ProcessStep
     * const processStep = await prisma.processStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessStepFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProcessSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessSteps
     * const processSteps = await prisma.processStep.findMany()
     * 
     * // Get first 10 ProcessSteps
     * const processSteps = await prisma.processStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processStepWithIdOnly = await prisma.processStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessStepFindManyArgs>(args?: SelectSubset<T, ProcessStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProcessStep.
     * @param {ProcessStepCreateArgs} args - Arguments to create a ProcessStep.
     * @example
     * // Create one ProcessStep
     * const ProcessStep = await prisma.processStep.create({
     *   data: {
     *     // ... data to create a ProcessStep
     *   }
     * })
     * 
     */
    create<T extends ProcessStepCreateArgs>(args: SelectSubset<T, ProcessStepCreateArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProcessSteps.
     * @param {ProcessStepCreateManyArgs} args - Arguments to create many ProcessSteps.
     * @example
     * // Create many ProcessSteps
     * const processStep = await prisma.processStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessStepCreateManyArgs>(args?: SelectSubset<T, ProcessStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcessSteps and returns the data saved in the database.
     * @param {ProcessStepCreateManyAndReturnArgs} args - Arguments to create many ProcessSteps.
     * @example
     * // Create many ProcessSteps
     * const processStep = await prisma.processStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcessSteps and only return the `id`
     * const processStepWithIdOnly = await prisma.processStep.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessStepCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProcessStep.
     * @param {ProcessStepDeleteArgs} args - Arguments to delete one ProcessStep.
     * @example
     * // Delete one ProcessStep
     * const ProcessStep = await prisma.processStep.delete({
     *   where: {
     *     // ... filter to delete one ProcessStep
     *   }
     * })
     * 
     */
    delete<T extends ProcessStepDeleteArgs>(args: SelectSubset<T, ProcessStepDeleteArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProcessStep.
     * @param {ProcessStepUpdateArgs} args - Arguments to update one ProcessStep.
     * @example
     * // Update one ProcessStep
     * const processStep = await prisma.processStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessStepUpdateArgs>(args: SelectSubset<T, ProcessStepUpdateArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProcessSteps.
     * @param {ProcessStepDeleteManyArgs} args - Arguments to filter ProcessSteps to delete.
     * @example
     * // Delete a few ProcessSteps
     * const { count } = await prisma.processStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessStepDeleteManyArgs>(args?: SelectSubset<T, ProcessStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessSteps
     * const processStep = await prisma.processStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessStepUpdateManyArgs>(args: SelectSubset<T, ProcessStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProcessStep.
     * @param {ProcessStepUpsertArgs} args - Arguments to update or create a ProcessStep.
     * @example
     * // Update or create a ProcessStep
     * const processStep = await prisma.processStep.upsert({
     *   create: {
     *     // ... data to create a ProcessStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessStep we want to update
     *   }
     * })
     */
    upsert<T extends ProcessStepUpsertArgs>(args: SelectSubset<T, ProcessStepUpsertArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProcessSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepCountArgs} args - Arguments to filter ProcessSteps to count.
     * @example
     * // Count the number of ProcessSteps
     * const count = await prisma.processStep.count({
     *   where: {
     *     // ... the filter for the ProcessSteps we want to count
     *   }
     * })
    **/
    count<T extends ProcessStepCountArgs>(
      args?: Subset<T, ProcessStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessStepAggregateArgs>(args: Subset<T, ProcessStepAggregateArgs>): Prisma.PrismaPromise<GetProcessStepAggregateType<T>>

    /**
     * Group by ProcessStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessStepGroupByArgs['orderBy'] }
        : { orderBy?: ProcessStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessStep model
   */
  readonly fields: ProcessStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends ProcessStep$ordersArgs<ExtArgs> = {}>(args?: Subset<T, ProcessStep$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    recipe<T extends ProcessStep$recipeArgs<ExtArgs> = {}>(args?: Subset<T, ProcessStep$recipeArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    resources<T extends ProcessStep$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, ProcessStep$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany"> | Null>
    sensors<T extends ProcessStep$sensorsArgs<ExtArgs> = {}>(args?: Subset<T, ProcessStep$sensorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findMany"> | Null>
    inputs<T extends ProcessStep$inputsArgs<ExtArgs> = {}>(args?: Subset<T, ProcessStep$inputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "findMany"> | Null>
    outputs<T extends ProcessStep$outputsArgs<ExtArgs> = {}>(args?: Subset<T, ProcessStep$outputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessStep model
   */ 
  interface ProcessStepFieldRefs {
    readonly id: FieldRef<"ProcessStep", 'Int'>
    readonly createdAt: FieldRef<"ProcessStep", 'DateTime'>
    readonly updatedAt: FieldRef<"ProcessStep", 'DateTime'>
    readonly name: FieldRef<"ProcessStep", 'String'>
    readonly status: FieldRef<"ProcessStep", 'String'>
    readonly active: FieldRef<"ProcessStep", 'Boolean'>
    readonly inputSpeed: FieldRef<"ProcessStep", 'Int'>
    readonly outputSpeed: FieldRef<"ProcessStep", 'Int'>
    readonly recipeRate: FieldRef<"ProcessStep", 'Int'>
    readonly duration: FieldRef<"ProcessStep", 'Int'>
    readonly locationId: FieldRef<"ProcessStep", 'Int'>
    readonly inventoryId: FieldRef<"ProcessStep", 'Int'>
    readonly recipeId: FieldRef<"ProcessStep", 'Int'>
    readonly errorRate: FieldRef<"ProcessStep", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ProcessStep findUnique
   */
  export type ProcessStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStep to fetch.
     */
    where: ProcessStepWhereUniqueInput
  }

  /**
   * ProcessStep findUniqueOrThrow
   */
  export type ProcessStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStep to fetch.
     */
    where: ProcessStepWhereUniqueInput
  }

  /**
   * ProcessStep findFirst
   */
  export type ProcessStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStep to fetch.
     */
    where?: ProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSteps to fetch.
     */
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessSteps.
     */
    cursor?: ProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessSteps.
     */
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * ProcessStep findFirstOrThrow
   */
  export type ProcessStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStep to fetch.
     */
    where?: ProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSteps to fetch.
     */
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessSteps.
     */
    cursor?: ProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessSteps.
     */
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * ProcessStep findMany
   */
  export type ProcessStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessSteps to fetch.
     */
    where?: ProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSteps to fetch.
     */
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessSteps.
     */
    cursor?: ProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSteps.
     */
    skip?: number
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * ProcessStep create
   */
  export type ProcessStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessStep.
     */
    data: XOR<ProcessStepCreateInput, ProcessStepUncheckedCreateInput>
  }

  /**
   * ProcessStep createMany
   */
  export type ProcessStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessSteps.
     */
    data: ProcessStepCreateManyInput | ProcessStepCreateManyInput[]
  }

  /**
   * ProcessStep createManyAndReturn
   */
  export type ProcessStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProcessSteps.
     */
    data: ProcessStepCreateManyInput | ProcessStepCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessStep update
   */
  export type ProcessStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessStep.
     */
    data: XOR<ProcessStepUpdateInput, ProcessStepUncheckedUpdateInput>
    /**
     * Choose, which ProcessStep to update.
     */
    where: ProcessStepWhereUniqueInput
  }

  /**
   * ProcessStep updateMany
   */
  export type ProcessStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessSteps.
     */
    data: XOR<ProcessStepUpdateManyMutationInput, ProcessStepUncheckedUpdateManyInput>
    /**
     * Filter which ProcessSteps to update
     */
    where?: ProcessStepWhereInput
  }

  /**
   * ProcessStep upsert
   */
  export type ProcessStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessStep to update in case it exists.
     */
    where: ProcessStepWhereUniqueInput
    /**
     * In case the ProcessStep found by the `where` argument doesn't exist, create a new ProcessStep with this data.
     */
    create: XOR<ProcessStepCreateInput, ProcessStepUncheckedCreateInput>
    /**
     * In case the ProcessStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessStepUpdateInput, ProcessStepUncheckedUpdateInput>
  }

  /**
   * ProcessStep delete
   */
  export type ProcessStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter which ProcessStep to delete.
     */
    where: ProcessStepWhereUniqueInput
  }

  /**
   * ProcessStep deleteMany
   */
  export type ProcessStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessSteps to delete
     */
    where?: ProcessStepWhereInput
  }

  /**
   * ProcessStep.orders
   */
  export type ProcessStep$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * ProcessStep.recipe
   */
  export type ProcessStep$recipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
  }

  /**
   * ProcessStep.resources
   */
  export type ProcessStep$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * ProcessStep.sensors
   */
  export type ProcessStep$sensorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    where?: SensorWhereInput
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    cursor?: SensorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * ProcessStep.inputs
   */
  export type ProcessStep$inputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    where?: TransportSystemWhereInput
    orderBy?: TransportSystemOrderByWithRelationInput | TransportSystemOrderByWithRelationInput[]
    cursor?: TransportSystemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransportSystemScalarFieldEnum | TransportSystemScalarFieldEnum[]
  }

  /**
   * ProcessStep.outputs
   */
  export type ProcessStep$outputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    where?: TransportSystemWhereInput
    orderBy?: TransportSystemOrderByWithRelationInput | TransportSystemOrderByWithRelationInput[]
    cursor?: TransportSystemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransportSystemScalarFieldEnum | TransportSystemScalarFieldEnum[]
  }

  /**
   * ProcessStep without action
   */
  export type ProcessStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
  }


  /**
   * Model Recipe
   */

  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeAvgAggregateOutputType = {
    id: number | null
  }

  export type RecipeSumAggregateOutputType = {
    id: number | null
  }

  export type RecipeMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    _all: number
  }


  export type RecipeAvgAggregateInputType = {
    id?: true
  }

  export type RecipeSumAggregateInputType = {
    id?: true
  }

  export type RecipeMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    _all?: true
  }

  export type RecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipe to aggregate.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithAggregationInput | RecipeOrderByWithAggregationInput[]
    by: RecipeScalarFieldEnum[] | RecipeScalarFieldEnum
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _avg?: RecipeAvgAggregateInputType
    _sum?: RecipeSumAggregateInputType
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }

  export type RecipeGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: string
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    processSteps?: boolean | Recipe$processStepsArgs<ExtArgs>
    inputs?: boolean | Recipe$inputsArgs<ExtArgs>
    outputs?: boolean | Recipe$outputsArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
  }

  export type RecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processSteps?: boolean | Recipe$processStepsArgs<ExtArgs>
    inputs?: boolean | Recipe$inputsArgs<ExtArgs>
    outputs?: boolean | Recipe$outputsArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipe"
    objects: {
      processSteps: Prisma.$ProcessStepPayload<ExtArgs>[]
      inputs: Prisma.$RecipeInputPayload<ExtArgs>[]
      outputs: Prisma.$RecipeOutputPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      name: string
    }, ExtArgs["result"]["recipe"]>
    composites: {}
  }

  type RecipeGetPayload<S extends boolean | null | undefined | RecipeDefaultArgs> = $Result.GetResult<Prisma.$RecipePayload, S>

  type RecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeCountAggregateInputType | true
    }

  export interface RecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipe'], meta: { name: 'Recipe' } }
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeFindUniqueArgs>(args: SelectSubset<T, RecipeFindUniqueArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Recipe that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeFindFirstArgs>(args?: SelectSubset<T, RecipeFindFirstArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeFindManyArgs>(args?: SelectSubset<T, RecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
     */
    create<T extends RecipeCreateArgs>(args: SelectSubset<T, RecipeCreateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Recipes.
     * @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeCreateManyArgs>(args?: SelectSubset<T, RecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recipes and returns the data saved in the database.
     * @param {RecipeCreateManyAndReturnArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recipes and only return the `id`
     * const recipeWithIdOnly = await prisma.recipe.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
     */
    delete<T extends RecipeDeleteArgs>(args: SelectSubset<T, RecipeDeleteArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeUpdateArgs>(args: SelectSubset<T, RecipeUpdateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeDeleteManyArgs>(args?: SelectSubset<T, RecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeUpdateManyArgs>(args: SelectSubset<T, RecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
     */
    upsert<T extends RecipeUpsertArgs>(args: SelectSubset<T, RecipeUpsertArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): Prisma.PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipe model
   */
  readonly fields: RecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    processSteps<T extends Recipe$processStepsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$processStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findMany"> | Null>
    inputs<T extends Recipe$inputsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$inputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeInputPayload<ExtArgs>, T, "findMany"> | Null>
    outputs<T extends Recipe$outputsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$outputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeOutputPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recipe model
   */ 
  interface RecipeFieldRefs {
    readonly id: FieldRef<"Recipe", 'Int'>
    readonly createdAt: FieldRef<"Recipe", 'DateTime'>
    readonly updatedAt: FieldRef<"Recipe", 'DateTime'>
    readonly name: FieldRef<"Recipe", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Recipe findUnique
   */
  export type RecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findFirst
   */
  export type RecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipes to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe create
   */
  export type RecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipe.
     */
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }

  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
  }

  /**
   * Recipe createManyAndReturn
   */
  export type RecipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
  }

  /**
   * Recipe update
   */
  export type RecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipe.
     */
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
  }

  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     */
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     */
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }

  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter which Recipe to delete.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipes to delete
     */
    where?: RecipeWhereInput
  }

  /**
   * Recipe.processSteps
   */
  export type Recipe$processStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    cursor?: ProcessStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * Recipe.inputs
   */
  export type Recipe$inputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInput
     */
    select?: RecipeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInputInclude<ExtArgs> | null
    where?: RecipeInputWhereInput
    orderBy?: RecipeInputOrderByWithRelationInput | RecipeInputOrderByWithRelationInput[]
    cursor?: RecipeInputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeInputScalarFieldEnum | RecipeInputScalarFieldEnum[]
  }

  /**
   * Recipe.outputs
   */
  export type Recipe$outputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeOutput
     */
    select?: RecipeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeOutputInclude<ExtArgs> | null
    where?: RecipeOutputWhereInput
    orderBy?: RecipeOutputOrderByWithRelationInput | RecipeOutputOrderByWithRelationInput[]
    cursor?: RecipeOutputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeOutputScalarFieldEnum | RecipeOutputScalarFieldEnum[]
  }

  /**
   * Recipe without action
   */
  export type RecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
  }


  /**
   * Model RecipeInput
   */

  export type AggregateRecipeInput = {
    _count: RecipeInputCountAggregateOutputType | null
    _avg: RecipeInputAvgAggregateOutputType | null
    _sum: RecipeInputSumAggregateOutputType | null
    _min: RecipeInputMinAggregateOutputType | null
    _max: RecipeInputMaxAggregateOutputType | null
  }

  export type RecipeInputAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    recipeId: number | null
  }

  export type RecipeInputSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    recipeId: number | null
  }

  export type RecipeInputMinAggregateOutputType = {
    id: number | null
    material: string | null
    quantity: number | null
    recipeId: number | null
  }

  export type RecipeInputMaxAggregateOutputType = {
    id: number | null
    material: string | null
    quantity: number | null
    recipeId: number | null
  }

  export type RecipeInputCountAggregateOutputType = {
    id: number
    material: number
    quantity: number
    recipeId: number
    _all: number
  }


  export type RecipeInputAvgAggregateInputType = {
    id?: true
    quantity?: true
    recipeId?: true
  }

  export type RecipeInputSumAggregateInputType = {
    id?: true
    quantity?: true
    recipeId?: true
  }

  export type RecipeInputMinAggregateInputType = {
    id?: true
    material?: true
    quantity?: true
    recipeId?: true
  }

  export type RecipeInputMaxAggregateInputType = {
    id?: true
    material?: true
    quantity?: true
    recipeId?: true
  }

  export type RecipeInputCountAggregateInputType = {
    id?: true
    material?: true
    quantity?: true
    recipeId?: true
    _all?: true
  }

  export type RecipeInputAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeInput to aggregate.
     */
    where?: RecipeInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeInputs to fetch.
     */
    orderBy?: RecipeInputOrderByWithRelationInput | RecipeInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeInputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeInputs
    **/
    _count?: true | RecipeInputCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeInputAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeInputSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeInputMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeInputMaxAggregateInputType
  }

  export type GetRecipeInputAggregateType<T extends RecipeInputAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeInput]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeInput[P]>
      : GetScalarType<T[P], AggregateRecipeInput[P]>
  }




  export type RecipeInputGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeInputWhereInput
    orderBy?: RecipeInputOrderByWithAggregationInput | RecipeInputOrderByWithAggregationInput[]
    by: RecipeInputScalarFieldEnum[] | RecipeInputScalarFieldEnum
    having?: RecipeInputScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeInputCountAggregateInputType | true
    _avg?: RecipeInputAvgAggregateInputType
    _sum?: RecipeInputSumAggregateInputType
    _min?: RecipeInputMinAggregateInputType
    _max?: RecipeInputMaxAggregateInputType
  }

  export type RecipeInputGroupByOutputType = {
    id: number
    material: string
    quantity: number
    recipeId: number | null
    _count: RecipeInputCountAggregateOutputType | null
    _avg: RecipeInputAvgAggregateOutputType | null
    _sum: RecipeInputSumAggregateOutputType | null
    _min: RecipeInputMinAggregateOutputType | null
    _max: RecipeInputMaxAggregateOutputType | null
  }

  type GetRecipeInputGroupByPayload<T extends RecipeInputGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeInputGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeInputGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeInputGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeInputGroupByOutputType[P]>
        }
      >
    >


  export type RecipeInputSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    material?: boolean
    quantity?: boolean
    recipeId?: boolean
    Recipe?: boolean | RecipeInput$RecipeArgs<ExtArgs>
  }, ExtArgs["result"]["recipeInput"]>

  export type RecipeInputSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    material?: boolean
    quantity?: boolean
    recipeId?: boolean
    Recipe?: boolean | RecipeInput$RecipeArgs<ExtArgs>
  }, ExtArgs["result"]["recipeInput"]>

  export type RecipeInputSelectScalar = {
    id?: boolean
    material?: boolean
    quantity?: boolean
    recipeId?: boolean
  }

  export type RecipeInputInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Recipe?: boolean | RecipeInput$RecipeArgs<ExtArgs>
  }
  export type RecipeInputIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Recipe?: boolean | RecipeInput$RecipeArgs<ExtArgs>
  }

  export type $RecipeInputPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeInput"
    objects: {
      Recipe: Prisma.$RecipePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      material: string
      quantity: number
      recipeId: number | null
    }, ExtArgs["result"]["recipeInput"]>
    composites: {}
  }

  type RecipeInputGetPayload<S extends boolean | null | undefined | RecipeInputDefaultArgs> = $Result.GetResult<Prisma.$RecipeInputPayload, S>

  type RecipeInputCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeInputFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeInputCountAggregateInputType | true
    }

  export interface RecipeInputDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeInput'], meta: { name: 'RecipeInput' } }
    /**
     * Find zero or one RecipeInput that matches the filter.
     * @param {RecipeInputFindUniqueArgs} args - Arguments to find a RecipeInput
     * @example
     * // Get one RecipeInput
     * const recipeInput = await prisma.recipeInput.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeInputFindUniqueArgs>(args: SelectSubset<T, RecipeInputFindUniqueArgs<ExtArgs>>): Prisma__RecipeInputClient<$Result.GetResult<Prisma.$RecipeInputPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RecipeInput that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecipeInputFindUniqueOrThrowArgs} args - Arguments to find a RecipeInput
     * @example
     * // Get one RecipeInput
     * const recipeInput = await prisma.recipeInput.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeInputFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeInputFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeInputClient<$Result.GetResult<Prisma.$RecipeInputPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RecipeInput that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInputFindFirstArgs} args - Arguments to find a RecipeInput
     * @example
     * // Get one RecipeInput
     * const recipeInput = await prisma.recipeInput.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeInputFindFirstArgs>(args?: SelectSubset<T, RecipeInputFindFirstArgs<ExtArgs>>): Prisma__RecipeInputClient<$Result.GetResult<Prisma.$RecipeInputPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RecipeInput that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInputFindFirstOrThrowArgs} args - Arguments to find a RecipeInput
     * @example
     * // Get one RecipeInput
     * const recipeInput = await prisma.recipeInput.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeInputFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeInputFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeInputClient<$Result.GetResult<Prisma.$RecipeInputPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RecipeInputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInputFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeInputs
     * const recipeInputs = await prisma.recipeInput.findMany()
     * 
     * // Get first 10 RecipeInputs
     * const recipeInputs = await prisma.recipeInput.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeInputWithIdOnly = await prisma.recipeInput.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeInputFindManyArgs>(args?: SelectSubset<T, RecipeInputFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeInputPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RecipeInput.
     * @param {RecipeInputCreateArgs} args - Arguments to create a RecipeInput.
     * @example
     * // Create one RecipeInput
     * const RecipeInput = await prisma.recipeInput.create({
     *   data: {
     *     // ... data to create a RecipeInput
     *   }
     * })
     * 
     */
    create<T extends RecipeInputCreateArgs>(args: SelectSubset<T, RecipeInputCreateArgs<ExtArgs>>): Prisma__RecipeInputClient<$Result.GetResult<Prisma.$RecipeInputPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RecipeInputs.
     * @param {RecipeInputCreateManyArgs} args - Arguments to create many RecipeInputs.
     * @example
     * // Create many RecipeInputs
     * const recipeInput = await prisma.recipeInput.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeInputCreateManyArgs>(args?: SelectSubset<T, RecipeInputCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipeInputs and returns the data saved in the database.
     * @param {RecipeInputCreateManyAndReturnArgs} args - Arguments to create many RecipeInputs.
     * @example
     * // Create many RecipeInputs
     * const recipeInput = await prisma.recipeInput.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipeInputs and only return the `id`
     * const recipeInputWithIdOnly = await prisma.recipeInput.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeInputCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeInputCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeInputPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RecipeInput.
     * @param {RecipeInputDeleteArgs} args - Arguments to delete one RecipeInput.
     * @example
     * // Delete one RecipeInput
     * const RecipeInput = await prisma.recipeInput.delete({
     *   where: {
     *     // ... filter to delete one RecipeInput
     *   }
     * })
     * 
     */
    delete<T extends RecipeInputDeleteArgs>(args: SelectSubset<T, RecipeInputDeleteArgs<ExtArgs>>): Prisma__RecipeInputClient<$Result.GetResult<Prisma.$RecipeInputPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RecipeInput.
     * @param {RecipeInputUpdateArgs} args - Arguments to update one RecipeInput.
     * @example
     * // Update one RecipeInput
     * const recipeInput = await prisma.recipeInput.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeInputUpdateArgs>(args: SelectSubset<T, RecipeInputUpdateArgs<ExtArgs>>): Prisma__RecipeInputClient<$Result.GetResult<Prisma.$RecipeInputPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RecipeInputs.
     * @param {RecipeInputDeleteManyArgs} args - Arguments to filter RecipeInputs to delete.
     * @example
     * // Delete a few RecipeInputs
     * const { count } = await prisma.recipeInput.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeInputDeleteManyArgs>(args?: SelectSubset<T, RecipeInputDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeInputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeInputs
     * const recipeInput = await prisma.recipeInput.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeInputUpdateManyArgs>(args: SelectSubset<T, RecipeInputUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeInput.
     * @param {RecipeInputUpsertArgs} args - Arguments to update or create a RecipeInput.
     * @example
     * // Update or create a RecipeInput
     * const recipeInput = await prisma.recipeInput.upsert({
     *   create: {
     *     // ... data to create a RecipeInput
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeInput we want to update
     *   }
     * })
     */
    upsert<T extends RecipeInputUpsertArgs>(args: SelectSubset<T, RecipeInputUpsertArgs<ExtArgs>>): Prisma__RecipeInputClient<$Result.GetResult<Prisma.$RecipeInputPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RecipeInputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInputCountArgs} args - Arguments to filter RecipeInputs to count.
     * @example
     * // Count the number of RecipeInputs
     * const count = await prisma.recipeInput.count({
     *   where: {
     *     // ... the filter for the RecipeInputs we want to count
     *   }
     * })
    **/
    count<T extends RecipeInputCountArgs>(
      args?: Subset<T, RecipeInputCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeInputCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeInput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeInputAggregateArgs>(args: Subset<T, RecipeInputAggregateArgs>): Prisma.PrismaPromise<GetRecipeInputAggregateType<T>>

    /**
     * Group by RecipeInput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeInputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeInputGroupByArgs['orderBy'] }
        : { orderBy?: RecipeInputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeInputGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeInputGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeInput model
   */
  readonly fields: RecipeInputFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeInput.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeInputClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Recipe<T extends RecipeInput$RecipeArgs<ExtArgs> = {}>(args?: Subset<T, RecipeInput$RecipeArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipeInput model
   */ 
  interface RecipeInputFieldRefs {
    readonly id: FieldRef<"RecipeInput", 'Int'>
    readonly material: FieldRef<"RecipeInput", 'String'>
    readonly quantity: FieldRef<"RecipeInput", 'Int'>
    readonly recipeId: FieldRef<"RecipeInput", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RecipeInput findUnique
   */
  export type RecipeInputFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInput
     */
    select?: RecipeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInputInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInput to fetch.
     */
    where: RecipeInputWhereUniqueInput
  }

  /**
   * RecipeInput findUniqueOrThrow
   */
  export type RecipeInputFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInput
     */
    select?: RecipeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInputInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInput to fetch.
     */
    where: RecipeInputWhereUniqueInput
  }

  /**
   * RecipeInput findFirst
   */
  export type RecipeInputFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInput
     */
    select?: RecipeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInputInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInput to fetch.
     */
    where?: RecipeInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeInputs to fetch.
     */
    orderBy?: RecipeInputOrderByWithRelationInput | RecipeInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeInputs.
     */
    cursor?: RecipeInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeInputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeInputs.
     */
    distinct?: RecipeInputScalarFieldEnum | RecipeInputScalarFieldEnum[]
  }

  /**
   * RecipeInput findFirstOrThrow
   */
  export type RecipeInputFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInput
     */
    select?: RecipeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInputInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInput to fetch.
     */
    where?: RecipeInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeInputs to fetch.
     */
    orderBy?: RecipeInputOrderByWithRelationInput | RecipeInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeInputs.
     */
    cursor?: RecipeInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeInputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeInputs.
     */
    distinct?: RecipeInputScalarFieldEnum | RecipeInputScalarFieldEnum[]
  }

  /**
   * RecipeInput findMany
   */
  export type RecipeInputFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInput
     */
    select?: RecipeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInputInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInputs to fetch.
     */
    where?: RecipeInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeInputs to fetch.
     */
    orderBy?: RecipeInputOrderByWithRelationInput | RecipeInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeInputs.
     */
    cursor?: RecipeInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeInputs.
     */
    skip?: number
    distinct?: RecipeInputScalarFieldEnum | RecipeInputScalarFieldEnum[]
  }

  /**
   * RecipeInput create
   */
  export type RecipeInputCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInput
     */
    select?: RecipeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInputInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeInput.
     */
    data: XOR<RecipeInputCreateInput, RecipeInputUncheckedCreateInput>
  }

  /**
   * RecipeInput createMany
   */
  export type RecipeInputCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeInputs.
     */
    data: RecipeInputCreateManyInput | RecipeInputCreateManyInput[]
  }

  /**
   * RecipeInput createManyAndReturn
   */
  export type RecipeInputCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInput
     */
    select?: RecipeInputSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RecipeInputs.
     */
    data: RecipeInputCreateManyInput | RecipeInputCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInputIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeInput update
   */
  export type RecipeInputUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInput
     */
    select?: RecipeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInputInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeInput.
     */
    data: XOR<RecipeInputUpdateInput, RecipeInputUncheckedUpdateInput>
    /**
     * Choose, which RecipeInput to update.
     */
    where: RecipeInputWhereUniqueInput
  }

  /**
   * RecipeInput updateMany
   */
  export type RecipeInputUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeInputs.
     */
    data: XOR<RecipeInputUpdateManyMutationInput, RecipeInputUncheckedUpdateManyInput>
    /**
     * Filter which RecipeInputs to update
     */
    where?: RecipeInputWhereInput
  }

  /**
   * RecipeInput upsert
   */
  export type RecipeInputUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInput
     */
    select?: RecipeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInputInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeInput to update in case it exists.
     */
    where: RecipeInputWhereUniqueInput
    /**
     * In case the RecipeInput found by the `where` argument doesn't exist, create a new RecipeInput with this data.
     */
    create: XOR<RecipeInputCreateInput, RecipeInputUncheckedCreateInput>
    /**
     * In case the RecipeInput was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeInputUpdateInput, RecipeInputUncheckedUpdateInput>
  }

  /**
   * RecipeInput delete
   */
  export type RecipeInputDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInput
     */
    select?: RecipeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInputInclude<ExtArgs> | null
    /**
     * Filter which RecipeInput to delete.
     */
    where: RecipeInputWhereUniqueInput
  }

  /**
   * RecipeInput deleteMany
   */
  export type RecipeInputDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeInputs to delete
     */
    where?: RecipeInputWhereInput
  }

  /**
   * RecipeInput.Recipe
   */
  export type RecipeInput$RecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
  }

  /**
   * RecipeInput without action
   */
  export type RecipeInputDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInput
     */
    select?: RecipeInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInputInclude<ExtArgs> | null
  }


  /**
   * Model RecipeOutput
   */

  export type AggregateRecipeOutput = {
    _count: RecipeOutputCountAggregateOutputType | null
    _avg: RecipeOutputAvgAggregateOutputType | null
    _sum: RecipeOutputSumAggregateOutputType | null
    _min: RecipeOutputMinAggregateOutputType | null
    _max: RecipeOutputMaxAggregateOutputType | null
  }

  export type RecipeOutputAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    recipeId: number | null
  }

  export type RecipeOutputSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    recipeId: number | null
  }

  export type RecipeOutputMinAggregateOutputType = {
    id: number | null
    material: string | null
    quantity: number | null
    recipeId: number | null
  }

  export type RecipeOutputMaxAggregateOutputType = {
    id: number | null
    material: string | null
    quantity: number | null
    recipeId: number | null
  }

  export type RecipeOutputCountAggregateOutputType = {
    id: number
    material: number
    quantity: number
    recipeId: number
    _all: number
  }


  export type RecipeOutputAvgAggregateInputType = {
    id?: true
    quantity?: true
    recipeId?: true
  }

  export type RecipeOutputSumAggregateInputType = {
    id?: true
    quantity?: true
    recipeId?: true
  }

  export type RecipeOutputMinAggregateInputType = {
    id?: true
    material?: true
    quantity?: true
    recipeId?: true
  }

  export type RecipeOutputMaxAggregateInputType = {
    id?: true
    material?: true
    quantity?: true
    recipeId?: true
  }

  export type RecipeOutputCountAggregateInputType = {
    id?: true
    material?: true
    quantity?: true
    recipeId?: true
    _all?: true
  }

  export type RecipeOutputAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeOutput to aggregate.
     */
    where?: RecipeOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeOutputs to fetch.
     */
    orderBy?: RecipeOutputOrderByWithRelationInput | RecipeOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeOutputs
    **/
    _count?: true | RecipeOutputCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeOutputAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeOutputSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeOutputMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeOutputMaxAggregateInputType
  }

  export type GetRecipeOutputAggregateType<T extends RecipeOutputAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeOutput]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeOutput[P]>
      : GetScalarType<T[P], AggregateRecipeOutput[P]>
  }




  export type RecipeOutputGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeOutputWhereInput
    orderBy?: RecipeOutputOrderByWithAggregationInput | RecipeOutputOrderByWithAggregationInput[]
    by: RecipeOutputScalarFieldEnum[] | RecipeOutputScalarFieldEnum
    having?: RecipeOutputScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeOutputCountAggregateInputType | true
    _avg?: RecipeOutputAvgAggregateInputType
    _sum?: RecipeOutputSumAggregateInputType
    _min?: RecipeOutputMinAggregateInputType
    _max?: RecipeOutputMaxAggregateInputType
  }

  export type RecipeOutputGroupByOutputType = {
    id: number
    material: string
    quantity: number
    recipeId: number | null
    _count: RecipeOutputCountAggregateOutputType | null
    _avg: RecipeOutputAvgAggregateOutputType | null
    _sum: RecipeOutputSumAggregateOutputType | null
    _min: RecipeOutputMinAggregateOutputType | null
    _max: RecipeOutputMaxAggregateOutputType | null
  }

  type GetRecipeOutputGroupByPayload<T extends RecipeOutputGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeOutputGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeOutputGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeOutputGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeOutputGroupByOutputType[P]>
        }
      >
    >


  export type RecipeOutputSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    material?: boolean
    quantity?: boolean
    recipeId?: boolean
    Recipe?: boolean | RecipeOutput$RecipeArgs<ExtArgs>
  }, ExtArgs["result"]["recipeOutput"]>

  export type RecipeOutputSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    material?: boolean
    quantity?: boolean
    recipeId?: boolean
    Recipe?: boolean | RecipeOutput$RecipeArgs<ExtArgs>
  }, ExtArgs["result"]["recipeOutput"]>

  export type RecipeOutputSelectScalar = {
    id?: boolean
    material?: boolean
    quantity?: boolean
    recipeId?: boolean
  }

  export type RecipeOutputInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Recipe?: boolean | RecipeOutput$RecipeArgs<ExtArgs>
  }
  export type RecipeOutputIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Recipe?: boolean | RecipeOutput$RecipeArgs<ExtArgs>
  }

  export type $RecipeOutputPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeOutput"
    objects: {
      Recipe: Prisma.$RecipePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      material: string
      quantity: number
      recipeId: number | null
    }, ExtArgs["result"]["recipeOutput"]>
    composites: {}
  }

  type RecipeOutputGetPayload<S extends boolean | null | undefined | RecipeOutputDefaultArgs> = $Result.GetResult<Prisma.$RecipeOutputPayload, S>

  type RecipeOutputCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeOutputFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeOutputCountAggregateInputType | true
    }

  export interface RecipeOutputDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeOutput'], meta: { name: 'RecipeOutput' } }
    /**
     * Find zero or one RecipeOutput that matches the filter.
     * @param {RecipeOutputFindUniqueArgs} args - Arguments to find a RecipeOutput
     * @example
     * // Get one RecipeOutput
     * const recipeOutput = await prisma.recipeOutput.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeOutputFindUniqueArgs>(args: SelectSubset<T, RecipeOutputFindUniqueArgs<ExtArgs>>): Prisma__RecipeOutputClient<$Result.GetResult<Prisma.$RecipeOutputPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RecipeOutput that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecipeOutputFindUniqueOrThrowArgs} args - Arguments to find a RecipeOutput
     * @example
     * // Get one RecipeOutput
     * const recipeOutput = await prisma.recipeOutput.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeOutputFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeOutputFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeOutputClient<$Result.GetResult<Prisma.$RecipeOutputPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RecipeOutput that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeOutputFindFirstArgs} args - Arguments to find a RecipeOutput
     * @example
     * // Get one RecipeOutput
     * const recipeOutput = await prisma.recipeOutput.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeOutputFindFirstArgs>(args?: SelectSubset<T, RecipeOutputFindFirstArgs<ExtArgs>>): Prisma__RecipeOutputClient<$Result.GetResult<Prisma.$RecipeOutputPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RecipeOutput that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeOutputFindFirstOrThrowArgs} args - Arguments to find a RecipeOutput
     * @example
     * // Get one RecipeOutput
     * const recipeOutput = await prisma.recipeOutput.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeOutputFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeOutputFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeOutputClient<$Result.GetResult<Prisma.$RecipeOutputPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RecipeOutputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeOutputFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeOutputs
     * const recipeOutputs = await prisma.recipeOutput.findMany()
     * 
     * // Get first 10 RecipeOutputs
     * const recipeOutputs = await prisma.recipeOutput.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeOutputWithIdOnly = await prisma.recipeOutput.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeOutputFindManyArgs>(args?: SelectSubset<T, RecipeOutputFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeOutputPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RecipeOutput.
     * @param {RecipeOutputCreateArgs} args - Arguments to create a RecipeOutput.
     * @example
     * // Create one RecipeOutput
     * const RecipeOutput = await prisma.recipeOutput.create({
     *   data: {
     *     // ... data to create a RecipeOutput
     *   }
     * })
     * 
     */
    create<T extends RecipeOutputCreateArgs>(args: SelectSubset<T, RecipeOutputCreateArgs<ExtArgs>>): Prisma__RecipeOutputClient<$Result.GetResult<Prisma.$RecipeOutputPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RecipeOutputs.
     * @param {RecipeOutputCreateManyArgs} args - Arguments to create many RecipeOutputs.
     * @example
     * // Create many RecipeOutputs
     * const recipeOutput = await prisma.recipeOutput.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeOutputCreateManyArgs>(args?: SelectSubset<T, RecipeOutputCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipeOutputs and returns the data saved in the database.
     * @param {RecipeOutputCreateManyAndReturnArgs} args - Arguments to create many RecipeOutputs.
     * @example
     * // Create many RecipeOutputs
     * const recipeOutput = await prisma.recipeOutput.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipeOutputs and only return the `id`
     * const recipeOutputWithIdOnly = await prisma.recipeOutput.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeOutputCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeOutputCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeOutputPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RecipeOutput.
     * @param {RecipeOutputDeleteArgs} args - Arguments to delete one RecipeOutput.
     * @example
     * // Delete one RecipeOutput
     * const RecipeOutput = await prisma.recipeOutput.delete({
     *   where: {
     *     // ... filter to delete one RecipeOutput
     *   }
     * })
     * 
     */
    delete<T extends RecipeOutputDeleteArgs>(args: SelectSubset<T, RecipeOutputDeleteArgs<ExtArgs>>): Prisma__RecipeOutputClient<$Result.GetResult<Prisma.$RecipeOutputPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RecipeOutput.
     * @param {RecipeOutputUpdateArgs} args - Arguments to update one RecipeOutput.
     * @example
     * // Update one RecipeOutput
     * const recipeOutput = await prisma.recipeOutput.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeOutputUpdateArgs>(args: SelectSubset<T, RecipeOutputUpdateArgs<ExtArgs>>): Prisma__RecipeOutputClient<$Result.GetResult<Prisma.$RecipeOutputPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RecipeOutputs.
     * @param {RecipeOutputDeleteManyArgs} args - Arguments to filter RecipeOutputs to delete.
     * @example
     * // Delete a few RecipeOutputs
     * const { count } = await prisma.recipeOutput.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeOutputDeleteManyArgs>(args?: SelectSubset<T, RecipeOutputDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeOutputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeOutputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeOutputs
     * const recipeOutput = await prisma.recipeOutput.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeOutputUpdateManyArgs>(args: SelectSubset<T, RecipeOutputUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeOutput.
     * @param {RecipeOutputUpsertArgs} args - Arguments to update or create a RecipeOutput.
     * @example
     * // Update or create a RecipeOutput
     * const recipeOutput = await prisma.recipeOutput.upsert({
     *   create: {
     *     // ... data to create a RecipeOutput
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeOutput we want to update
     *   }
     * })
     */
    upsert<T extends RecipeOutputUpsertArgs>(args: SelectSubset<T, RecipeOutputUpsertArgs<ExtArgs>>): Prisma__RecipeOutputClient<$Result.GetResult<Prisma.$RecipeOutputPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RecipeOutputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeOutputCountArgs} args - Arguments to filter RecipeOutputs to count.
     * @example
     * // Count the number of RecipeOutputs
     * const count = await prisma.recipeOutput.count({
     *   where: {
     *     // ... the filter for the RecipeOutputs we want to count
     *   }
     * })
    **/
    count<T extends RecipeOutputCountArgs>(
      args?: Subset<T, RecipeOutputCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeOutputCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeOutput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeOutputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeOutputAggregateArgs>(args: Subset<T, RecipeOutputAggregateArgs>): Prisma.PrismaPromise<GetRecipeOutputAggregateType<T>>

    /**
     * Group by RecipeOutput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeOutputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeOutputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeOutputGroupByArgs['orderBy'] }
        : { orderBy?: RecipeOutputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeOutputGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeOutputGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeOutput model
   */
  readonly fields: RecipeOutputFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeOutput.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeOutputClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Recipe<T extends RecipeOutput$RecipeArgs<ExtArgs> = {}>(args?: Subset<T, RecipeOutput$RecipeArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipeOutput model
   */ 
  interface RecipeOutputFieldRefs {
    readonly id: FieldRef<"RecipeOutput", 'Int'>
    readonly material: FieldRef<"RecipeOutput", 'String'>
    readonly quantity: FieldRef<"RecipeOutput", 'Int'>
    readonly recipeId: FieldRef<"RecipeOutput", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RecipeOutput findUnique
   */
  export type RecipeOutputFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeOutput
     */
    select?: RecipeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeOutputInclude<ExtArgs> | null
    /**
     * Filter, which RecipeOutput to fetch.
     */
    where: RecipeOutputWhereUniqueInput
  }

  /**
   * RecipeOutput findUniqueOrThrow
   */
  export type RecipeOutputFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeOutput
     */
    select?: RecipeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeOutputInclude<ExtArgs> | null
    /**
     * Filter, which RecipeOutput to fetch.
     */
    where: RecipeOutputWhereUniqueInput
  }

  /**
   * RecipeOutput findFirst
   */
  export type RecipeOutputFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeOutput
     */
    select?: RecipeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeOutputInclude<ExtArgs> | null
    /**
     * Filter, which RecipeOutput to fetch.
     */
    where?: RecipeOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeOutputs to fetch.
     */
    orderBy?: RecipeOutputOrderByWithRelationInput | RecipeOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeOutputs.
     */
    cursor?: RecipeOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeOutputs.
     */
    distinct?: RecipeOutputScalarFieldEnum | RecipeOutputScalarFieldEnum[]
  }

  /**
   * RecipeOutput findFirstOrThrow
   */
  export type RecipeOutputFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeOutput
     */
    select?: RecipeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeOutputInclude<ExtArgs> | null
    /**
     * Filter, which RecipeOutput to fetch.
     */
    where?: RecipeOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeOutputs to fetch.
     */
    orderBy?: RecipeOutputOrderByWithRelationInput | RecipeOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeOutputs.
     */
    cursor?: RecipeOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeOutputs.
     */
    distinct?: RecipeOutputScalarFieldEnum | RecipeOutputScalarFieldEnum[]
  }

  /**
   * RecipeOutput findMany
   */
  export type RecipeOutputFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeOutput
     */
    select?: RecipeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeOutputInclude<ExtArgs> | null
    /**
     * Filter, which RecipeOutputs to fetch.
     */
    where?: RecipeOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeOutputs to fetch.
     */
    orderBy?: RecipeOutputOrderByWithRelationInput | RecipeOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeOutputs.
     */
    cursor?: RecipeOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeOutputs.
     */
    skip?: number
    distinct?: RecipeOutputScalarFieldEnum | RecipeOutputScalarFieldEnum[]
  }

  /**
   * RecipeOutput create
   */
  export type RecipeOutputCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeOutput
     */
    select?: RecipeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeOutputInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeOutput.
     */
    data: XOR<RecipeOutputCreateInput, RecipeOutputUncheckedCreateInput>
  }

  /**
   * RecipeOutput createMany
   */
  export type RecipeOutputCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeOutputs.
     */
    data: RecipeOutputCreateManyInput | RecipeOutputCreateManyInput[]
  }

  /**
   * RecipeOutput createManyAndReturn
   */
  export type RecipeOutputCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeOutput
     */
    select?: RecipeOutputSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RecipeOutputs.
     */
    data: RecipeOutputCreateManyInput | RecipeOutputCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeOutputIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeOutput update
   */
  export type RecipeOutputUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeOutput
     */
    select?: RecipeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeOutputInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeOutput.
     */
    data: XOR<RecipeOutputUpdateInput, RecipeOutputUncheckedUpdateInput>
    /**
     * Choose, which RecipeOutput to update.
     */
    where: RecipeOutputWhereUniqueInput
  }

  /**
   * RecipeOutput updateMany
   */
  export type RecipeOutputUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeOutputs.
     */
    data: XOR<RecipeOutputUpdateManyMutationInput, RecipeOutputUncheckedUpdateManyInput>
    /**
     * Filter which RecipeOutputs to update
     */
    where?: RecipeOutputWhereInput
  }

  /**
   * RecipeOutput upsert
   */
  export type RecipeOutputUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeOutput
     */
    select?: RecipeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeOutputInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeOutput to update in case it exists.
     */
    where: RecipeOutputWhereUniqueInput
    /**
     * In case the RecipeOutput found by the `where` argument doesn't exist, create a new RecipeOutput with this data.
     */
    create: XOR<RecipeOutputCreateInput, RecipeOutputUncheckedCreateInput>
    /**
     * In case the RecipeOutput was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeOutputUpdateInput, RecipeOutputUncheckedUpdateInput>
  }

  /**
   * RecipeOutput delete
   */
  export type RecipeOutputDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeOutput
     */
    select?: RecipeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeOutputInclude<ExtArgs> | null
    /**
     * Filter which RecipeOutput to delete.
     */
    where: RecipeOutputWhereUniqueInput
  }

  /**
   * RecipeOutput deleteMany
   */
  export type RecipeOutputDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeOutputs to delete
     */
    where?: RecipeOutputWhereInput
  }

  /**
   * RecipeOutput.Recipe
   */
  export type RecipeOutput$RecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
  }

  /**
   * RecipeOutput without action
   */
  export type RecipeOutputDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeOutput
     */
    select?: RecipeOutputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeOutputInclude<ExtArgs> | null
  }


  /**
   * Model LogEntry
   */

  export type AggregateLogEntry = {
    _count: LogEntryCountAggregateOutputType | null
    _avg: LogEntryAvgAggregateOutputType | null
    _sum: LogEntrySumAggregateOutputType | null
    _min: LogEntryMinAggregateOutputType | null
    _max: LogEntryMaxAggregateOutputType | null
  }

  export type LogEntryAvgAggregateOutputType = {
    id: number | null
    sensorId: number | null
    materialId: number | null
    processStepId: number | null
    transportSystemId: number | null
  }

  export type LogEntrySumAggregateOutputType = {
    id: number | null
    sensorId: number | null
    materialId: number | null
    processStepId: number | null
    transportSystemId: number | null
  }

  export type LogEntryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    inputType: string | null
    sensorId: number | null
    materialId: number | null
    materialName: string | null
    processStepId: number | null
    transportSystemId: number | null
  }

  export type LogEntryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    inputType: string | null
    sensorId: number | null
    materialId: number | null
    materialName: string | null
    processStepId: number | null
    transportSystemId: number | null
  }

  export type LogEntryCountAggregateOutputType = {
    id: number
    createdAt: number
    inputType: number
    sensorId: number
    materialId: number
    materialName: number
    processStepId: number
    transportSystemId: number
    _all: number
  }


  export type LogEntryAvgAggregateInputType = {
    id?: true
    sensorId?: true
    materialId?: true
    processStepId?: true
    transportSystemId?: true
  }

  export type LogEntrySumAggregateInputType = {
    id?: true
    sensorId?: true
    materialId?: true
    processStepId?: true
    transportSystemId?: true
  }

  export type LogEntryMinAggregateInputType = {
    id?: true
    createdAt?: true
    inputType?: true
    sensorId?: true
    materialId?: true
    materialName?: true
    processStepId?: true
    transportSystemId?: true
  }

  export type LogEntryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    inputType?: true
    sensorId?: true
    materialId?: true
    materialName?: true
    processStepId?: true
    transportSystemId?: true
  }

  export type LogEntryCountAggregateInputType = {
    id?: true
    createdAt?: true
    inputType?: true
    sensorId?: true
    materialId?: true
    materialName?: true
    processStepId?: true
    transportSystemId?: true
    _all?: true
  }

  export type LogEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogEntry to aggregate.
     */
    where?: LogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntries to fetch.
     */
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogEntries
    **/
    _count?: true | LogEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogEntryMaxAggregateInputType
  }

  export type GetLogEntryAggregateType<T extends LogEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLogEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogEntry[P]>
      : GetScalarType<T[P], AggregateLogEntry[P]>
  }




  export type LogEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogEntryWhereInput
    orderBy?: LogEntryOrderByWithAggregationInput | LogEntryOrderByWithAggregationInput[]
    by: LogEntryScalarFieldEnum[] | LogEntryScalarFieldEnum
    having?: LogEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogEntryCountAggregateInputType | true
    _avg?: LogEntryAvgAggregateInputType
    _sum?: LogEntrySumAggregateInputType
    _min?: LogEntryMinAggregateInputType
    _max?: LogEntryMaxAggregateInputType
  }

  export type LogEntryGroupByOutputType = {
    id: number
    createdAt: Date
    inputType: string
    sensorId: number | null
    materialId: number
    materialName: string
    processStepId: number | null
    transportSystemId: number | null
    _count: LogEntryCountAggregateOutputType | null
    _avg: LogEntryAvgAggregateOutputType | null
    _sum: LogEntrySumAggregateOutputType | null
    _min: LogEntryMinAggregateOutputType | null
    _max: LogEntryMaxAggregateOutputType | null
  }

  type GetLogEntryGroupByPayload<T extends LogEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LogEntryGroupByOutputType[P]>
        }
      >
    >


  export type LogEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    inputType?: boolean
    sensorId?: boolean
    materialId?: boolean
    materialName?: boolean
    processStepId?: boolean
    transportSystemId?: boolean
    sensor?: boolean | LogEntry$sensorArgs<ExtArgs>
  }, ExtArgs["result"]["logEntry"]>

  export type LogEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    inputType?: boolean
    sensorId?: boolean
    materialId?: boolean
    materialName?: boolean
    processStepId?: boolean
    transportSystemId?: boolean
    sensor?: boolean | LogEntry$sensorArgs<ExtArgs>
  }, ExtArgs["result"]["logEntry"]>

  export type LogEntrySelectScalar = {
    id?: boolean
    createdAt?: boolean
    inputType?: boolean
    sensorId?: boolean
    materialId?: boolean
    materialName?: boolean
    processStepId?: boolean
    transportSystemId?: boolean
  }

  export type LogEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sensor?: boolean | LogEntry$sensorArgs<ExtArgs>
  }
  export type LogEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sensor?: boolean | LogEntry$sensorArgs<ExtArgs>
  }

  export type $LogEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogEntry"
    objects: {
      sensor: Prisma.$SensorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      inputType: string
      sensorId: number | null
      materialId: number
      materialName: string
      processStepId: number | null
      transportSystemId: number | null
    }, ExtArgs["result"]["logEntry"]>
    composites: {}
  }

  type LogEntryGetPayload<S extends boolean | null | undefined | LogEntryDefaultArgs> = $Result.GetResult<Prisma.$LogEntryPayload, S>

  type LogEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogEntryCountAggregateInputType | true
    }

  export interface LogEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogEntry'], meta: { name: 'LogEntry' } }
    /**
     * Find zero or one LogEntry that matches the filter.
     * @param {LogEntryFindUniqueArgs} args - Arguments to find a LogEntry
     * @example
     * // Get one LogEntry
     * const logEntry = await prisma.logEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogEntryFindUniqueArgs>(args: SelectSubset<T, LogEntryFindUniqueArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LogEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogEntryFindUniqueOrThrowArgs} args - Arguments to find a LogEntry
     * @example
     * // Get one LogEntry
     * const logEntry = await prisma.logEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LogEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LogEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryFindFirstArgs} args - Arguments to find a LogEntry
     * @example
     * // Get one LogEntry
     * const logEntry = await prisma.logEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogEntryFindFirstArgs>(args?: SelectSubset<T, LogEntryFindFirstArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LogEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryFindFirstOrThrowArgs} args - Arguments to find a LogEntry
     * @example
     * // Get one LogEntry
     * const logEntry = await prisma.logEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LogEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LogEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogEntries
     * const logEntries = await prisma.logEntry.findMany()
     * 
     * // Get first 10 LogEntries
     * const logEntries = await prisma.logEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logEntryWithIdOnly = await prisma.logEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogEntryFindManyArgs>(args?: SelectSubset<T, LogEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LogEntry.
     * @param {LogEntryCreateArgs} args - Arguments to create a LogEntry.
     * @example
     * // Create one LogEntry
     * const LogEntry = await prisma.logEntry.create({
     *   data: {
     *     // ... data to create a LogEntry
     *   }
     * })
     * 
     */
    create<T extends LogEntryCreateArgs>(args: SelectSubset<T, LogEntryCreateArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LogEntries.
     * @param {LogEntryCreateManyArgs} args - Arguments to create many LogEntries.
     * @example
     * // Create many LogEntries
     * const logEntry = await prisma.logEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogEntryCreateManyArgs>(args?: SelectSubset<T, LogEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LogEntries and returns the data saved in the database.
     * @param {LogEntryCreateManyAndReturnArgs} args - Arguments to create many LogEntries.
     * @example
     * // Create many LogEntries
     * const logEntry = await prisma.logEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LogEntries and only return the `id`
     * const logEntryWithIdOnly = await prisma.logEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LogEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LogEntry.
     * @param {LogEntryDeleteArgs} args - Arguments to delete one LogEntry.
     * @example
     * // Delete one LogEntry
     * const LogEntry = await prisma.logEntry.delete({
     *   where: {
     *     // ... filter to delete one LogEntry
     *   }
     * })
     * 
     */
    delete<T extends LogEntryDeleteArgs>(args: SelectSubset<T, LogEntryDeleteArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LogEntry.
     * @param {LogEntryUpdateArgs} args - Arguments to update one LogEntry.
     * @example
     * // Update one LogEntry
     * const logEntry = await prisma.logEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogEntryUpdateArgs>(args: SelectSubset<T, LogEntryUpdateArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LogEntries.
     * @param {LogEntryDeleteManyArgs} args - Arguments to filter LogEntries to delete.
     * @example
     * // Delete a few LogEntries
     * const { count } = await prisma.logEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogEntryDeleteManyArgs>(args?: SelectSubset<T, LogEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogEntries
     * const logEntry = await prisma.logEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogEntryUpdateManyArgs>(args: SelectSubset<T, LogEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogEntry.
     * @param {LogEntryUpsertArgs} args - Arguments to update or create a LogEntry.
     * @example
     * // Update or create a LogEntry
     * const logEntry = await prisma.logEntry.upsert({
     *   create: {
     *     // ... data to create a LogEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogEntry we want to update
     *   }
     * })
     */
    upsert<T extends LogEntryUpsertArgs>(args: SelectSubset<T, LogEntryUpsertArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LogEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryCountArgs} args - Arguments to filter LogEntries to count.
     * @example
     * // Count the number of LogEntries
     * const count = await prisma.logEntry.count({
     *   where: {
     *     // ... the filter for the LogEntries we want to count
     *   }
     * })
    **/
    count<T extends LogEntryCountArgs>(
      args?: Subset<T, LogEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogEntryAggregateArgs>(args: Subset<T, LogEntryAggregateArgs>): Prisma.PrismaPromise<GetLogEntryAggregateType<T>>

    /**
     * Group by LogEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogEntryGroupByArgs['orderBy'] }
        : { orderBy?: LogEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogEntry model
   */
  readonly fields: LogEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sensor<T extends LogEntry$sensorArgs<ExtArgs> = {}>(args?: Subset<T, LogEntry$sensorArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogEntry model
   */ 
  interface LogEntryFieldRefs {
    readonly id: FieldRef<"LogEntry", 'Int'>
    readonly createdAt: FieldRef<"LogEntry", 'DateTime'>
    readonly inputType: FieldRef<"LogEntry", 'String'>
    readonly sensorId: FieldRef<"LogEntry", 'Int'>
    readonly materialId: FieldRef<"LogEntry", 'Int'>
    readonly materialName: FieldRef<"LogEntry", 'String'>
    readonly processStepId: FieldRef<"LogEntry", 'Int'>
    readonly transportSystemId: FieldRef<"LogEntry", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LogEntry findUnique
   */
  export type LogEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntry to fetch.
     */
    where: LogEntryWhereUniqueInput
  }

  /**
   * LogEntry findUniqueOrThrow
   */
  export type LogEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntry to fetch.
     */
    where: LogEntryWhereUniqueInput
  }

  /**
   * LogEntry findFirst
   */
  export type LogEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntry to fetch.
     */
    where?: LogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntries to fetch.
     */
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogEntries.
     */
    cursor?: LogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogEntries.
     */
    distinct?: LogEntryScalarFieldEnum | LogEntryScalarFieldEnum[]
  }

  /**
   * LogEntry findFirstOrThrow
   */
  export type LogEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntry to fetch.
     */
    where?: LogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntries to fetch.
     */
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogEntries.
     */
    cursor?: LogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogEntries.
     */
    distinct?: LogEntryScalarFieldEnum | LogEntryScalarFieldEnum[]
  }

  /**
   * LogEntry findMany
   */
  export type LogEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntries to fetch.
     */
    where?: LogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntries to fetch.
     */
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogEntries.
     */
    cursor?: LogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntries.
     */
    skip?: number
    distinct?: LogEntryScalarFieldEnum | LogEntryScalarFieldEnum[]
  }

  /**
   * LogEntry create
   */
  export type LogEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LogEntry.
     */
    data: XOR<LogEntryCreateInput, LogEntryUncheckedCreateInput>
  }

  /**
   * LogEntry createMany
   */
  export type LogEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogEntries.
     */
    data: LogEntryCreateManyInput | LogEntryCreateManyInput[]
  }

  /**
   * LogEntry createManyAndReturn
   */
  export type LogEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LogEntries.
     */
    data: LogEntryCreateManyInput | LogEntryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LogEntry update
   */
  export type LogEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LogEntry.
     */
    data: XOR<LogEntryUpdateInput, LogEntryUncheckedUpdateInput>
    /**
     * Choose, which LogEntry to update.
     */
    where: LogEntryWhereUniqueInput
  }

  /**
   * LogEntry updateMany
   */
  export type LogEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogEntries.
     */
    data: XOR<LogEntryUpdateManyMutationInput, LogEntryUncheckedUpdateManyInput>
    /**
     * Filter which LogEntries to update
     */
    where?: LogEntryWhereInput
  }

  /**
   * LogEntry upsert
   */
  export type LogEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LogEntry to update in case it exists.
     */
    where: LogEntryWhereUniqueInput
    /**
     * In case the LogEntry found by the `where` argument doesn't exist, create a new LogEntry with this data.
     */
    create: XOR<LogEntryCreateInput, LogEntryUncheckedCreateInput>
    /**
     * In case the LogEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogEntryUpdateInput, LogEntryUncheckedUpdateInput>
  }

  /**
   * LogEntry delete
   */
  export type LogEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter which LogEntry to delete.
     */
    where: LogEntryWhereUniqueInput
  }

  /**
   * LogEntry deleteMany
   */
  export type LogEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogEntries to delete
     */
    where?: LogEntryWhereInput
  }

  /**
   * LogEntry.sensor
   */
  export type LogEntry$sensorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    where?: SensorWhereInput
  }

  /**
   * LogEntry without action
   */
  export type LogEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
  }


  /**
   * Model Sensor
   */

  export type AggregateSensor = {
    _count: SensorCountAggregateOutputType | null
    _avg: SensorAvgAggregateOutputType | null
    _sum: SensorSumAggregateOutputType | null
    _min: SensorMinAggregateOutputType | null
    _max: SensorMaxAggregateOutputType | null
  }

  export type SensorAvgAggregateOutputType = {
    id: number | null
    value: number | null
    sensorDelay: number | null
    processStepId: number | null
    transportSystemId: number | null
  }

  export type SensorSumAggregateOutputType = {
    id: number | null
    value: number | null
    sensorDelay: number | null
    processStepId: number | null
    transportSystemId: number | null
  }

  export type SensorMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    type: string | null
    value: number | null
    sensorDelay: number | null
    active: boolean | null
    processStepId: number | null
    transportSystemId: number | null
  }

  export type SensorMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    type: string | null
    value: number | null
    sensorDelay: number | null
    active: boolean | null
    processStepId: number | null
    transportSystemId: number | null
  }

  export type SensorCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    type: number
    value: number
    sensorDelay: number
    active: number
    processStepId: number
    transportSystemId: number
    _all: number
  }


  export type SensorAvgAggregateInputType = {
    id?: true
    value?: true
    sensorDelay?: true
    processStepId?: true
    transportSystemId?: true
  }

  export type SensorSumAggregateInputType = {
    id?: true
    value?: true
    sensorDelay?: true
    processStepId?: true
    transportSystemId?: true
  }

  export type SensorMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    type?: true
    value?: true
    sensorDelay?: true
    active?: true
    processStepId?: true
    transportSystemId?: true
  }

  export type SensorMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    type?: true
    value?: true
    sensorDelay?: true
    active?: true
    processStepId?: true
    transportSystemId?: true
  }

  export type SensorCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    type?: true
    value?: true
    sensorDelay?: true
    active?: true
    processStepId?: true
    transportSystemId?: true
    _all?: true
  }

  export type SensorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sensor to aggregate.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sensors
    **/
    _count?: true | SensorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SensorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SensorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SensorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SensorMaxAggregateInputType
  }

  export type GetSensorAggregateType<T extends SensorAggregateArgs> = {
        [P in keyof T & keyof AggregateSensor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSensor[P]>
      : GetScalarType<T[P], AggregateSensor[P]>
  }




  export type SensorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SensorWhereInput
    orderBy?: SensorOrderByWithAggregationInput | SensorOrderByWithAggregationInput[]
    by: SensorScalarFieldEnum[] | SensorScalarFieldEnum
    having?: SensorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SensorCountAggregateInputType | true
    _avg?: SensorAvgAggregateInputType
    _sum?: SensorSumAggregateInputType
    _min?: SensorMinAggregateInputType
    _max?: SensorMaxAggregateInputType
  }

  export type SensorGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: string
    type: string
    value: number
    sensorDelay: number
    active: boolean
    processStepId: number | null
    transportSystemId: number | null
    _count: SensorCountAggregateOutputType | null
    _avg: SensorAvgAggregateOutputType | null
    _sum: SensorSumAggregateOutputType | null
    _min: SensorMinAggregateOutputType | null
    _max: SensorMaxAggregateOutputType | null
  }

  type GetSensorGroupByPayload<T extends SensorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SensorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SensorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SensorGroupByOutputType[P]>
            : GetScalarType<T[P], SensorGroupByOutputType[P]>
        }
      >
    >


  export type SensorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    sensorDelay?: boolean
    active?: boolean
    processStepId?: boolean
    transportSystemId?: boolean
    processStep?: boolean | Sensor$processStepArgs<ExtArgs>
    transportSystem?: boolean | Sensor$transportSystemArgs<ExtArgs>
    logEntries?: boolean | Sensor$logEntriesArgs<ExtArgs>
    _count?: boolean | SensorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sensor"]>

  export type SensorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    sensorDelay?: boolean
    active?: boolean
    processStepId?: boolean
    transportSystemId?: boolean
    processStep?: boolean | Sensor$processStepArgs<ExtArgs>
    transportSystem?: boolean | Sensor$transportSystemArgs<ExtArgs>
  }, ExtArgs["result"]["sensor"]>

  export type SensorSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    sensorDelay?: boolean
    active?: boolean
    processStepId?: boolean
    transportSystemId?: boolean
  }

  export type SensorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processStep?: boolean | Sensor$processStepArgs<ExtArgs>
    transportSystem?: boolean | Sensor$transportSystemArgs<ExtArgs>
    logEntries?: boolean | Sensor$logEntriesArgs<ExtArgs>
    _count?: boolean | SensorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SensorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processStep?: boolean | Sensor$processStepArgs<ExtArgs>
    transportSystem?: boolean | Sensor$transportSystemArgs<ExtArgs>
  }

  export type $SensorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sensor"
    objects: {
      processStep: Prisma.$ProcessStepPayload<ExtArgs> | null
      transportSystem: Prisma.$TransportSystemPayload<ExtArgs> | null
      logEntries: Prisma.$LogEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      name: string
      type: string
      value: number
      sensorDelay: number
      active: boolean
      processStepId: number | null
      transportSystemId: number | null
    }, ExtArgs["result"]["sensor"]>
    composites: {}
  }

  type SensorGetPayload<S extends boolean | null | undefined | SensorDefaultArgs> = $Result.GetResult<Prisma.$SensorPayload, S>

  type SensorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SensorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SensorCountAggregateInputType | true
    }

  export interface SensorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sensor'], meta: { name: 'Sensor' } }
    /**
     * Find zero or one Sensor that matches the filter.
     * @param {SensorFindUniqueArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SensorFindUniqueArgs>(args: SelectSubset<T, SensorFindUniqueArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sensor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SensorFindUniqueOrThrowArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SensorFindUniqueOrThrowArgs>(args: SelectSubset<T, SensorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sensor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorFindFirstArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SensorFindFirstArgs>(args?: SelectSubset<T, SensorFindFirstArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sensor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorFindFirstOrThrowArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SensorFindFirstOrThrowArgs>(args?: SelectSubset<T, SensorFindFirstOrThrowArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sensors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sensors
     * const sensors = await prisma.sensor.findMany()
     * 
     * // Get first 10 Sensors
     * const sensors = await prisma.sensor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sensorWithIdOnly = await prisma.sensor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SensorFindManyArgs>(args?: SelectSubset<T, SensorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sensor.
     * @param {SensorCreateArgs} args - Arguments to create a Sensor.
     * @example
     * // Create one Sensor
     * const Sensor = await prisma.sensor.create({
     *   data: {
     *     // ... data to create a Sensor
     *   }
     * })
     * 
     */
    create<T extends SensorCreateArgs>(args: SelectSubset<T, SensorCreateArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sensors.
     * @param {SensorCreateManyArgs} args - Arguments to create many Sensors.
     * @example
     * // Create many Sensors
     * const sensor = await prisma.sensor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SensorCreateManyArgs>(args?: SelectSubset<T, SensorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sensors and returns the data saved in the database.
     * @param {SensorCreateManyAndReturnArgs} args - Arguments to create many Sensors.
     * @example
     * // Create many Sensors
     * const sensor = await prisma.sensor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sensors and only return the `id`
     * const sensorWithIdOnly = await prisma.sensor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SensorCreateManyAndReturnArgs>(args?: SelectSubset<T, SensorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Sensor.
     * @param {SensorDeleteArgs} args - Arguments to delete one Sensor.
     * @example
     * // Delete one Sensor
     * const Sensor = await prisma.sensor.delete({
     *   where: {
     *     // ... filter to delete one Sensor
     *   }
     * })
     * 
     */
    delete<T extends SensorDeleteArgs>(args: SelectSubset<T, SensorDeleteArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sensor.
     * @param {SensorUpdateArgs} args - Arguments to update one Sensor.
     * @example
     * // Update one Sensor
     * const sensor = await prisma.sensor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SensorUpdateArgs>(args: SelectSubset<T, SensorUpdateArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sensors.
     * @param {SensorDeleteManyArgs} args - Arguments to filter Sensors to delete.
     * @example
     * // Delete a few Sensors
     * const { count } = await prisma.sensor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SensorDeleteManyArgs>(args?: SelectSubset<T, SensorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sensors
     * const sensor = await prisma.sensor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SensorUpdateManyArgs>(args: SelectSubset<T, SensorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sensor.
     * @param {SensorUpsertArgs} args - Arguments to update or create a Sensor.
     * @example
     * // Update or create a Sensor
     * const sensor = await prisma.sensor.upsert({
     *   create: {
     *     // ... data to create a Sensor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sensor we want to update
     *   }
     * })
     */
    upsert<T extends SensorUpsertArgs>(args: SelectSubset<T, SensorUpsertArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorCountArgs} args - Arguments to filter Sensors to count.
     * @example
     * // Count the number of Sensors
     * const count = await prisma.sensor.count({
     *   where: {
     *     // ... the filter for the Sensors we want to count
     *   }
     * })
    **/
    count<T extends SensorCountArgs>(
      args?: Subset<T, SensorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SensorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sensor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SensorAggregateArgs>(args: Subset<T, SensorAggregateArgs>): Prisma.PrismaPromise<GetSensorAggregateType<T>>

    /**
     * Group by Sensor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SensorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SensorGroupByArgs['orderBy'] }
        : { orderBy?: SensorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SensorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSensorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sensor model
   */
  readonly fields: SensorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sensor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SensorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    processStep<T extends Sensor$processStepArgs<ExtArgs> = {}>(args?: Subset<T, Sensor$processStepArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transportSystem<T extends Sensor$transportSystemArgs<ExtArgs> = {}>(args?: Subset<T, Sensor$transportSystemArgs<ExtArgs>>): Prisma__TransportSystemClient<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    logEntries<T extends Sensor$logEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Sensor$logEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sensor model
   */ 
  interface SensorFieldRefs {
    readonly id: FieldRef<"Sensor", 'Int'>
    readonly createdAt: FieldRef<"Sensor", 'DateTime'>
    readonly updatedAt: FieldRef<"Sensor", 'DateTime'>
    readonly name: FieldRef<"Sensor", 'String'>
    readonly type: FieldRef<"Sensor", 'String'>
    readonly value: FieldRef<"Sensor", 'Int'>
    readonly sensorDelay: FieldRef<"Sensor", 'Int'>
    readonly active: FieldRef<"Sensor", 'Boolean'>
    readonly processStepId: FieldRef<"Sensor", 'Int'>
    readonly transportSystemId: FieldRef<"Sensor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Sensor findUnique
   */
  export type SensorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor findUniqueOrThrow
   */
  export type SensorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor findFirst
   */
  export type SensorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sensors.
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sensors.
     */
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * Sensor findFirstOrThrow
   */
  export type SensorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sensors.
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sensors.
     */
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * Sensor findMany
   */
  export type SensorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensors to fetch.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sensors.
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * Sensor create
   */
  export type SensorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * The data needed to create a Sensor.
     */
    data: XOR<SensorCreateInput, SensorUncheckedCreateInput>
  }

  /**
   * Sensor createMany
   */
  export type SensorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sensors.
     */
    data: SensorCreateManyInput | SensorCreateManyInput[]
  }

  /**
   * Sensor createManyAndReturn
   */
  export type SensorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sensors.
     */
    data: SensorCreateManyInput | SensorCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sensor update
   */
  export type SensorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * The data needed to update a Sensor.
     */
    data: XOR<SensorUpdateInput, SensorUncheckedUpdateInput>
    /**
     * Choose, which Sensor to update.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor updateMany
   */
  export type SensorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sensors.
     */
    data: XOR<SensorUpdateManyMutationInput, SensorUncheckedUpdateManyInput>
    /**
     * Filter which Sensors to update
     */
    where?: SensorWhereInput
  }

  /**
   * Sensor upsert
   */
  export type SensorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * The filter to search for the Sensor to update in case it exists.
     */
    where: SensorWhereUniqueInput
    /**
     * In case the Sensor found by the `where` argument doesn't exist, create a new Sensor with this data.
     */
    create: XOR<SensorCreateInput, SensorUncheckedCreateInput>
    /**
     * In case the Sensor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SensorUpdateInput, SensorUncheckedUpdateInput>
  }

  /**
   * Sensor delete
   */
  export type SensorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter which Sensor to delete.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor deleteMany
   */
  export type SensorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sensors to delete
     */
    where?: SensorWhereInput
  }

  /**
   * Sensor.processStep
   */
  export type Sensor$processStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
  }

  /**
   * Sensor.transportSystem
   */
  export type Sensor$transportSystemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    where?: TransportSystemWhereInput
  }

  /**
   * Sensor.logEntries
   */
  export type Sensor$logEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    where?: LogEntryWhereInput
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    cursor?: LogEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogEntryScalarFieldEnum | LogEntryScalarFieldEnum[]
  }

  /**
   * Sensor without action
   */
  export type SensorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
  }


  /**
   * Model FilterEntry
   */

  export type AggregateFilterEntry = {
    _count: FilterEntryCountAggregateOutputType | null
    _avg: FilterEntryAvgAggregateOutputType | null
    _sum: FilterEntrySumAggregateOutputType | null
    _min: FilterEntryMinAggregateOutputType | null
    _max: FilterEntryMaxAggregateOutputType | null
  }

  export type FilterEntryAvgAggregateOutputType = {
    id: number | null
    filterId: number | null
  }

  export type FilterEntrySumAggregateOutputType = {
    id: number | null
    filterId: number | null
  }

  export type FilterEntryMinAggregateOutputType = {
    id: number | null
    addedAt: Date | null
    material: string | null
    filterId: number | null
  }

  export type FilterEntryMaxAggregateOutputType = {
    id: number | null
    addedAt: Date | null
    material: string | null
    filterId: number | null
  }

  export type FilterEntryCountAggregateOutputType = {
    id: number
    addedAt: number
    material: number
    filterId: number
    _all: number
  }


  export type FilterEntryAvgAggregateInputType = {
    id?: true
    filterId?: true
  }

  export type FilterEntrySumAggregateInputType = {
    id?: true
    filterId?: true
  }

  export type FilterEntryMinAggregateInputType = {
    id?: true
    addedAt?: true
    material?: true
    filterId?: true
  }

  export type FilterEntryMaxAggregateInputType = {
    id?: true
    addedAt?: true
    material?: true
    filterId?: true
  }

  export type FilterEntryCountAggregateInputType = {
    id?: true
    addedAt?: true
    material?: true
    filterId?: true
    _all?: true
  }

  export type FilterEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilterEntry to aggregate.
     */
    where?: FilterEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilterEntries to fetch.
     */
    orderBy?: FilterEntryOrderByWithRelationInput | FilterEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FilterEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilterEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilterEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FilterEntries
    **/
    _count?: true | FilterEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilterEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilterEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilterEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilterEntryMaxAggregateInputType
  }

  export type GetFilterEntryAggregateType<T extends FilterEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateFilterEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilterEntry[P]>
      : GetScalarType<T[P], AggregateFilterEntry[P]>
  }




  export type FilterEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilterEntryWhereInput
    orderBy?: FilterEntryOrderByWithAggregationInput | FilterEntryOrderByWithAggregationInput[]
    by: FilterEntryScalarFieldEnum[] | FilterEntryScalarFieldEnum
    having?: FilterEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilterEntryCountAggregateInputType | true
    _avg?: FilterEntryAvgAggregateInputType
    _sum?: FilterEntrySumAggregateInputType
    _min?: FilterEntryMinAggregateInputType
    _max?: FilterEntryMaxAggregateInputType
  }

  export type FilterEntryGroupByOutputType = {
    id: number
    addedAt: Date
    material: string
    filterId: number
    _count: FilterEntryCountAggregateOutputType | null
    _avg: FilterEntryAvgAggregateOutputType | null
    _sum: FilterEntrySumAggregateOutputType | null
    _min: FilterEntryMinAggregateOutputType | null
    _max: FilterEntryMaxAggregateOutputType | null
  }

  type GetFilterEntryGroupByPayload<T extends FilterEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilterEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilterEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilterEntryGroupByOutputType[P]>
            : GetScalarType<T[P], FilterEntryGroupByOutputType[P]>
        }
      >
    >


  export type FilterEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addedAt?: boolean
    material?: boolean
    filterId?: boolean
    filter?: boolean | FilterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filterEntry"]>

  export type FilterEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addedAt?: boolean
    material?: boolean
    filterId?: boolean
    filter?: boolean | FilterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filterEntry"]>

  export type FilterEntrySelectScalar = {
    id?: boolean
    addedAt?: boolean
    material?: boolean
    filterId?: boolean
  }

  export type FilterEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filter?: boolean | FilterDefaultArgs<ExtArgs>
  }
  export type FilterEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filter?: boolean | FilterDefaultArgs<ExtArgs>
  }

  export type $FilterEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FilterEntry"
    objects: {
      filter: Prisma.$FilterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      addedAt: Date
      material: string
      filterId: number
    }, ExtArgs["result"]["filterEntry"]>
    composites: {}
  }

  type FilterEntryGetPayload<S extends boolean | null | undefined | FilterEntryDefaultArgs> = $Result.GetResult<Prisma.$FilterEntryPayload, S>

  type FilterEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FilterEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FilterEntryCountAggregateInputType | true
    }

  export interface FilterEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FilterEntry'], meta: { name: 'FilterEntry' } }
    /**
     * Find zero or one FilterEntry that matches the filter.
     * @param {FilterEntryFindUniqueArgs} args - Arguments to find a FilterEntry
     * @example
     * // Get one FilterEntry
     * const filterEntry = await prisma.filterEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FilterEntryFindUniqueArgs>(args: SelectSubset<T, FilterEntryFindUniqueArgs<ExtArgs>>): Prisma__FilterEntryClient<$Result.GetResult<Prisma.$FilterEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FilterEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FilterEntryFindUniqueOrThrowArgs} args - Arguments to find a FilterEntry
     * @example
     * // Get one FilterEntry
     * const filterEntry = await prisma.filterEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FilterEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, FilterEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FilterEntryClient<$Result.GetResult<Prisma.$FilterEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FilterEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterEntryFindFirstArgs} args - Arguments to find a FilterEntry
     * @example
     * // Get one FilterEntry
     * const filterEntry = await prisma.filterEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FilterEntryFindFirstArgs>(args?: SelectSubset<T, FilterEntryFindFirstArgs<ExtArgs>>): Prisma__FilterEntryClient<$Result.GetResult<Prisma.$FilterEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FilterEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterEntryFindFirstOrThrowArgs} args - Arguments to find a FilterEntry
     * @example
     * // Get one FilterEntry
     * const filterEntry = await prisma.filterEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FilterEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, FilterEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__FilterEntryClient<$Result.GetResult<Prisma.$FilterEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FilterEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FilterEntries
     * const filterEntries = await prisma.filterEntry.findMany()
     * 
     * // Get first 10 FilterEntries
     * const filterEntries = await prisma.filterEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filterEntryWithIdOnly = await prisma.filterEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FilterEntryFindManyArgs>(args?: SelectSubset<T, FilterEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilterEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FilterEntry.
     * @param {FilterEntryCreateArgs} args - Arguments to create a FilterEntry.
     * @example
     * // Create one FilterEntry
     * const FilterEntry = await prisma.filterEntry.create({
     *   data: {
     *     // ... data to create a FilterEntry
     *   }
     * })
     * 
     */
    create<T extends FilterEntryCreateArgs>(args: SelectSubset<T, FilterEntryCreateArgs<ExtArgs>>): Prisma__FilterEntryClient<$Result.GetResult<Prisma.$FilterEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FilterEntries.
     * @param {FilterEntryCreateManyArgs} args - Arguments to create many FilterEntries.
     * @example
     * // Create many FilterEntries
     * const filterEntry = await prisma.filterEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FilterEntryCreateManyArgs>(args?: SelectSubset<T, FilterEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FilterEntries and returns the data saved in the database.
     * @param {FilterEntryCreateManyAndReturnArgs} args - Arguments to create many FilterEntries.
     * @example
     * // Create many FilterEntries
     * const filterEntry = await prisma.filterEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FilterEntries and only return the `id`
     * const filterEntryWithIdOnly = await prisma.filterEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FilterEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, FilterEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilterEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FilterEntry.
     * @param {FilterEntryDeleteArgs} args - Arguments to delete one FilterEntry.
     * @example
     * // Delete one FilterEntry
     * const FilterEntry = await prisma.filterEntry.delete({
     *   where: {
     *     // ... filter to delete one FilterEntry
     *   }
     * })
     * 
     */
    delete<T extends FilterEntryDeleteArgs>(args: SelectSubset<T, FilterEntryDeleteArgs<ExtArgs>>): Prisma__FilterEntryClient<$Result.GetResult<Prisma.$FilterEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FilterEntry.
     * @param {FilterEntryUpdateArgs} args - Arguments to update one FilterEntry.
     * @example
     * // Update one FilterEntry
     * const filterEntry = await prisma.filterEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FilterEntryUpdateArgs>(args: SelectSubset<T, FilterEntryUpdateArgs<ExtArgs>>): Prisma__FilterEntryClient<$Result.GetResult<Prisma.$FilterEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FilterEntries.
     * @param {FilterEntryDeleteManyArgs} args - Arguments to filter FilterEntries to delete.
     * @example
     * // Delete a few FilterEntries
     * const { count } = await prisma.filterEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FilterEntryDeleteManyArgs>(args?: SelectSubset<T, FilterEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FilterEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FilterEntries
     * const filterEntry = await prisma.filterEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FilterEntryUpdateManyArgs>(args: SelectSubset<T, FilterEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FilterEntry.
     * @param {FilterEntryUpsertArgs} args - Arguments to update or create a FilterEntry.
     * @example
     * // Update or create a FilterEntry
     * const filterEntry = await prisma.filterEntry.upsert({
     *   create: {
     *     // ... data to create a FilterEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FilterEntry we want to update
     *   }
     * })
     */
    upsert<T extends FilterEntryUpsertArgs>(args: SelectSubset<T, FilterEntryUpsertArgs<ExtArgs>>): Prisma__FilterEntryClient<$Result.GetResult<Prisma.$FilterEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FilterEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterEntryCountArgs} args - Arguments to filter FilterEntries to count.
     * @example
     * // Count the number of FilterEntries
     * const count = await prisma.filterEntry.count({
     *   where: {
     *     // ... the filter for the FilterEntries we want to count
     *   }
     * })
    **/
    count<T extends FilterEntryCountArgs>(
      args?: Subset<T, FilterEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilterEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FilterEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilterEntryAggregateArgs>(args: Subset<T, FilterEntryAggregateArgs>): Prisma.PrismaPromise<GetFilterEntryAggregateType<T>>

    /**
     * Group by FilterEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilterEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilterEntryGroupByArgs['orderBy'] }
        : { orderBy?: FilterEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilterEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilterEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FilterEntry model
   */
  readonly fields: FilterEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FilterEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FilterEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filter<T extends FilterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FilterDefaultArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FilterEntry model
   */ 
  interface FilterEntryFieldRefs {
    readonly id: FieldRef<"FilterEntry", 'Int'>
    readonly addedAt: FieldRef<"FilterEntry", 'DateTime'>
    readonly material: FieldRef<"FilterEntry", 'String'>
    readonly filterId: FieldRef<"FilterEntry", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FilterEntry findUnique
   */
  export type FilterEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilterEntry
     */
    select?: FilterEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterEntryInclude<ExtArgs> | null
    /**
     * Filter, which FilterEntry to fetch.
     */
    where: FilterEntryWhereUniqueInput
  }

  /**
   * FilterEntry findUniqueOrThrow
   */
  export type FilterEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilterEntry
     */
    select?: FilterEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterEntryInclude<ExtArgs> | null
    /**
     * Filter, which FilterEntry to fetch.
     */
    where: FilterEntryWhereUniqueInput
  }

  /**
   * FilterEntry findFirst
   */
  export type FilterEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilterEntry
     */
    select?: FilterEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterEntryInclude<ExtArgs> | null
    /**
     * Filter, which FilterEntry to fetch.
     */
    where?: FilterEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilterEntries to fetch.
     */
    orderBy?: FilterEntryOrderByWithRelationInput | FilterEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilterEntries.
     */
    cursor?: FilterEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilterEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilterEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilterEntries.
     */
    distinct?: FilterEntryScalarFieldEnum | FilterEntryScalarFieldEnum[]
  }

  /**
   * FilterEntry findFirstOrThrow
   */
  export type FilterEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilterEntry
     */
    select?: FilterEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterEntryInclude<ExtArgs> | null
    /**
     * Filter, which FilterEntry to fetch.
     */
    where?: FilterEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilterEntries to fetch.
     */
    orderBy?: FilterEntryOrderByWithRelationInput | FilterEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilterEntries.
     */
    cursor?: FilterEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilterEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilterEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilterEntries.
     */
    distinct?: FilterEntryScalarFieldEnum | FilterEntryScalarFieldEnum[]
  }

  /**
   * FilterEntry findMany
   */
  export type FilterEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilterEntry
     */
    select?: FilterEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterEntryInclude<ExtArgs> | null
    /**
     * Filter, which FilterEntries to fetch.
     */
    where?: FilterEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilterEntries to fetch.
     */
    orderBy?: FilterEntryOrderByWithRelationInput | FilterEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FilterEntries.
     */
    cursor?: FilterEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilterEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilterEntries.
     */
    skip?: number
    distinct?: FilterEntryScalarFieldEnum | FilterEntryScalarFieldEnum[]
  }

  /**
   * FilterEntry create
   */
  export type FilterEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilterEntry
     */
    select?: FilterEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a FilterEntry.
     */
    data: XOR<FilterEntryCreateInput, FilterEntryUncheckedCreateInput>
  }

  /**
   * FilterEntry createMany
   */
  export type FilterEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FilterEntries.
     */
    data: FilterEntryCreateManyInput | FilterEntryCreateManyInput[]
  }

  /**
   * FilterEntry createManyAndReturn
   */
  export type FilterEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilterEntry
     */
    select?: FilterEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FilterEntries.
     */
    data: FilterEntryCreateManyInput | FilterEntryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FilterEntry update
   */
  export type FilterEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilterEntry
     */
    select?: FilterEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a FilterEntry.
     */
    data: XOR<FilterEntryUpdateInput, FilterEntryUncheckedUpdateInput>
    /**
     * Choose, which FilterEntry to update.
     */
    where: FilterEntryWhereUniqueInput
  }

  /**
   * FilterEntry updateMany
   */
  export type FilterEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FilterEntries.
     */
    data: XOR<FilterEntryUpdateManyMutationInput, FilterEntryUncheckedUpdateManyInput>
    /**
     * Filter which FilterEntries to update
     */
    where?: FilterEntryWhereInput
  }

  /**
   * FilterEntry upsert
   */
  export type FilterEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilterEntry
     */
    select?: FilterEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the FilterEntry to update in case it exists.
     */
    where: FilterEntryWhereUniqueInput
    /**
     * In case the FilterEntry found by the `where` argument doesn't exist, create a new FilterEntry with this data.
     */
    create: XOR<FilterEntryCreateInput, FilterEntryUncheckedCreateInput>
    /**
     * In case the FilterEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FilterEntryUpdateInput, FilterEntryUncheckedUpdateInput>
  }

  /**
   * FilterEntry delete
   */
  export type FilterEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilterEntry
     */
    select?: FilterEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterEntryInclude<ExtArgs> | null
    /**
     * Filter which FilterEntry to delete.
     */
    where: FilterEntryWhereUniqueInput
  }

  /**
   * FilterEntry deleteMany
   */
  export type FilterEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilterEntries to delete
     */
    where?: FilterEntryWhereInput
  }

  /**
   * FilterEntry without action
   */
  export type FilterEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilterEntry
     */
    select?: FilterEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterEntryInclude<ExtArgs> | null
  }


  /**
   * Model Filter
   */

  export type AggregateFilter = {
    _count: FilterCountAggregateOutputType | null
    _avg: FilterAvgAggregateOutputType | null
    _sum: FilterSumAggregateOutputType | null
    _min: FilterMinAggregateOutputType | null
    _max: FilterMaxAggregateOutputType | null
  }

  export type FilterAvgAggregateOutputType = {
    id: number | null
    transportSystemId: number | null
    orderId: number | null
  }

  export type FilterSumAggregateOutputType = {
    id: number | null
    transportSystemId: number | null
    orderId: number | null
  }

  export type FilterMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    transportSystemId: number | null
    orderId: number | null
  }

  export type FilterMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    transportSystemId: number | null
    orderId: number | null
  }

  export type FilterCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    transportSystemId: number
    orderId: number
    _all: number
  }


  export type FilterAvgAggregateInputType = {
    id?: true
    transportSystemId?: true
    orderId?: true
  }

  export type FilterSumAggregateInputType = {
    id?: true
    transportSystemId?: true
    orderId?: true
  }

  export type FilterMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    transportSystemId?: true
    orderId?: true
  }

  export type FilterMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    transportSystemId?: true
    orderId?: true
  }

  export type FilterCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    transportSystemId?: true
    orderId?: true
    _all?: true
  }

  export type FilterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Filter to aggregate.
     */
    where?: FilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filters to fetch.
     */
    orderBy?: FilterOrderByWithRelationInput | FilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Filters
    **/
    _count?: true | FilterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilterMaxAggregateInputType
  }

  export type GetFilterAggregateType<T extends FilterAggregateArgs> = {
        [P in keyof T & keyof AggregateFilter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilter[P]>
      : GetScalarType<T[P], AggregateFilter[P]>
  }




  export type FilterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilterWhereInput
    orderBy?: FilterOrderByWithAggregationInput | FilterOrderByWithAggregationInput[]
    by: FilterScalarFieldEnum[] | FilterScalarFieldEnum
    having?: FilterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilterCountAggregateInputType | true
    _avg?: FilterAvgAggregateInputType
    _sum?: FilterSumAggregateInputType
    _min?: FilterMinAggregateInputType
    _max?: FilterMaxAggregateInputType
  }

  export type FilterGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    transportSystemId: number
    orderId: number | null
    _count: FilterCountAggregateOutputType | null
    _avg: FilterAvgAggregateOutputType | null
    _sum: FilterSumAggregateOutputType | null
    _min: FilterMinAggregateOutputType | null
    _max: FilterMaxAggregateOutputType | null
  }

  type GetFilterGroupByPayload<T extends FilterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilterGroupByOutputType[P]>
            : GetScalarType<T[P], FilterGroupByOutputType[P]>
        }
      >
    >


  export type FilterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transportSystemId?: boolean
    orderId?: boolean
    transportSystem?: boolean | TransportSystemDefaultArgs<ExtArgs>
    entries?: boolean | Filter$entriesArgs<ExtArgs>
    _count?: boolean | FilterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filter"]>

  export type FilterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transportSystemId?: boolean
    orderId?: boolean
    transportSystem?: boolean | TransportSystemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filter"]>

  export type FilterSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transportSystemId?: boolean
    orderId?: boolean
  }

  export type FilterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transportSystem?: boolean | TransportSystemDefaultArgs<ExtArgs>
    entries?: boolean | Filter$entriesArgs<ExtArgs>
    _count?: boolean | FilterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FilterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transportSystem?: boolean | TransportSystemDefaultArgs<ExtArgs>
  }

  export type $FilterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Filter"
    objects: {
      transportSystem: Prisma.$TransportSystemPayload<ExtArgs>
      entries: Prisma.$FilterEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      transportSystemId: number
      orderId: number | null
    }, ExtArgs["result"]["filter"]>
    composites: {}
  }

  type FilterGetPayload<S extends boolean | null | undefined | FilterDefaultArgs> = $Result.GetResult<Prisma.$FilterPayload, S>

  type FilterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FilterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FilterCountAggregateInputType | true
    }

  export interface FilterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Filter'], meta: { name: 'Filter' } }
    /**
     * Find zero or one Filter that matches the filter.
     * @param {FilterFindUniqueArgs} args - Arguments to find a Filter
     * @example
     * // Get one Filter
     * const filter = await prisma.filter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FilterFindUniqueArgs>(args: SelectSubset<T, FilterFindUniqueArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Filter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FilterFindUniqueOrThrowArgs} args - Arguments to find a Filter
     * @example
     * // Get one Filter
     * const filter = await prisma.filter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FilterFindUniqueOrThrowArgs>(args: SelectSubset<T, FilterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Filter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterFindFirstArgs} args - Arguments to find a Filter
     * @example
     * // Get one Filter
     * const filter = await prisma.filter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FilterFindFirstArgs>(args?: SelectSubset<T, FilterFindFirstArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Filter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterFindFirstOrThrowArgs} args - Arguments to find a Filter
     * @example
     * // Get one Filter
     * const filter = await prisma.filter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FilterFindFirstOrThrowArgs>(args?: SelectSubset<T, FilterFindFirstOrThrowArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Filters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Filters
     * const filters = await prisma.filter.findMany()
     * 
     * // Get first 10 Filters
     * const filters = await prisma.filter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filterWithIdOnly = await prisma.filter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FilterFindManyArgs>(args?: SelectSubset<T, FilterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Filter.
     * @param {FilterCreateArgs} args - Arguments to create a Filter.
     * @example
     * // Create one Filter
     * const Filter = await prisma.filter.create({
     *   data: {
     *     // ... data to create a Filter
     *   }
     * })
     * 
     */
    create<T extends FilterCreateArgs>(args: SelectSubset<T, FilterCreateArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Filters.
     * @param {FilterCreateManyArgs} args - Arguments to create many Filters.
     * @example
     * // Create many Filters
     * const filter = await prisma.filter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FilterCreateManyArgs>(args?: SelectSubset<T, FilterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Filters and returns the data saved in the database.
     * @param {FilterCreateManyAndReturnArgs} args - Arguments to create many Filters.
     * @example
     * // Create many Filters
     * const filter = await prisma.filter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Filters and only return the `id`
     * const filterWithIdOnly = await prisma.filter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FilterCreateManyAndReturnArgs>(args?: SelectSubset<T, FilterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Filter.
     * @param {FilterDeleteArgs} args - Arguments to delete one Filter.
     * @example
     * // Delete one Filter
     * const Filter = await prisma.filter.delete({
     *   where: {
     *     // ... filter to delete one Filter
     *   }
     * })
     * 
     */
    delete<T extends FilterDeleteArgs>(args: SelectSubset<T, FilterDeleteArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Filter.
     * @param {FilterUpdateArgs} args - Arguments to update one Filter.
     * @example
     * // Update one Filter
     * const filter = await prisma.filter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FilterUpdateArgs>(args: SelectSubset<T, FilterUpdateArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Filters.
     * @param {FilterDeleteManyArgs} args - Arguments to filter Filters to delete.
     * @example
     * // Delete a few Filters
     * const { count } = await prisma.filter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FilterDeleteManyArgs>(args?: SelectSubset<T, FilterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Filters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Filters
     * const filter = await prisma.filter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FilterUpdateManyArgs>(args: SelectSubset<T, FilterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Filter.
     * @param {FilterUpsertArgs} args - Arguments to update or create a Filter.
     * @example
     * // Update or create a Filter
     * const filter = await prisma.filter.upsert({
     *   create: {
     *     // ... data to create a Filter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Filter we want to update
     *   }
     * })
     */
    upsert<T extends FilterUpsertArgs>(args: SelectSubset<T, FilterUpsertArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Filters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterCountArgs} args - Arguments to filter Filters to count.
     * @example
     * // Count the number of Filters
     * const count = await prisma.filter.count({
     *   where: {
     *     // ... the filter for the Filters we want to count
     *   }
     * })
    **/
    count<T extends FilterCountArgs>(
      args?: Subset<T, FilterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilterAggregateArgs>(args: Subset<T, FilterAggregateArgs>): Prisma.PrismaPromise<GetFilterAggregateType<T>>

    /**
     * Group by Filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilterGroupByArgs['orderBy'] }
        : { orderBy?: FilterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Filter model
   */
  readonly fields: FilterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Filter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FilterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transportSystem<T extends TransportSystemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransportSystemDefaultArgs<ExtArgs>>): Prisma__TransportSystemClient<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    entries<T extends Filter$entriesArgs<ExtArgs> = {}>(args?: Subset<T, Filter$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilterEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Filter model
   */ 
  interface FilterFieldRefs {
    readonly id: FieldRef<"Filter", 'Int'>
    readonly createdAt: FieldRef<"Filter", 'DateTime'>
    readonly updatedAt: FieldRef<"Filter", 'DateTime'>
    readonly transportSystemId: FieldRef<"Filter", 'Int'>
    readonly orderId: FieldRef<"Filter", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Filter findUnique
   */
  export type FilterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * Filter, which Filter to fetch.
     */
    where: FilterWhereUniqueInput
  }

  /**
   * Filter findUniqueOrThrow
   */
  export type FilterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * Filter, which Filter to fetch.
     */
    where: FilterWhereUniqueInput
  }

  /**
   * Filter findFirst
   */
  export type FilterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * Filter, which Filter to fetch.
     */
    where?: FilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filters to fetch.
     */
    orderBy?: FilterOrderByWithRelationInput | FilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Filters.
     */
    cursor?: FilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Filters.
     */
    distinct?: FilterScalarFieldEnum | FilterScalarFieldEnum[]
  }

  /**
   * Filter findFirstOrThrow
   */
  export type FilterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * Filter, which Filter to fetch.
     */
    where?: FilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filters to fetch.
     */
    orderBy?: FilterOrderByWithRelationInput | FilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Filters.
     */
    cursor?: FilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Filters.
     */
    distinct?: FilterScalarFieldEnum | FilterScalarFieldEnum[]
  }

  /**
   * Filter findMany
   */
  export type FilterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * Filter, which Filters to fetch.
     */
    where?: FilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filters to fetch.
     */
    orderBy?: FilterOrderByWithRelationInput | FilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Filters.
     */
    cursor?: FilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filters.
     */
    skip?: number
    distinct?: FilterScalarFieldEnum | FilterScalarFieldEnum[]
  }

  /**
   * Filter create
   */
  export type FilterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * The data needed to create a Filter.
     */
    data: XOR<FilterCreateInput, FilterUncheckedCreateInput>
  }

  /**
   * Filter createMany
   */
  export type FilterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Filters.
     */
    data: FilterCreateManyInput | FilterCreateManyInput[]
  }

  /**
   * Filter createManyAndReturn
   */
  export type FilterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Filters.
     */
    data: FilterCreateManyInput | FilterCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Filter update
   */
  export type FilterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * The data needed to update a Filter.
     */
    data: XOR<FilterUpdateInput, FilterUncheckedUpdateInput>
    /**
     * Choose, which Filter to update.
     */
    where: FilterWhereUniqueInput
  }

  /**
   * Filter updateMany
   */
  export type FilterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Filters.
     */
    data: XOR<FilterUpdateManyMutationInput, FilterUncheckedUpdateManyInput>
    /**
     * Filter which Filters to update
     */
    where?: FilterWhereInput
  }

  /**
   * Filter upsert
   */
  export type FilterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * The filter to search for the Filter to update in case it exists.
     */
    where: FilterWhereUniqueInput
    /**
     * In case the Filter found by the `where` argument doesn't exist, create a new Filter with this data.
     */
    create: XOR<FilterCreateInput, FilterUncheckedCreateInput>
    /**
     * In case the Filter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FilterUpdateInput, FilterUncheckedUpdateInput>
  }

  /**
   * Filter delete
   */
  export type FilterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    /**
     * Filter which Filter to delete.
     */
    where: FilterWhereUniqueInput
  }

  /**
   * Filter deleteMany
   */
  export type FilterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Filters to delete
     */
    where?: FilterWhereInput
  }

  /**
   * Filter.entries
   */
  export type Filter$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilterEntry
     */
    select?: FilterEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterEntryInclude<ExtArgs> | null
    where?: FilterEntryWhereInput
    orderBy?: FilterEntryOrderByWithRelationInput | FilterEntryOrderByWithRelationInput[]
    cursor?: FilterEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilterEntryScalarFieldEnum | FilterEntryScalarFieldEnum[]
  }

  /**
   * Filter without action
   */
  export type FilterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
  }


  /**
   * Model TransportSystem
   */

  export type AggregateTransportSystem = {
    _count: TransportSystemCountAggregateOutputType | null
    _avg: TransportSystemAvgAggregateOutputType | null
    _sum: TransportSystemSumAggregateOutputType | null
    _min: TransportSystemMinAggregateOutputType | null
    _max: TransportSystemMaxAggregateOutputType | null
  }

  export type TransportSystemAvgAggregateOutputType = {
    id: number | null
    inputSpeed: number | null
    outputSpeed: number | null
    inventoryId: number | null
    minQuantity: number | null
    transportDelay: number | null
    startStepId: number | null
    endStepId: number | null
    startTSId: number | null
    endTSId: number | null
  }

  export type TransportSystemSumAggregateOutputType = {
    id: number | null
    inputSpeed: number | null
    outputSpeed: number | null
    inventoryId: number | null
    minQuantity: number | null
    transportDelay: number | null
    startStepId: number | null
    endStepId: number | null
    startTSId: number | null
    endTSId: number | null
  }

  export type TransportSystemMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    active: boolean | null
    name: string | null
    inputSpeed: number | null
    outputSpeed: number | null
    inventoryId: number | null
    minQuantity: number | null
    transportDelay: number | null
    startStepId: number | null
    endStepId: number | null
    type: string | null
    startTSId: number | null
    endTSId: number | null
  }

  export type TransportSystemMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    active: boolean | null
    name: string | null
    inputSpeed: number | null
    outputSpeed: number | null
    inventoryId: number | null
    minQuantity: number | null
    transportDelay: number | null
    startStepId: number | null
    endStepId: number | null
    type: string | null
    startTSId: number | null
    endTSId: number | null
  }

  export type TransportSystemCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    active: number
    name: number
    inputSpeed: number
    outputSpeed: number
    inventoryId: number
    minQuantity: number
    transportDelay: number
    startStepId: number
    endStepId: number
    type: number
    startTSId: number
    endTSId: number
    _all: number
  }


  export type TransportSystemAvgAggregateInputType = {
    id?: true
    inputSpeed?: true
    outputSpeed?: true
    inventoryId?: true
    minQuantity?: true
    transportDelay?: true
    startStepId?: true
    endStepId?: true
    startTSId?: true
    endTSId?: true
  }

  export type TransportSystemSumAggregateInputType = {
    id?: true
    inputSpeed?: true
    outputSpeed?: true
    inventoryId?: true
    minQuantity?: true
    transportDelay?: true
    startStepId?: true
    endStepId?: true
    startTSId?: true
    endTSId?: true
  }

  export type TransportSystemMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    active?: true
    name?: true
    inputSpeed?: true
    outputSpeed?: true
    inventoryId?: true
    minQuantity?: true
    transportDelay?: true
    startStepId?: true
    endStepId?: true
    type?: true
    startTSId?: true
    endTSId?: true
  }

  export type TransportSystemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    active?: true
    name?: true
    inputSpeed?: true
    outputSpeed?: true
    inventoryId?: true
    minQuantity?: true
    transportDelay?: true
    startStepId?: true
    endStepId?: true
    type?: true
    startTSId?: true
    endTSId?: true
  }

  export type TransportSystemCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    active?: true
    name?: true
    inputSpeed?: true
    outputSpeed?: true
    inventoryId?: true
    minQuantity?: true
    transportDelay?: true
    startStepId?: true
    endStepId?: true
    type?: true
    startTSId?: true
    endTSId?: true
    _all?: true
  }

  export type TransportSystemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransportSystem to aggregate.
     */
    where?: TransportSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransportSystems to fetch.
     */
    orderBy?: TransportSystemOrderByWithRelationInput | TransportSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransportSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransportSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransportSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransportSystems
    **/
    _count?: true | TransportSystemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransportSystemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransportSystemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransportSystemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransportSystemMaxAggregateInputType
  }

  export type GetTransportSystemAggregateType<T extends TransportSystemAggregateArgs> = {
        [P in keyof T & keyof AggregateTransportSystem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransportSystem[P]>
      : GetScalarType<T[P], AggregateTransportSystem[P]>
  }




  export type TransportSystemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportSystemWhereInput
    orderBy?: TransportSystemOrderByWithAggregationInput | TransportSystemOrderByWithAggregationInput[]
    by: TransportSystemScalarFieldEnum[] | TransportSystemScalarFieldEnum
    having?: TransportSystemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransportSystemCountAggregateInputType | true
    _avg?: TransportSystemAvgAggregateInputType
    _sum?: TransportSystemSumAggregateInputType
    _min?: TransportSystemMinAggregateInputType
    _max?: TransportSystemMaxAggregateInputType
  }

  export type TransportSystemGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    active: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    inventoryId: number
    minQuantity: number | null
    transportDelay: number | null
    startStepId: number | null
    endStepId: number | null
    type: string
    startTSId: number | null
    endTSId: number | null
    _count: TransportSystemCountAggregateOutputType | null
    _avg: TransportSystemAvgAggregateOutputType | null
    _sum: TransportSystemSumAggregateOutputType | null
    _min: TransportSystemMinAggregateOutputType | null
    _max: TransportSystemMaxAggregateOutputType | null
  }

  type GetTransportSystemGroupByPayload<T extends TransportSystemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransportSystemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransportSystemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransportSystemGroupByOutputType[P]>
            : GetScalarType<T[P], TransportSystemGroupByOutputType[P]>
        }
      >
    >


  export type TransportSystemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    active?: boolean
    name?: boolean
    inputSpeed?: boolean
    outputSpeed?: boolean
    inventoryId?: boolean
    minQuantity?: boolean
    transportDelay?: boolean
    startStepId?: boolean
    endStepId?: boolean
    type?: boolean
    startTSId?: boolean
    endTSId?: boolean
    endStep?: boolean | TransportSystem$endStepArgs<ExtArgs>
    startStep?: boolean | TransportSystem$startStepArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    orders?: boolean | TransportSystem$ordersArgs<ExtArgs>
    filter?: boolean | TransportSystem$filterArgs<ExtArgs>
    sensors?: boolean | TransportSystem$sensorsArgs<ExtArgs>
    resources?: boolean | TransportSystem$resourcesArgs<ExtArgs>
    _count?: boolean | TransportSystemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transportSystem"]>

  export type TransportSystemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    active?: boolean
    name?: boolean
    inputSpeed?: boolean
    outputSpeed?: boolean
    inventoryId?: boolean
    minQuantity?: boolean
    transportDelay?: boolean
    startStepId?: boolean
    endStepId?: boolean
    type?: boolean
    startTSId?: boolean
    endTSId?: boolean
    endStep?: boolean | TransportSystem$endStepArgs<ExtArgs>
    startStep?: boolean | TransportSystem$startStepArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transportSystem"]>

  export type TransportSystemSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    active?: boolean
    name?: boolean
    inputSpeed?: boolean
    outputSpeed?: boolean
    inventoryId?: boolean
    minQuantity?: boolean
    transportDelay?: boolean
    startStepId?: boolean
    endStepId?: boolean
    type?: boolean
    startTSId?: boolean
    endTSId?: boolean
  }

  export type TransportSystemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endStep?: boolean | TransportSystem$endStepArgs<ExtArgs>
    startStep?: boolean | TransportSystem$startStepArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    orders?: boolean | TransportSystem$ordersArgs<ExtArgs>
    filter?: boolean | TransportSystem$filterArgs<ExtArgs>
    sensors?: boolean | TransportSystem$sensorsArgs<ExtArgs>
    resources?: boolean | TransportSystem$resourcesArgs<ExtArgs>
    _count?: boolean | TransportSystemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransportSystemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endStep?: boolean | TransportSystem$endStepArgs<ExtArgs>
    startStep?: boolean | TransportSystem$startStepArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }

  export type $TransportSystemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransportSystem"
    objects: {
      endStep: Prisma.$ProcessStepPayload<ExtArgs> | null
      startStep: Prisma.$ProcessStepPayload<ExtArgs> | null
      inventory: Prisma.$InventoryPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs>[]
      filter: Prisma.$FilterPayload<ExtArgs> | null
      sensors: Prisma.$SensorPayload<ExtArgs>[]
      resources: Prisma.$ResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      active: boolean
      name: string
      inputSpeed: number
      outputSpeed: number
      inventoryId: number
      minQuantity: number | null
      transportDelay: number | null
      startStepId: number | null
      endStepId: number | null
      type: string
      startTSId: number | null
      endTSId: number | null
    }, ExtArgs["result"]["transportSystem"]>
    composites: {}
  }

  type TransportSystemGetPayload<S extends boolean | null | undefined | TransportSystemDefaultArgs> = $Result.GetResult<Prisma.$TransportSystemPayload, S>

  type TransportSystemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransportSystemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransportSystemCountAggregateInputType | true
    }

  export interface TransportSystemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransportSystem'], meta: { name: 'TransportSystem' } }
    /**
     * Find zero or one TransportSystem that matches the filter.
     * @param {TransportSystemFindUniqueArgs} args - Arguments to find a TransportSystem
     * @example
     * // Get one TransportSystem
     * const transportSystem = await prisma.transportSystem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransportSystemFindUniqueArgs>(args: SelectSubset<T, TransportSystemFindUniqueArgs<ExtArgs>>): Prisma__TransportSystemClient<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TransportSystem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransportSystemFindUniqueOrThrowArgs} args - Arguments to find a TransportSystem
     * @example
     * // Get one TransportSystem
     * const transportSystem = await prisma.transportSystem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransportSystemFindUniqueOrThrowArgs>(args: SelectSubset<T, TransportSystemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransportSystemClient<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TransportSystem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportSystemFindFirstArgs} args - Arguments to find a TransportSystem
     * @example
     * // Get one TransportSystem
     * const transportSystem = await prisma.transportSystem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransportSystemFindFirstArgs>(args?: SelectSubset<T, TransportSystemFindFirstArgs<ExtArgs>>): Prisma__TransportSystemClient<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TransportSystem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportSystemFindFirstOrThrowArgs} args - Arguments to find a TransportSystem
     * @example
     * // Get one TransportSystem
     * const transportSystem = await prisma.transportSystem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransportSystemFindFirstOrThrowArgs>(args?: SelectSubset<T, TransportSystemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransportSystemClient<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TransportSystems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportSystemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransportSystems
     * const transportSystems = await prisma.transportSystem.findMany()
     * 
     * // Get first 10 TransportSystems
     * const transportSystems = await prisma.transportSystem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transportSystemWithIdOnly = await prisma.transportSystem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransportSystemFindManyArgs>(args?: SelectSubset<T, TransportSystemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TransportSystem.
     * @param {TransportSystemCreateArgs} args - Arguments to create a TransportSystem.
     * @example
     * // Create one TransportSystem
     * const TransportSystem = await prisma.transportSystem.create({
     *   data: {
     *     // ... data to create a TransportSystem
     *   }
     * })
     * 
     */
    create<T extends TransportSystemCreateArgs>(args: SelectSubset<T, TransportSystemCreateArgs<ExtArgs>>): Prisma__TransportSystemClient<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TransportSystems.
     * @param {TransportSystemCreateManyArgs} args - Arguments to create many TransportSystems.
     * @example
     * // Create many TransportSystems
     * const transportSystem = await prisma.transportSystem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransportSystemCreateManyArgs>(args?: SelectSubset<T, TransportSystemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransportSystems and returns the data saved in the database.
     * @param {TransportSystemCreateManyAndReturnArgs} args - Arguments to create many TransportSystems.
     * @example
     * // Create many TransportSystems
     * const transportSystem = await prisma.transportSystem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransportSystems and only return the `id`
     * const transportSystemWithIdOnly = await prisma.transportSystem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransportSystemCreateManyAndReturnArgs>(args?: SelectSubset<T, TransportSystemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TransportSystem.
     * @param {TransportSystemDeleteArgs} args - Arguments to delete one TransportSystem.
     * @example
     * // Delete one TransportSystem
     * const TransportSystem = await prisma.transportSystem.delete({
     *   where: {
     *     // ... filter to delete one TransportSystem
     *   }
     * })
     * 
     */
    delete<T extends TransportSystemDeleteArgs>(args: SelectSubset<T, TransportSystemDeleteArgs<ExtArgs>>): Prisma__TransportSystemClient<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TransportSystem.
     * @param {TransportSystemUpdateArgs} args - Arguments to update one TransportSystem.
     * @example
     * // Update one TransportSystem
     * const transportSystem = await prisma.transportSystem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransportSystemUpdateArgs>(args: SelectSubset<T, TransportSystemUpdateArgs<ExtArgs>>): Prisma__TransportSystemClient<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TransportSystems.
     * @param {TransportSystemDeleteManyArgs} args - Arguments to filter TransportSystems to delete.
     * @example
     * // Delete a few TransportSystems
     * const { count } = await prisma.transportSystem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransportSystemDeleteManyArgs>(args?: SelectSubset<T, TransportSystemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransportSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportSystemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransportSystems
     * const transportSystem = await prisma.transportSystem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransportSystemUpdateManyArgs>(args: SelectSubset<T, TransportSystemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransportSystem.
     * @param {TransportSystemUpsertArgs} args - Arguments to update or create a TransportSystem.
     * @example
     * // Update or create a TransportSystem
     * const transportSystem = await prisma.transportSystem.upsert({
     *   create: {
     *     // ... data to create a TransportSystem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransportSystem we want to update
     *   }
     * })
     */
    upsert<T extends TransportSystemUpsertArgs>(args: SelectSubset<T, TransportSystemUpsertArgs<ExtArgs>>): Prisma__TransportSystemClient<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TransportSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportSystemCountArgs} args - Arguments to filter TransportSystems to count.
     * @example
     * // Count the number of TransportSystems
     * const count = await prisma.transportSystem.count({
     *   where: {
     *     // ... the filter for the TransportSystems we want to count
     *   }
     * })
    **/
    count<T extends TransportSystemCountArgs>(
      args?: Subset<T, TransportSystemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransportSystemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransportSystem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportSystemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransportSystemAggregateArgs>(args: Subset<T, TransportSystemAggregateArgs>): Prisma.PrismaPromise<GetTransportSystemAggregateType<T>>

    /**
     * Group by TransportSystem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportSystemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransportSystemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransportSystemGroupByArgs['orderBy'] }
        : { orderBy?: TransportSystemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransportSystemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransportSystemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransportSystem model
   */
  readonly fields: TransportSystemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransportSystem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransportSystemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    endStep<T extends TransportSystem$endStepArgs<ExtArgs> = {}>(args?: Subset<T, TransportSystem$endStepArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    startStep<T extends TransportSystem$startStepArgs<ExtArgs> = {}>(args?: Subset<T, TransportSystem$startStepArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    orders<T extends TransportSystem$ordersArgs<ExtArgs> = {}>(args?: Subset<T, TransportSystem$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    filter<T extends TransportSystem$filterArgs<ExtArgs> = {}>(args?: Subset<T, TransportSystem$filterArgs<ExtArgs>>): Prisma__FilterClient<$Result.GetResult<Prisma.$FilterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sensors<T extends TransportSystem$sensorsArgs<ExtArgs> = {}>(args?: Subset<T, TransportSystem$sensorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findMany"> | Null>
    resources<T extends TransportSystem$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, TransportSystem$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransportSystem model
   */ 
  interface TransportSystemFieldRefs {
    readonly id: FieldRef<"TransportSystem", 'Int'>
    readonly createdAt: FieldRef<"TransportSystem", 'DateTime'>
    readonly updatedAt: FieldRef<"TransportSystem", 'DateTime'>
    readonly active: FieldRef<"TransportSystem", 'Boolean'>
    readonly name: FieldRef<"TransportSystem", 'String'>
    readonly inputSpeed: FieldRef<"TransportSystem", 'Int'>
    readonly outputSpeed: FieldRef<"TransportSystem", 'Int'>
    readonly inventoryId: FieldRef<"TransportSystem", 'Int'>
    readonly minQuantity: FieldRef<"TransportSystem", 'Int'>
    readonly transportDelay: FieldRef<"TransportSystem", 'Int'>
    readonly startStepId: FieldRef<"TransportSystem", 'Int'>
    readonly endStepId: FieldRef<"TransportSystem", 'Int'>
    readonly type: FieldRef<"TransportSystem", 'String'>
    readonly startTSId: FieldRef<"TransportSystem", 'Int'>
    readonly endTSId: FieldRef<"TransportSystem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TransportSystem findUnique
   */
  export type TransportSystemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    /**
     * Filter, which TransportSystem to fetch.
     */
    where: TransportSystemWhereUniqueInput
  }

  /**
   * TransportSystem findUniqueOrThrow
   */
  export type TransportSystemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    /**
     * Filter, which TransportSystem to fetch.
     */
    where: TransportSystemWhereUniqueInput
  }

  /**
   * TransportSystem findFirst
   */
  export type TransportSystemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    /**
     * Filter, which TransportSystem to fetch.
     */
    where?: TransportSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransportSystems to fetch.
     */
    orderBy?: TransportSystemOrderByWithRelationInput | TransportSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransportSystems.
     */
    cursor?: TransportSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransportSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransportSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransportSystems.
     */
    distinct?: TransportSystemScalarFieldEnum | TransportSystemScalarFieldEnum[]
  }

  /**
   * TransportSystem findFirstOrThrow
   */
  export type TransportSystemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    /**
     * Filter, which TransportSystem to fetch.
     */
    where?: TransportSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransportSystems to fetch.
     */
    orderBy?: TransportSystemOrderByWithRelationInput | TransportSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransportSystems.
     */
    cursor?: TransportSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransportSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransportSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransportSystems.
     */
    distinct?: TransportSystemScalarFieldEnum | TransportSystemScalarFieldEnum[]
  }

  /**
   * TransportSystem findMany
   */
  export type TransportSystemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    /**
     * Filter, which TransportSystems to fetch.
     */
    where?: TransportSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransportSystems to fetch.
     */
    orderBy?: TransportSystemOrderByWithRelationInput | TransportSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransportSystems.
     */
    cursor?: TransportSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransportSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransportSystems.
     */
    skip?: number
    distinct?: TransportSystemScalarFieldEnum | TransportSystemScalarFieldEnum[]
  }

  /**
   * TransportSystem create
   */
  export type TransportSystemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    /**
     * The data needed to create a TransportSystem.
     */
    data: XOR<TransportSystemCreateInput, TransportSystemUncheckedCreateInput>
  }

  /**
   * TransportSystem createMany
   */
  export type TransportSystemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransportSystems.
     */
    data: TransportSystemCreateManyInput | TransportSystemCreateManyInput[]
  }

  /**
   * TransportSystem createManyAndReturn
   */
  export type TransportSystemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TransportSystems.
     */
    data: TransportSystemCreateManyInput | TransportSystemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransportSystem update
   */
  export type TransportSystemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    /**
     * The data needed to update a TransportSystem.
     */
    data: XOR<TransportSystemUpdateInput, TransportSystemUncheckedUpdateInput>
    /**
     * Choose, which TransportSystem to update.
     */
    where: TransportSystemWhereUniqueInput
  }

  /**
   * TransportSystem updateMany
   */
  export type TransportSystemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransportSystems.
     */
    data: XOR<TransportSystemUpdateManyMutationInput, TransportSystemUncheckedUpdateManyInput>
    /**
     * Filter which TransportSystems to update
     */
    where?: TransportSystemWhereInput
  }

  /**
   * TransportSystem upsert
   */
  export type TransportSystemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    /**
     * The filter to search for the TransportSystem to update in case it exists.
     */
    where: TransportSystemWhereUniqueInput
    /**
     * In case the TransportSystem found by the `where` argument doesn't exist, create a new TransportSystem with this data.
     */
    create: XOR<TransportSystemCreateInput, TransportSystemUncheckedCreateInput>
    /**
     * In case the TransportSystem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransportSystemUpdateInput, TransportSystemUncheckedUpdateInput>
  }

  /**
   * TransportSystem delete
   */
  export type TransportSystemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    /**
     * Filter which TransportSystem to delete.
     */
    where: TransportSystemWhereUniqueInput
  }

  /**
   * TransportSystem deleteMany
   */
  export type TransportSystemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransportSystems to delete
     */
    where?: TransportSystemWhereInput
  }

  /**
   * TransportSystem.endStep
   */
  export type TransportSystem$endStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
  }

  /**
   * TransportSystem.startStep
   */
  export type TransportSystem$startStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
  }

  /**
   * TransportSystem.orders
   */
  export type TransportSystem$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * TransportSystem.filter
   */
  export type TransportSystem$filterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filter
     */
    select?: FilterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilterInclude<ExtArgs> | null
    where?: FilterWhereInput
  }

  /**
   * TransportSystem.sensors
   */
  export type TransportSystem$sensorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    where?: SensorWhereInput
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    cursor?: SensorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * TransportSystem.resources
   */
  export type TransportSystem$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * TransportSystem without action
   */
  export type TransportSystemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    priority: number | null
    quantity: number | null
    startedTick: number | null
    completedTick: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    priority: number | null
    quantity: number | null
    startedTick: number | null
    completedTick: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    priority: number | null
    dueDate: Date | null
    description: string | null
    quantity: number | null
    startedAt: Date | null
    startedTick: number | null
    completedTick: number | null
    completedAt: Date | null
    canceledAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    priority: number | null
    dueDate: Date | null
    description: string | null
    quantity: number | null
    startedAt: Date | null
    startedTick: number | null
    completedTick: number | null
    completedAt: Date | null
    canceledAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    priority: number
    dueDate: number
    description: number
    quantity: number
    startedAt: number
    startedTick: number
    completedTick: number
    completedAt: number
    canceledAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    priority?: true
    quantity?: true
    startedTick?: true
    completedTick?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    priority?: true
    quantity?: true
    startedTick?: true
    completedTick?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    priority?: true
    dueDate?: true
    description?: true
    quantity?: true
    startedAt?: true
    startedTick?: true
    completedTick?: true
    completedAt?: true
    canceledAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    priority?: true
    dueDate?: true
    description?: true
    quantity?: true
    startedAt?: true
    startedTick?: true
    completedTick?: true
    completedAt?: true
    canceledAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    priority?: true
    dueDate?: true
    description?: true
    quantity?: true
    startedAt?: true
    startedTick?: true
    completedTick?: true
    completedAt?: true
    canceledAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    status: string
    priority: number
    dueDate: Date | null
    description: string | null
    quantity: number
    startedAt: Date | null
    startedTick: number | null
    completedTick: number | null
    completedAt: Date | null
    canceledAt: Date | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    description?: boolean
    quantity?: boolean
    startedAt?: boolean
    startedTick?: boolean
    completedTick?: boolean
    completedAt?: boolean
    canceledAt?: boolean
    inventoryEntries?: boolean | Order$inventoryEntriesArgs<ExtArgs>
    processSteps?: boolean | Order$processStepsArgs<ExtArgs>
    transportSystems?: boolean | Order$transportSystemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    description?: boolean
    quantity?: boolean
    startedAt?: boolean
    startedTick?: boolean
    completedTick?: boolean
    completedAt?: boolean
    canceledAt?: boolean
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    description?: boolean
    quantity?: boolean
    startedAt?: boolean
    startedTick?: boolean
    completedTick?: boolean
    completedAt?: boolean
    canceledAt?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryEntries?: boolean | Order$inventoryEntriesArgs<ExtArgs>
    processSteps?: boolean | Order$processStepsArgs<ExtArgs>
    transportSystems?: boolean | Order$transportSystemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      inventoryEntries: Prisma.$InventoryEntryPayload<ExtArgs>[]
      processSteps: Prisma.$ProcessStepPayload<ExtArgs>[]
      transportSystems: Prisma.$TransportSystemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      status: string
      priority: number
      dueDate: Date | null
      description: string | null
      quantity: number
      startedAt: Date | null
      startedTick: number | null
      completedTick: number | null
      completedAt: Date | null
      canceledAt: Date | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryEntries<T extends Order$inventoryEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Order$inventoryEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryEntryPayload<ExtArgs>, T, "findMany"> | Null>
    processSteps<T extends Order$processStepsArgs<ExtArgs> = {}>(args?: Subset<T, Order$processStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findMany"> | Null>
    transportSystems<T extends Order$transportSystemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$transportSystemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportSystemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly status: FieldRef<"Order", 'String'>
    readonly priority: FieldRef<"Order", 'Int'>
    readonly dueDate: FieldRef<"Order", 'DateTime'>
    readonly description: FieldRef<"Order", 'String'>
    readonly quantity: FieldRef<"Order", 'Int'>
    readonly startedAt: FieldRef<"Order", 'DateTime'>
    readonly startedTick: FieldRef<"Order", 'Int'>
    readonly completedTick: FieldRef<"Order", 'Int'>
    readonly completedAt: FieldRef<"Order", 'DateTime'>
    readonly canceledAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.inventoryEntries
   */
  export type Order$inventoryEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryEntry
     */
    select?: InventoryEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryEntryInclude<ExtArgs> | null
    where?: InventoryEntryWhereInput
    orderBy?: InventoryEntryOrderByWithRelationInput | InventoryEntryOrderByWithRelationInput[]
    cursor?: InventoryEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryEntryScalarFieldEnum | InventoryEntryScalarFieldEnum[]
  }

  /**
   * Order.processSteps
   */
  export type Order$processStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    cursor?: ProcessStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * Order.transportSystems
   */
  export type Order$transportSystemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportSystem
     */
    select?: TransportSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportSystemInclude<ExtArgs> | null
    where?: TransportSystemWhereInput
    orderBy?: TransportSystemOrderByWithRelationInput | TransportSystemOrderByWithRelationInput[]
    cursor?: TransportSystemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransportSystemScalarFieldEnum | TransportSystemScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SimulationRecordScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name'
  };

  export type SimulationRecordScalarFieldEnum = (typeof SimulationRecordScalarFieldEnum)[keyof typeof SimulationRecordScalarFieldEnum]


  export const KpiRecordScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    key: 'key',
    value: 'value',
    name: 'name',
    simulationId: 'simulationId'
  };

  export type KpiRecordScalarFieldEnum = (typeof KpiRecordScalarFieldEnum)[keyof typeof KpiRecordScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    active: 'active',
    mandatory: 'mandatory',
    productionResource: 'productionResource',
    inventoryResource: 'inventoryResource',
    locationId: 'locationId',
    processStepId: 'processStepId',
    transportSystemId: 'transportSystemId',
    faulty: 'faulty',
    faultyRate: 'faultyRate'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const MachineScalarFieldEnum: {
    id: 'id',
    resourceId: 'resourceId'
  };

  export type MachineScalarFieldEnum = (typeof MachineScalarFieldEnum)[keyof typeof MachineScalarFieldEnum]


  export const WorkerScalarFieldEnum: {
    id: 'id',
    workerNumber: 'workerNumber',
    fullName: 'fullName',
    address: 'address',
    resourceId: 'resourceId'
  };

  export type WorkerScalarFieldEnum = (typeof WorkerScalarFieldEnum)[keyof typeof WorkerScalarFieldEnum]


  export const WorkerRoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type WorkerRoleScalarFieldEnum = (typeof WorkerRoleScalarFieldEnum)[keyof typeof WorkerRoleScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    type: 'type',
    limit: 'limit'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const InventoryEntryScalarFieldEnum: {
    id: 'id',
    addedAt: 'addedAt',
    material: 'material',
    inventoryId: 'inventoryId',
    orderId: 'orderId'
  };

  export type InventoryEntryScalarFieldEnum = (typeof InventoryEntryScalarFieldEnum)[keyof typeof InventoryEntryScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    description: 'description'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const ProcessStepScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    status: 'status',
    active: 'active',
    inputSpeed: 'inputSpeed',
    outputSpeed: 'outputSpeed',
    recipeRate: 'recipeRate',
    duration: 'duration',
    locationId: 'locationId',
    inventoryId: 'inventoryId',
    recipeId: 'recipeId',
    errorRate: 'errorRate'
  };

  export type ProcessStepScalarFieldEnum = (typeof ProcessStepScalarFieldEnum)[keyof typeof ProcessStepScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const RecipeInputScalarFieldEnum: {
    id: 'id',
    material: 'material',
    quantity: 'quantity',
    recipeId: 'recipeId'
  };

  export type RecipeInputScalarFieldEnum = (typeof RecipeInputScalarFieldEnum)[keyof typeof RecipeInputScalarFieldEnum]


  export const RecipeOutputScalarFieldEnum: {
    id: 'id',
    material: 'material',
    quantity: 'quantity',
    recipeId: 'recipeId'
  };

  export type RecipeOutputScalarFieldEnum = (typeof RecipeOutputScalarFieldEnum)[keyof typeof RecipeOutputScalarFieldEnum]


  export const LogEntryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    inputType: 'inputType',
    sensorId: 'sensorId',
    materialId: 'materialId',
    materialName: 'materialName',
    processStepId: 'processStepId',
    transportSystemId: 'transportSystemId'
  };

  export type LogEntryScalarFieldEnum = (typeof LogEntryScalarFieldEnum)[keyof typeof LogEntryScalarFieldEnum]


  export const SensorScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    type: 'type',
    value: 'value',
    sensorDelay: 'sensorDelay',
    active: 'active',
    processStepId: 'processStepId',
    transportSystemId: 'transportSystemId'
  };

  export type SensorScalarFieldEnum = (typeof SensorScalarFieldEnum)[keyof typeof SensorScalarFieldEnum]


  export const FilterEntryScalarFieldEnum: {
    id: 'id',
    addedAt: 'addedAt',
    material: 'material',
    filterId: 'filterId'
  };

  export type FilterEntryScalarFieldEnum = (typeof FilterEntryScalarFieldEnum)[keyof typeof FilterEntryScalarFieldEnum]


  export const FilterScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    transportSystemId: 'transportSystemId',
    orderId: 'orderId'
  };

  export type FilterScalarFieldEnum = (typeof FilterScalarFieldEnum)[keyof typeof FilterScalarFieldEnum]


  export const TransportSystemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    active: 'active',
    name: 'name',
    inputSpeed: 'inputSpeed',
    outputSpeed: 'outputSpeed',
    inventoryId: 'inventoryId',
    minQuantity: 'minQuantity',
    transportDelay: 'transportDelay',
    startStepId: 'startStepId',
    endStepId: 'endStepId',
    type: 'type',
    startTSId: 'startTSId',
    endTSId: 'endTSId'
  };

  export type TransportSystemScalarFieldEnum = (typeof TransportSystemScalarFieldEnum)[keyof typeof TransportSystemScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    description: 'description',
    quantity: 'quantity',
    startedAt: 'startedAt',
    startedTick: 'startedTick',
    completedTick: 'completedTick',
    completedAt: 'completedAt',
    canceledAt: 'canceledAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type SimulationRecordWhereInput = {
    AND?: SimulationRecordWhereInput | SimulationRecordWhereInput[]
    OR?: SimulationRecordWhereInput[]
    NOT?: SimulationRecordWhereInput | SimulationRecordWhereInput[]
    id?: IntFilter<"SimulationRecord"> | number
    createdAt?: DateTimeFilter<"SimulationRecord"> | Date | string
    updatedAt?: DateTimeFilter<"SimulationRecord"> | Date | string
    name?: StringFilter<"SimulationRecord"> | string
    kpis?: KpiRecordListRelationFilter
  }

  export type SimulationRecordOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    kpis?: KpiRecordOrderByRelationAggregateInput
  }

  export type SimulationRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SimulationRecordWhereInput | SimulationRecordWhereInput[]
    OR?: SimulationRecordWhereInput[]
    NOT?: SimulationRecordWhereInput | SimulationRecordWhereInput[]
    createdAt?: DateTimeFilter<"SimulationRecord"> | Date | string
    updatedAt?: DateTimeFilter<"SimulationRecord"> | Date | string
    name?: StringFilter<"SimulationRecord"> | string
    kpis?: KpiRecordListRelationFilter
  }, "id">

  export type SimulationRecordOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    _count?: SimulationRecordCountOrderByAggregateInput
    _avg?: SimulationRecordAvgOrderByAggregateInput
    _max?: SimulationRecordMaxOrderByAggregateInput
    _min?: SimulationRecordMinOrderByAggregateInput
    _sum?: SimulationRecordSumOrderByAggregateInput
  }

  export type SimulationRecordScalarWhereWithAggregatesInput = {
    AND?: SimulationRecordScalarWhereWithAggregatesInput | SimulationRecordScalarWhereWithAggregatesInput[]
    OR?: SimulationRecordScalarWhereWithAggregatesInput[]
    NOT?: SimulationRecordScalarWhereWithAggregatesInput | SimulationRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SimulationRecord"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SimulationRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SimulationRecord"> | Date | string
    name?: StringWithAggregatesFilter<"SimulationRecord"> | string
  }

  export type KpiRecordWhereInput = {
    AND?: KpiRecordWhereInput | KpiRecordWhereInput[]
    OR?: KpiRecordWhereInput[]
    NOT?: KpiRecordWhereInput | KpiRecordWhereInput[]
    id?: IntFilter<"KpiRecord"> | number
    createdAt?: DateTimeFilter<"KpiRecord"> | Date | string
    updatedAt?: DateTimeFilter<"KpiRecord"> | Date | string
    key?: StringFilter<"KpiRecord"> | string
    value?: FloatFilter<"KpiRecord"> | number
    name?: StringNullableFilter<"KpiRecord"> | string | null
    simulationId?: IntFilter<"KpiRecord"> | number
    simulation?: XOR<SimulationRecordRelationFilter, SimulationRecordWhereInput>
  }

  export type KpiRecordOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    value?: SortOrder
    name?: SortOrderInput | SortOrder
    simulationId?: SortOrder
    simulation?: SimulationRecordOrderByWithRelationInput
  }

  export type KpiRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KpiRecordWhereInput | KpiRecordWhereInput[]
    OR?: KpiRecordWhereInput[]
    NOT?: KpiRecordWhereInput | KpiRecordWhereInput[]
    createdAt?: DateTimeFilter<"KpiRecord"> | Date | string
    updatedAt?: DateTimeFilter<"KpiRecord"> | Date | string
    key?: StringFilter<"KpiRecord"> | string
    value?: FloatFilter<"KpiRecord"> | number
    name?: StringNullableFilter<"KpiRecord"> | string | null
    simulationId?: IntFilter<"KpiRecord"> | number
    simulation?: XOR<SimulationRecordRelationFilter, SimulationRecordWhereInput>
  }, "id">

  export type KpiRecordOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    value?: SortOrder
    name?: SortOrderInput | SortOrder
    simulationId?: SortOrder
    _count?: KpiRecordCountOrderByAggregateInput
    _avg?: KpiRecordAvgOrderByAggregateInput
    _max?: KpiRecordMaxOrderByAggregateInput
    _min?: KpiRecordMinOrderByAggregateInput
    _sum?: KpiRecordSumOrderByAggregateInput
  }

  export type KpiRecordScalarWhereWithAggregatesInput = {
    AND?: KpiRecordScalarWhereWithAggregatesInput | KpiRecordScalarWhereWithAggregatesInput[]
    OR?: KpiRecordScalarWhereWithAggregatesInput[]
    NOT?: KpiRecordScalarWhereWithAggregatesInput | KpiRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KpiRecord"> | number
    createdAt?: DateTimeWithAggregatesFilter<"KpiRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KpiRecord"> | Date | string
    key?: StringWithAggregatesFilter<"KpiRecord"> | string
    value?: FloatWithAggregatesFilter<"KpiRecord"> | number
    name?: StringNullableWithAggregatesFilter<"KpiRecord"> | string | null
    simulationId?: IntWithAggregatesFilter<"KpiRecord"> | number
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: IntFilter<"Resource"> | number
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    name?: StringNullableFilter<"Resource"> | string | null
    active?: BoolFilter<"Resource"> | boolean
    mandatory?: BoolFilter<"Resource"> | boolean
    productionResource?: BoolFilter<"Resource"> | boolean
    inventoryResource?: BoolFilter<"Resource"> | boolean
    locationId?: IntFilter<"Resource"> | number
    processStepId?: IntNullableFilter<"Resource"> | number | null
    transportSystemId?: IntNullableFilter<"Resource"> | number | null
    faulty?: BoolNullableFilter<"Resource"> | boolean | null
    faultyRate?: FloatFilter<"Resource"> | number
    Machine?: XOR<MachineNullableRelationFilter, MachineWhereInput> | null
    processStep?: XOR<ProcessStepNullableRelationFilter, ProcessStepWhereInput> | null
    transportSystem?: XOR<TransportSystemNullableRelationFilter, TransportSystemWhereInput> | null
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    Worker?: XOR<WorkerNullableRelationFilter, WorkerWhereInput> | null
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrderInput | SortOrder
    active?: SortOrder
    mandatory?: SortOrder
    productionResource?: SortOrder
    inventoryResource?: SortOrder
    locationId?: SortOrder
    processStepId?: SortOrderInput | SortOrder
    transportSystemId?: SortOrderInput | SortOrder
    faulty?: SortOrderInput | SortOrder
    faultyRate?: SortOrder
    Machine?: MachineOrderByWithRelationInput
    processStep?: ProcessStepOrderByWithRelationInput
    transportSystem?: TransportSystemOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    Worker?: WorkerOrderByWithRelationInput
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    name?: StringNullableFilter<"Resource"> | string | null
    active?: BoolFilter<"Resource"> | boolean
    mandatory?: BoolFilter<"Resource"> | boolean
    productionResource?: BoolFilter<"Resource"> | boolean
    inventoryResource?: BoolFilter<"Resource"> | boolean
    locationId?: IntFilter<"Resource"> | number
    processStepId?: IntNullableFilter<"Resource"> | number | null
    transportSystemId?: IntNullableFilter<"Resource"> | number | null
    faulty?: BoolNullableFilter<"Resource"> | boolean | null
    faultyRate?: FloatFilter<"Resource"> | number
    Machine?: XOR<MachineNullableRelationFilter, MachineWhereInput> | null
    processStep?: XOR<ProcessStepNullableRelationFilter, ProcessStepWhereInput> | null
    transportSystem?: XOR<TransportSystemNullableRelationFilter, TransportSystemWhereInput> | null
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    Worker?: XOR<WorkerNullableRelationFilter, WorkerWhereInput> | null
  }, "id">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrderInput | SortOrder
    active?: SortOrder
    mandatory?: SortOrder
    productionResource?: SortOrder
    inventoryResource?: SortOrder
    locationId?: SortOrder
    processStepId?: SortOrderInput | SortOrder
    transportSystemId?: SortOrderInput | SortOrder
    faulty?: SortOrderInput | SortOrder
    faultyRate?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _avg?: ResourceAvgOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
    _sum?: ResourceSumOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Resource"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    name?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    active?: BoolWithAggregatesFilter<"Resource"> | boolean
    mandatory?: BoolWithAggregatesFilter<"Resource"> | boolean
    productionResource?: BoolWithAggregatesFilter<"Resource"> | boolean
    inventoryResource?: BoolWithAggregatesFilter<"Resource"> | boolean
    locationId?: IntWithAggregatesFilter<"Resource"> | number
    processStepId?: IntNullableWithAggregatesFilter<"Resource"> | number | null
    transportSystemId?: IntNullableWithAggregatesFilter<"Resource"> | number | null
    faulty?: BoolNullableWithAggregatesFilter<"Resource"> | boolean | null
    faultyRate?: FloatWithAggregatesFilter<"Resource"> | number
  }

  export type MachineWhereInput = {
    AND?: MachineWhereInput | MachineWhereInput[]
    OR?: MachineWhereInput[]
    NOT?: MachineWhereInput | MachineWhereInput[]
    id?: IntFilter<"Machine"> | number
    resourceId?: IntFilter<"Machine"> | number
    resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
  }

  export type MachineOrderByWithRelationInput = {
    id?: SortOrder
    resourceId?: SortOrder
    resource?: ResourceOrderByWithRelationInput
  }

  export type MachineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    resourceId?: number
    AND?: MachineWhereInput | MachineWhereInput[]
    OR?: MachineWhereInput[]
    NOT?: MachineWhereInput | MachineWhereInput[]
    resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
  }, "id" | "resourceId">

  export type MachineOrderByWithAggregationInput = {
    id?: SortOrder
    resourceId?: SortOrder
    _count?: MachineCountOrderByAggregateInput
    _avg?: MachineAvgOrderByAggregateInput
    _max?: MachineMaxOrderByAggregateInput
    _min?: MachineMinOrderByAggregateInput
    _sum?: MachineSumOrderByAggregateInput
  }

  export type MachineScalarWhereWithAggregatesInput = {
    AND?: MachineScalarWhereWithAggregatesInput | MachineScalarWhereWithAggregatesInput[]
    OR?: MachineScalarWhereWithAggregatesInput[]
    NOT?: MachineScalarWhereWithAggregatesInput | MachineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Machine"> | number
    resourceId?: IntWithAggregatesFilter<"Machine"> | number
  }

  export type WorkerWhereInput = {
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    id?: IntFilter<"Worker"> | number
    workerNumber?: StringFilter<"Worker"> | string
    fullName?: StringFilter<"Worker"> | string
    address?: StringFilter<"Worker"> | string
    resourceId?: IntFilter<"Worker"> | number
    resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
    workerRoles?: WorkerRoleListRelationFilter
  }

  export type WorkerOrderByWithRelationInput = {
    id?: SortOrder
    workerNumber?: SortOrder
    fullName?: SortOrder
    address?: SortOrder
    resourceId?: SortOrder
    resource?: ResourceOrderByWithRelationInput
    workerRoles?: WorkerRoleOrderByRelationAggregateInput
  }

  export type WorkerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    resourceId?: number
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    workerNumber?: StringFilter<"Worker"> | string
    fullName?: StringFilter<"Worker"> | string
    address?: StringFilter<"Worker"> | string
    resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
    workerRoles?: WorkerRoleListRelationFilter
  }, "id" | "resourceId">

  export type WorkerOrderByWithAggregationInput = {
    id?: SortOrder
    workerNumber?: SortOrder
    fullName?: SortOrder
    address?: SortOrder
    resourceId?: SortOrder
    _count?: WorkerCountOrderByAggregateInput
    _avg?: WorkerAvgOrderByAggregateInput
    _max?: WorkerMaxOrderByAggregateInput
    _min?: WorkerMinOrderByAggregateInput
    _sum?: WorkerSumOrderByAggregateInput
  }

  export type WorkerScalarWhereWithAggregatesInput = {
    AND?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    OR?: WorkerScalarWhereWithAggregatesInput[]
    NOT?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Worker"> | number
    workerNumber?: StringWithAggregatesFilter<"Worker"> | string
    fullName?: StringWithAggregatesFilter<"Worker"> | string
    address?: StringWithAggregatesFilter<"Worker"> | string
    resourceId?: IntWithAggregatesFilter<"Worker"> | number
  }

  export type WorkerRoleWhereInput = {
    AND?: WorkerRoleWhereInput | WorkerRoleWhereInput[]
    OR?: WorkerRoleWhereInput[]
    NOT?: WorkerRoleWhereInput | WorkerRoleWhereInput[]
    id?: IntFilter<"WorkerRole"> | number
    name?: StringFilter<"WorkerRole"> | string
    description?: StringNullableFilter<"WorkerRole"> | string | null
    workers?: WorkerListRelationFilter
  }

  export type WorkerRoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    workers?: WorkerOrderByRelationAggregateInput
  }

  export type WorkerRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: WorkerRoleWhereInput | WorkerRoleWhereInput[]
    OR?: WorkerRoleWhereInput[]
    NOT?: WorkerRoleWhereInput | WorkerRoleWhereInput[]
    description?: StringNullableFilter<"WorkerRole"> | string | null
    workers?: WorkerListRelationFilter
  }, "id" | "name">

  export type WorkerRoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: WorkerRoleCountOrderByAggregateInput
    _avg?: WorkerRoleAvgOrderByAggregateInput
    _max?: WorkerRoleMaxOrderByAggregateInput
    _min?: WorkerRoleMinOrderByAggregateInput
    _sum?: WorkerRoleSumOrderByAggregateInput
  }

  export type WorkerRoleScalarWhereWithAggregatesInput = {
    AND?: WorkerRoleScalarWhereWithAggregatesInput | WorkerRoleScalarWhereWithAggregatesInput[]
    OR?: WorkerRoleScalarWhereWithAggregatesInput[]
    NOT?: WorkerRoleScalarWhereWithAggregatesInput | WorkerRoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkerRole"> | number
    name?: StringWithAggregatesFilter<"WorkerRole"> | string
    description?: StringNullableWithAggregatesFilter<"WorkerRole"> | string | null
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: IntFilter<"Inventory"> | number
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    type?: StringFilter<"Inventory"> | string
    limit?: IntFilter<"Inventory"> | number
    entries?: InventoryEntryListRelationFilter
    processStep?: XOR<ProcessStepNullableRelationFilter, ProcessStepWhereInput> | null
    transportSystem?: XOR<TransportSystemNullableRelationFilter, TransportSystemWhereInput> | null
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    limit?: SortOrder
    entries?: InventoryEntryOrderByRelationAggregateInput
    processStep?: ProcessStepOrderByWithRelationInput
    transportSystem?: TransportSystemOrderByWithRelationInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    type?: StringFilter<"Inventory"> | string
    limit?: IntFilter<"Inventory"> | number
    entries?: InventoryEntryListRelationFilter
    processStep?: XOR<ProcessStepNullableRelationFilter, ProcessStepWhereInput> | null
    transportSystem?: XOR<TransportSystemNullableRelationFilter, TransportSystemWhereInput> | null
  }, "id">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    limit?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inventory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    type?: StringWithAggregatesFilter<"Inventory"> | string
    limit?: IntWithAggregatesFilter<"Inventory"> | number
  }

  export type InventoryEntryWhereInput = {
    AND?: InventoryEntryWhereInput | InventoryEntryWhereInput[]
    OR?: InventoryEntryWhereInput[]
    NOT?: InventoryEntryWhereInput | InventoryEntryWhereInput[]
    id?: IntFilter<"InventoryEntry"> | number
    addedAt?: DateTimeFilter<"InventoryEntry"> | Date | string
    material?: StringFilter<"InventoryEntry"> | string
    inventoryId?: IntFilter<"InventoryEntry"> | number
    orderId?: IntNullableFilter<"InventoryEntry"> | number | null
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
    Order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
  }

  export type InventoryEntryOrderByWithRelationInput = {
    id?: SortOrder
    addedAt?: SortOrder
    material?: SortOrder
    inventoryId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    inventory?: InventoryOrderByWithRelationInput
    Order?: OrderOrderByWithRelationInput
  }

  export type InventoryEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InventoryEntryWhereInput | InventoryEntryWhereInput[]
    OR?: InventoryEntryWhereInput[]
    NOT?: InventoryEntryWhereInput | InventoryEntryWhereInput[]
    addedAt?: DateTimeFilter<"InventoryEntry"> | Date | string
    material?: StringFilter<"InventoryEntry"> | string
    inventoryId?: IntFilter<"InventoryEntry"> | number
    orderId?: IntNullableFilter<"InventoryEntry"> | number | null
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
    Order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
  }, "id">

  export type InventoryEntryOrderByWithAggregationInput = {
    id?: SortOrder
    addedAt?: SortOrder
    material?: SortOrder
    inventoryId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    _count?: InventoryEntryCountOrderByAggregateInput
    _avg?: InventoryEntryAvgOrderByAggregateInput
    _max?: InventoryEntryMaxOrderByAggregateInput
    _min?: InventoryEntryMinOrderByAggregateInput
    _sum?: InventoryEntrySumOrderByAggregateInput
  }

  export type InventoryEntryScalarWhereWithAggregatesInput = {
    AND?: InventoryEntryScalarWhereWithAggregatesInput | InventoryEntryScalarWhereWithAggregatesInput[]
    OR?: InventoryEntryScalarWhereWithAggregatesInput[]
    NOT?: InventoryEntryScalarWhereWithAggregatesInput | InventoryEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InventoryEntry"> | number
    addedAt?: DateTimeWithAggregatesFilter<"InventoryEntry"> | Date | string
    material?: StringWithAggregatesFilter<"InventoryEntry"> | string
    inventoryId?: IntWithAggregatesFilter<"InventoryEntry"> | number
    orderId?: IntNullableWithAggregatesFilter<"InventoryEntry"> | number | null
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: IntFilter<"Location"> | number
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    name?: StringFilter<"Location"> | string
    description?: StringNullableFilter<"Location"> | string | null
    processSteps?: ProcessStepListRelationFilter
    resources?: ResourceListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    processSteps?: ProcessStepOrderByRelationAggregateInput
    resources?: ResourceOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    name?: StringFilter<"Location"> | string
    description?: StringNullableFilter<"Location"> | string | null
    processSteps?: ProcessStepListRelationFilter
    resources?: ResourceListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Location"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    name?: StringWithAggregatesFilter<"Location"> | string
    description?: StringNullableWithAggregatesFilter<"Location"> | string | null
  }

  export type ProcessStepWhereInput = {
    AND?: ProcessStepWhereInput | ProcessStepWhereInput[]
    OR?: ProcessStepWhereInput[]
    NOT?: ProcessStepWhereInput | ProcessStepWhereInput[]
    id?: IntFilter<"ProcessStep"> | number
    createdAt?: DateTimeFilter<"ProcessStep"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessStep"> | Date | string
    name?: StringFilter<"ProcessStep"> | string
    status?: StringFilter<"ProcessStep"> | string
    active?: BoolFilter<"ProcessStep"> | boolean
    inputSpeed?: IntFilter<"ProcessStep"> | number
    outputSpeed?: IntFilter<"ProcessStep"> | number
    recipeRate?: IntFilter<"ProcessStep"> | number
    duration?: IntFilter<"ProcessStep"> | number
    locationId?: IntFilter<"ProcessStep"> | number
    inventoryId?: IntFilter<"ProcessStep"> | number
    recipeId?: IntNullableFilter<"ProcessStep"> | number | null
    errorRate?: FloatNullableFilter<"ProcessStep"> | number | null
    orders?: OrderListRelationFilter
    recipe?: XOR<RecipeNullableRelationFilter, RecipeWhereInput> | null
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    resources?: ResourceListRelationFilter
    sensors?: SensorListRelationFilter
    inputs?: TransportSystemListRelationFilter
    outputs?: TransportSystemListRelationFilter
  }

  export type ProcessStepOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    active?: SortOrder
    inputSpeed?: SortOrder
    outputSpeed?: SortOrder
    recipeRate?: SortOrder
    duration?: SortOrder
    locationId?: SortOrder
    inventoryId?: SortOrder
    recipeId?: SortOrderInput | SortOrder
    errorRate?: SortOrderInput | SortOrder
    orders?: OrderOrderByRelationAggregateInput
    recipe?: RecipeOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    resources?: ResourceOrderByRelationAggregateInput
    sensors?: SensorOrderByRelationAggregateInput
    inputs?: TransportSystemOrderByRelationAggregateInput
    outputs?: TransportSystemOrderByRelationAggregateInput
  }

  export type ProcessStepWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    inventoryId?: number
    AND?: ProcessStepWhereInput | ProcessStepWhereInput[]
    OR?: ProcessStepWhereInput[]
    NOT?: ProcessStepWhereInput | ProcessStepWhereInput[]
    createdAt?: DateTimeFilter<"ProcessStep"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessStep"> | Date | string
    name?: StringFilter<"ProcessStep"> | string
    status?: StringFilter<"ProcessStep"> | string
    active?: BoolFilter<"ProcessStep"> | boolean
    inputSpeed?: IntFilter<"ProcessStep"> | number
    outputSpeed?: IntFilter<"ProcessStep"> | number
    recipeRate?: IntFilter<"ProcessStep"> | number
    duration?: IntFilter<"ProcessStep"> | number
    locationId?: IntFilter<"ProcessStep"> | number
    recipeId?: IntNullableFilter<"ProcessStep"> | number | null
    errorRate?: FloatNullableFilter<"ProcessStep"> | number | null
    orders?: OrderListRelationFilter
    recipe?: XOR<RecipeNullableRelationFilter, RecipeWhereInput> | null
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    resources?: ResourceListRelationFilter
    sensors?: SensorListRelationFilter
    inputs?: TransportSystemListRelationFilter
    outputs?: TransportSystemListRelationFilter
  }, "id" | "inventoryId">

  export type ProcessStepOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    active?: SortOrder
    inputSpeed?: SortOrder
    outputSpeed?: SortOrder
    recipeRate?: SortOrder
    duration?: SortOrder
    locationId?: SortOrder
    inventoryId?: SortOrder
    recipeId?: SortOrderInput | SortOrder
    errorRate?: SortOrderInput | SortOrder
    _count?: ProcessStepCountOrderByAggregateInput
    _avg?: ProcessStepAvgOrderByAggregateInput
    _max?: ProcessStepMaxOrderByAggregateInput
    _min?: ProcessStepMinOrderByAggregateInput
    _sum?: ProcessStepSumOrderByAggregateInput
  }

  export type ProcessStepScalarWhereWithAggregatesInput = {
    AND?: ProcessStepScalarWhereWithAggregatesInput | ProcessStepScalarWhereWithAggregatesInput[]
    OR?: ProcessStepScalarWhereWithAggregatesInput[]
    NOT?: ProcessStepScalarWhereWithAggregatesInput | ProcessStepScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProcessStep"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProcessStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProcessStep"> | Date | string
    name?: StringWithAggregatesFilter<"ProcessStep"> | string
    status?: StringWithAggregatesFilter<"ProcessStep"> | string
    active?: BoolWithAggregatesFilter<"ProcessStep"> | boolean
    inputSpeed?: IntWithAggregatesFilter<"ProcessStep"> | number
    outputSpeed?: IntWithAggregatesFilter<"ProcessStep"> | number
    recipeRate?: IntWithAggregatesFilter<"ProcessStep"> | number
    duration?: IntWithAggregatesFilter<"ProcessStep"> | number
    locationId?: IntWithAggregatesFilter<"ProcessStep"> | number
    inventoryId?: IntWithAggregatesFilter<"ProcessStep"> | number
    recipeId?: IntNullableWithAggregatesFilter<"ProcessStep"> | number | null
    errorRate?: FloatNullableWithAggregatesFilter<"ProcessStep"> | number | null
  }

  export type RecipeWhereInput = {
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    id?: IntFilter<"Recipe"> | number
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeFilter<"Recipe"> | Date | string
    name?: StringFilter<"Recipe"> | string
    processSteps?: ProcessStepListRelationFilter
    inputs?: RecipeInputListRelationFilter
    outputs?: RecipeOutputListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    processSteps?: ProcessStepOrderByRelationAggregateInput
    inputs?: RecipeInputOrderByRelationAggregateInput
    outputs?: RecipeOutputOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeFilter<"Recipe"> | Date | string
    name?: StringFilter<"Recipe"> | string
    processSteps?: ProcessStepListRelationFilter
    inputs?: RecipeInputListRelationFilter
    outputs?: RecipeOutputListRelationFilter
  }, "id">

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _avg?: RecipeAvgOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
    _sum?: RecipeSumOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    OR?: RecipeScalarWhereWithAggregatesInput[]
    NOT?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Recipe"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
    name?: StringWithAggregatesFilter<"Recipe"> | string
  }

  export type RecipeInputWhereInput = {
    AND?: RecipeInputWhereInput | RecipeInputWhereInput[]
    OR?: RecipeInputWhereInput[]
    NOT?: RecipeInputWhereInput | RecipeInputWhereInput[]
    id?: IntFilter<"RecipeInput"> | number
    material?: StringFilter<"RecipeInput"> | string
    quantity?: IntFilter<"RecipeInput"> | number
    recipeId?: IntNullableFilter<"RecipeInput"> | number | null
    Recipe?: XOR<RecipeNullableRelationFilter, RecipeWhereInput> | null
  }

  export type RecipeInputOrderByWithRelationInput = {
    id?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    recipeId?: SortOrderInput | SortOrder
    Recipe?: RecipeOrderByWithRelationInput
  }

  export type RecipeInputWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    material_recipeId?: RecipeInputMaterialRecipeIdCompoundUniqueInput
    AND?: RecipeInputWhereInput | RecipeInputWhereInput[]
    OR?: RecipeInputWhereInput[]
    NOT?: RecipeInputWhereInput | RecipeInputWhereInput[]
    material?: StringFilter<"RecipeInput"> | string
    quantity?: IntFilter<"RecipeInput"> | number
    recipeId?: IntNullableFilter<"RecipeInput"> | number | null
    Recipe?: XOR<RecipeNullableRelationFilter, RecipeWhereInput> | null
  }, "id" | "material_recipeId">

  export type RecipeInputOrderByWithAggregationInput = {
    id?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    recipeId?: SortOrderInput | SortOrder
    _count?: RecipeInputCountOrderByAggregateInput
    _avg?: RecipeInputAvgOrderByAggregateInput
    _max?: RecipeInputMaxOrderByAggregateInput
    _min?: RecipeInputMinOrderByAggregateInput
    _sum?: RecipeInputSumOrderByAggregateInput
  }

  export type RecipeInputScalarWhereWithAggregatesInput = {
    AND?: RecipeInputScalarWhereWithAggregatesInput | RecipeInputScalarWhereWithAggregatesInput[]
    OR?: RecipeInputScalarWhereWithAggregatesInput[]
    NOT?: RecipeInputScalarWhereWithAggregatesInput | RecipeInputScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RecipeInput"> | number
    material?: StringWithAggregatesFilter<"RecipeInput"> | string
    quantity?: IntWithAggregatesFilter<"RecipeInput"> | number
    recipeId?: IntNullableWithAggregatesFilter<"RecipeInput"> | number | null
  }

  export type RecipeOutputWhereInput = {
    AND?: RecipeOutputWhereInput | RecipeOutputWhereInput[]
    OR?: RecipeOutputWhereInput[]
    NOT?: RecipeOutputWhereInput | RecipeOutputWhereInput[]
    id?: IntFilter<"RecipeOutput"> | number
    material?: StringFilter<"RecipeOutput"> | string
    quantity?: IntFilter<"RecipeOutput"> | number
    recipeId?: IntNullableFilter<"RecipeOutput"> | number | null
    Recipe?: XOR<RecipeNullableRelationFilter, RecipeWhereInput> | null
  }

  export type RecipeOutputOrderByWithRelationInput = {
    id?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    recipeId?: SortOrderInput | SortOrder
    Recipe?: RecipeOrderByWithRelationInput
  }

  export type RecipeOutputWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RecipeOutputWhereInput | RecipeOutputWhereInput[]
    OR?: RecipeOutputWhereInput[]
    NOT?: RecipeOutputWhereInput | RecipeOutputWhereInput[]
    material?: StringFilter<"RecipeOutput"> | string
    quantity?: IntFilter<"RecipeOutput"> | number
    recipeId?: IntNullableFilter<"RecipeOutput"> | number | null
    Recipe?: XOR<RecipeNullableRelationFilter, RecipeWhereInput> | null
  }, "id">

  export type RecipeOutputOrderByWithAggregationInput = {
    id?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    recipeId?: SortOrderInput | SortOrder
    _count?: RecipeOutputCountOrderByAggregateInput
    _avg?: RecipeOutputAvgOrderByAggregateInput
    _max?: RecipeOutputMaxOrderByAggregateInput
    _min?: RecipeOutputMinOrderByAggregateInput
    _sum?: RecipeOutputSumOrderByAggregateInput
  }

  export type RecipeOutputScalarWhereWithAggregatesInput = {
    AND?: RecipeOutputScalarWhereWithAggregatesInput | RecipeOutputScalarWhereWithAggregatesInput[]
    OR?: RecipeOutputScalarWhereWithAggregatesInput[]
    NOT?: RecipeOutputScalarWhereWithAggregatesInput | RecipeOutputScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RecipeOutput"> | number
    material?: StringWithAggregatesFilter<"RecipeOutput"> | string
    quantity?: IntWithAggregatesFilter<"RecipeOutput"> | number
    recipeId?: IntNullableWithAggregatesFilter<"RecipeOutput"> | number | null
  }

  export type LogEntryWhereInput = {
    AND?: LogEntryWhereInput | LogEntryWhereInput[]
    OR?: LogEntryWhereInput[]
    NOT?: LogEntryWhereInput | LogEntryWhereInput[]
    id?: IntFilter<"LogEntry"> | number
    createdAt?: DateTimeFilter<"LogEntry"> | Date | string
    inputType?: StringFilter<"LogEntry"> | string
    sensorId?: IntNullableFilter<"LogEntry"> | number | null
    materialId?: IntFilter<"LogEntry"> | number
    materialName?: StringFilter<"LogEntry"> | string
    processStepId?: IntNullableFilter<"LogEntry"> | number | null
    transportSystemId?: IntNullableFilter<"LogEntry"> | number | null
    sensor?: XOR<SensorNullableRelationFilter, SensorWhereInput> | null
  }

  export type LogEntryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    inputType?: SortOrder
    sensorId?: SortOrderInput | SortOrder
    materialId?: SortOrder
    materialName?: SortOrder
    processStepId?: SortOrderInput | SortOrder
    transportSystemId?: SortOrderInput | SortOrder
    sensor?: SensorOrderByWithRelationInput
  }

  export type LogEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogEntryWhereInput | LogEntryWhereInput[]
    OR?: LogEntryWhereInput[]
    NOT?: LogEntryWhereInput | LogEntryWhereInput[]
    createdAt?: DateTimeFilter<"LogEntry"> | Date | string
    inputType?: StringFilter<"LogEntry"> | string
    sensorId?: IntNullableFilter<"LogEntry"> | number | null
    materialId?: IntFilter<"LogEntry"> | number
    materialName?: StringFilter<"LogEntry"> | string
    processStepId?: IntNullableFilter<"LogEntry"> | number | null
    transportSystemId?: IntNullableFilter<"LogEntry"> | number | null
    sensor?: XOR<SensorNullableRelationFilter, SensorWhereInput> | null
  }, "id">

  export type LogEntryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    inputType?: SortOrder
    sensorId?: SortOrderInput | SortOrder
    materialId?: SortOrder
    materialName?: SortOrder
    processStepId?: SortOrderInput | SortOrder
    transportSystemId?: SortOrderInput | SortOrder
    _count?: LogEntryCountOrderByAggregateInput
    _avg?: LogEntryAvgOrderByAggregateInput
    _max?: LogEntryMaxOrderByAggregateInput
    _min?: LogEntryMinOrderByAggregateInput
    _sum?: LogEntrySumOrderByAggregateInput
  }

  export type LogEntryScalarWhereWithAggregatesInput = {
    AND?: LogEntryScalarWhereWithAggregatesInput | LogEntryScalarWhereWithAggregatesInput[]
    OR?: LogEntryScalarWhereWithAggregatesInput[]
    NOT?: LogEntryScalarWhereWithAggregatesInput | LogEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogEntry"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LogEntry"> | Date | string
    inputType?: StringWithAggregatesFilter<"LogEntry"> | string
    sensorId?: IntNullableWithAggregatesFilter<"LogEntry"> | number | null
    materialId?: IntWithAggregatesFilter<"LogEntry"> | number
    materialName?: StringWithAggregatesFilter<"LogEntry"> | string
    processStepId?: IntNullableWithAggregatesFilter<"LogEntry"> | number | null
    transportSystemId?: IntNullableWithAggregatesFilter<"LogEntry"> | number | null
  }

  export type SensorWhereInput = {
    AND?: SensorWhereInput | SensorWhereInput[]
    OR?: SensorWhereInput[]
    NOT?: SensorWhereInput | SensorWhereInput[]
    id?: IntFilter<"Sensor"> | number
    createdAt?: DateTimeFilter<"Sensor"> | Date | string
    updatedAt?: DateTimeFilter<"Sensor"> | Date | string
    name?: StringFilter<"Sensor"> | string
    type?: StringFilter<"Sensor"> | string
    value?: IntFilter<"Sensor"> | number
    sensorDelay?: IntFilter<"Sensor"> | number
    active?: BoolFilter<"Sensor"> | boolean
    processStepId?: IntNullableFilter<"Sensor"> | number | null
    transportSystemId?: IntNullableFilter<"Sensor"> | number | null
    processStep?: XOR<ProcessStepNullableRelationFilter, ProcessStepWhereInput> | null
    transportSystem?: XOR<TransportSystemNullableRelationFilter, TransportSystemWhereInput> | null
    logEntries?: LogEntryListRelationFilter
  }

  export type SensorOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    sensorDelay?: SortOrder
    active?: SortOrder
    processStepId?: SortOrderInput | SortOrder
    transportSystemId?: SortOrderInput | SortOrder
    processStep?: ProcessStepOrderByWithRelationInput
    transportSystem?: TransportSystemOrderByWithRelationInput
    logEntries?: LogEntryOrderByRelationAggregateInput
  }

  export type SensorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SensorWhereInput | SensorWhereInput[]
    OR?: SensorWhereInput[]
    NOT?: SensorWhereInput | SensorWhereInput[]
    createdAt?: DateTimeFilter<"Sensor"> | Date | string
    updatedAt?: DateTimeFilter<"Sensor"> | Date | string
    name?: StringFilter<"Sensor"> | string
    type?: StringFilter<"Sensor"> | string
    value?: IntFilter<"Sensor"> | number
    sensorDelay?: IntFilter<"Sensor"> | number
    active?: BoolFilter<"Sensor"> | boolean
    processStepId?: IntNullableFilter<"Sensor"> | number | null
    transportSystemId?: IntNullableFilter<"Sensor"> | number | null
    processStep?: XOR<ProcessStepNullableRelationFilter, ProcessStepWhereInput> | null
    transportSystem?: XOR<TransportSystemNullableRelationFilter, TransportSystemWhereInput> | null
    logEntries?: LogEntryListRelationFilter
  }, "id">

  export type SensorOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    sensorDelay?: SortOrder
    active?: SortOrder
    processStepId?: SortOrderInput | SortOrder
    transportSystemId?: SortOrderInput | SortOrder
    _count?: SensorCountOrderByAggregateInput
    _avg?: SensorAvgOrderByAggregateInput
    _max?: SensorMaxOrderByAggregateInput
    _min?: SensorMinOrderByAggregateInput
    _sum?: SensorSumOrderByAggregateInput
  }

  export type SensorScalarWhereWithAggregatesInput = {
    AND?: SensorScalarWhereWithAggregatesInput | SensorScalarWhereWithAggregatesInput[]
    OR?: SensorScalarWhereWithAggregatesInput[]
    NOT?: SensorScalarWhereWithAggregatesInput | SensorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sensor"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Sensor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sensor"> | Date | string
    name?: StringWithAggregatesFilter<"Sensor"> | string
    type?: StringWithAggregatesFilter<"Sensor"> | string
    value?: IntWithAggregatesFilter<"Sensor"> | number
    sensorDelay?: IntWithAggregatesFilter<"Sensor"> | number
    active?: BoolWithAggregatesFilter<"Sensor"> | boolean
    processStepId?: IntNullableWithAggregatesFilter<"Sensor"> | number | null
    transportSystemId?: IntNullableWithAggregatesFilter<"Sensor"> | number | null
  }

  export type FilterEntryWhereInput = {
    AND?: FilterEntryWhereInput | FilterEntryWhereInput[]
    OR?: FilterEntryWhereInput[]
    NOT?: FilterEntryWhereInput | FilterEntryWhereInput[]
    id?: IntFilter<"FilterEntry"> | number
    addedAt?: DateTimeFilter<"FilterEntry"> | Date | string
    material?: StringFilter<"FilterEntry"> | string
    filterId?: IntFilter<"FilterEntry"> | number
    filter?: XOR<FilterRelationFilter, FilterWhereInput>
  }

  export type FilterEntryOrderByWithRelationInput = {
    id?: SortOrder
    addedAt?: SortOrder
    material?: SortOrder
    filterId?: SortOrder
    filter?: FilterOrderByWithRelationInput
  }

  export type FilterEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FilterEntryWhereInput | FilterEntryWhereInput[]
    OR?: FilterEntryWhereInput[]
    NOT?: FilterEntryWhereInput | FilterEntryWhereInput[]
    addedAt?: DateTimeFilter<"FilterEntry"> | Date | string
    material?: StringFilter<"FilterEntry"> | string
    filterId?: IntFilter<"FilterEntry"> | number
    filter?: XOR<FilterRelationFilter, FilterWhereInput>
  }, "id">

  export type FilterEntryOrderByWithAggregationInput = {
    id?: SortOrder
    addedAt?: SortOrder
    material?: SortOrder
    filterId?: SortOrder
    _count?: FilterEntryCountOrderByAggregateInput
    _avg?: FilterEntryAvgOrderByAggregateInput
    _max?: FilterEntryMaxOrderByAggregateInput
    _min?: FilterEntryMinOrderByAggregateInput
    _sum?: FilterEntrySumOrderByAggregateInput
  }

  export type FilterEntryScalarWhereWithAggregatesInput = {
    AND?: FilterEntryScalarWhereWithAggregatesInput | FilterEntryScalarWhereWithAggregatesInput[]
    OR?: FilterEntryScalarWhereWithAggregatesInput[]
    NOT?: FilterEntryScalarWhereWithAggregatesInput | FilterEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FilterEntry"> | number
    addedAt?: DateTimeWithAggregatesFilter<"FilterEntry"> | Date | string
    material?: StringWithAggregatesFilter<"FilterEntry"> | string
    filterId?: IntWithAggregatesFilter<"FilterEntry"> | number
  }

  export type FilterWhereInput = {
    AND?: FilterWhereInput | FilterWhereInput[]
    OR?: FilterWhereInput[]
    NOT?: FilterWhereInput | FilterWhereInput[]
    id?: IntFilter<"Filter"> | number
    createdAt?: DateTimeFilter<"Filter"> | Date | string
    updatedAt?: DateTimeFilter<"Filter"> | Date | string
    transportSystemId?: IntFilter<"Filter"> | number
    orderId?: IntNullableFilter<"Filter"> | number | null
    transportSystem?: XOR<TransportSystemRelationFilter, TransportSystemWhereInput>
    entries?: FilterEntryListRelationFilter
  }

  export type FilterOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transportSystemId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    transportSystem?: TransportSystemOrderByWithRelationInput
    entries?: FilterEntryOrderByRelationAggregateInput
  }

  export type FilterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transportSystemId?: number
    AND?: FilterWhereInput | FilterWhereInput[]
    OR?: FilterWhereInput[]
    NOT?: FilterWhereInput | FilterWhereInput[]
    createdAt?: DateTimeFilter<"Filter"> | Date | string
    updatedAt?: DateTimeFilter<"Filter"> | Date | string
    orderId?: IntNullableFilter<"Filter"> | number | null
    transportSystem?: XOR<TransportSystemRelationFilter, TransportSystemWhereInput>
    entries?: FilterEntryListRelationFilter
  }, "id" | "transportSystemId">

  export type FilterOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transportSystemId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    _count?: FilterCountOrderByAggregateInput
    _avg?: FilterAvgOrderByAggregateInput
    _max?: FilterMaxOrderByAggregateInput
    _min?: FilterMinOrderByAggregateInput
    _sum?: FilterSumOrderByAggregateInput
  }

  export type FilterScalarWhereWithAggregatesInput = {
    AND?: FilterScalarWhereWithAggregatesInput | FilterScalarWhereWithAggregatesInput[]
    OR?: FilterScalarWhereWithAggregatesInput[]
    NOT?: FilterScalarWhereWithAggregatesInput | FilterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Filter"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Filter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Filter"> | Date | string
    transportSystemId?: IntWithAggregatesFilter<"Filter"> | number
    orderId?: IntNullableWithAggregatesFilter<"Filter"> | number | null
  }

  export type TransportSystemWhereInput = {
    AND?: TransportSystemWhereInput | TransportSystemWhereInput[]
    OR?: TransportSystemWhereInput[]
    NOT?: TransportSystemWhereInput | TransportSystemWhereInput[]
    id?: IntFilter<"TransportSystem"> | number
    createdAt?: DateTimeFilter<"TransportSystem"> | Date | string
    updatedAt?: DateTimeFilter<"TransportSystem"> | Date | string
    active?: BoolFilter<"TransportSystem"> | boolean
    name?: StringFilter<"TransportSystem"> | string
    inputSpeed?: IntFilter<"TransportSystem"> | number
    outputSpeed?: IntFilter<"TransportSystem"> | number
    inventoryId?: IntFilter<"TransportSystem"> | number
    minQuantity?: IntNullableFilter<"TransportSystem"> | number | null
    transportDelay?: IntNullableFilter<"TransportSystem"> | number | null
    startStepId?: IntNullableFilter<"TransportSystem"> | number | null
    endStepId?: IntNullableFilter<"TransportSystem"> | number | null
    type?: StringFilter<"TransportSystem"> | string
    startTSId?: IntNullableFilter<"TransportSystem"> | number | null
    endTSId?: IntNullableFilter<"TransportSystem"> | number | null
    endStep?: XOR<ProcessStepNullableRelationFilter, ProcessStepWhereInput> | null
    startStep?: XOR<ProcessStepNullableRelationFilter, ProcessStepWhereInput> | null
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
    orders?: OrderListRelationFilter
    filter?: XOR<FilterNullableRelationFilter, FilterWhereInput> | null
    sensors?: SensorListRelationFilter
    resources?: ResourceListRelationFilter
  }

  export type TransportSystemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    active?: SortOrder
    name?: SortOrder
    inputSpeed?: SortOrder
    outputSpeed?: SortOrder
    inventoryId?: SortOrder
    minQuantity?: SortOrderInput | SortOrder
    transportDelay?: SortOrderInput | SortOrder
    startStepId?: SortOrderInput | SortOrder
    endStepId?: SortOrderInput | SortOrder
    type?: SortOrder
    startTSId?: SortOrderInput | SortOrder
    endTSId?: SortOrderInput | SortOrder
    endStep?: ProcessStepOrderByWithRelationInput
    startStep?: ProcessStepOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    filter?: FilterOrderByWithRelationInput
    sensors?: SensorOrderByRelationAggregateInput
    resources?: ResourceOrderByRelationAggregateInput
  }

  export type TransportSystemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    inventoryId?: number
    AND?: TransportSystemWhereInput | TransportSystemWhereInput[]
    OR?: TransportSystemWhereInput[]
    NOT?: TransportSystemWhereInput | TransportSystemWhereInput[]
    createdAt?: DateTimeFilter<"TransportSystem"> | Date | string
    updatedAt?: DateTimeFilter<"TransportSystem"> | Date | string
    active?: BoolFilter<"TransportSystem"> | boolean
    name?: StringFilter<"TransportSystem"> | string
    inputSpeed?: IntFilter<"TransportSystem"> | number
    outputSpeed?: IntFilter<"TransportSystem"> | number
    minQuantity?: IntNullableFilter<"TransportSystem"> | number | null
    transportDelay?: IntNullableFilter<"TransportSystem"> | number | null
    startStepId?: IntNullableFilter<"TransportSystem"> | number | null
    endStepId?: IntNullableFilter<"TransportSystem"> | number | null
    type?: StringFilter<"TransportSystem"> | string
    startTSId?: IntNullableFilter<"TransportSystem"> | number | null
    endTSId?: IntNullableFilter<"TransportSystem"> | number | null
    endStep?: XOR<ProcessStepNullableRelationFilter, ProcessStepWhereInput> | null
    startStep?: XOR<ProcessStepNullableRelationFilter, ProcessStepWhereInput> | null
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
    orders?: OrderListRelationFilter
    filter?: XOR<FilterNullableRelationFilter, FilterWhereInput> | null
    sensors?: SensorListRelationFilter
    resources?: ResourceListRelationFilter
  }, "id" | "inventoryId">

  export type TransportSystemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    active?: SortOrder
    name?: SortOrder
    inputSpeed?: SortOrder
    outputSpeed?: SortOrder
    inventoryId?: SortOrder
    minQuantity?: SortOrderInput | SortOrder
    transportDelay?: SortOrderInput | SortOrder
    startStepId?: SortOrderInput | SortOrder
    endStepId?: SortOrderInput | SortOrder
    type?: SortOrder
    startTSId?: SortOrderInput | SortOrder
    endTSId?: SortOrderInput | SortOrder
    _count?: TransportSystemCountOrderByAggregateInput
    _avg?: TransportSystemAvgOrderByAggregateInput
    _max?: TransportSystemMaxOrderByAggregateInput
    _min?: TransportSystemMinOrderByAggregateInput
    _sum?: TransportSystemSumOrderByAggregateInput
  }

  export type TransportSystemScalarWhereWithAggregatesInput = {
    AND?: TransportSystemScalarWhereWithAggregatesInput | TransportSystemScalarWhereWithAggregatesInput[]
    OR?: TransportSystemScalarWhereWithAggregatesInput[]
    NOT?: TransportSystemScalarWhereWithAggregatesInput | TransportSystemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TransportSystem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TransportSystem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransportSystem"> | Date | string
    active?: BoolWithAggregatesFilter<"TransportSystem"> | boolean
    name?: StringWithAggregatesFilter<"TransportSystem"> | string
    inputSpeed?: IntWithAggregatesFilter<"TransportSystem"> | number
    outputSpeed?: IntWithAggregatesFilter<"TransportSystem"> | number
    inventoryId?: IntWithAggregatesFilter<"TransportSystem"> | number
    minQuantity?: IntNullableWithAggregatesFilter<"TransportSystem"> | number | null
    transportDelay?: IntNullableWithAggregatesFilter<"TransportSystem"> | number | null
    startStepId?: IntNullableWithAggregatesFilter<"TransportSystem"> | number | null
    endStepId?: IntNullableWithAggregatesFilter<"TransportSystem"> | number | null
    type?: StringWithAggregatesFilter<"TransportSystem"> | string
    startTSId?: IntNullableWithAggregatesFilter<"TransportSystem"> | number | null
    endTSId?: IntNullableWithAggregatesFilter<"TransportSystem"> | number | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    status?: StringFilter<"Order"> | string
    priority?: IntFilter<"Order"> | number
    dueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    description?: StringNullableFilter<"Order"> | string | null
    quantity?: IntFilter<"Order"> | number
    startedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    startedTick?: IntNullableFilter<"Order"> | number | null
    completedTick?: IntNullableFilter<"Order"> | number | null
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    inventoryEntries?: InventoryEntryListRelationFilter
    processSteps?: ProcessStepListRelationFilter
    transportSystems?: TransportSystemListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    startedTick?: SortOrderInput | SortOrder
    completedTick?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    inventoryEntries?: InventoryEntryOrderByRelationAggregateInput
    processSteps?: ProcessStepOrderByRelationAggregateInput
    transportSystems?: TransportSystemOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    status?: StringFilter<"Order"> | string
    priority?: IntFilter<"Order"> | number
    dueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    description?: StringNullableFilter<"Order"> | string | null
    quantity?: IntFilter<"Order"> | number
    startedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    startedTick?: IntNullableFilter<"Order"> | number | null
    completedTick?: IntNullableFilter<"Order"> | number | null
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    inventoryEntries?: InventoryEntryListRelationFilter
    processSteps?: ProcessStepListRelationFilter
    transportSystems?: TransportSystemListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    startedTick?: SortOrderInput | SortOrder
    completedTick?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    status?: StringWithAggregatesFilter<"Order"> | string
    priority?: IntWithAggregatesFilter<"Order"> | number
    dueDate?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Order"> | string | null
    quantity?: IntWithAggregatesFilter<"Order"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    startedTick?: IntNullableWithAggregatesFilter<"Order"> | number | null
    completedTick?: IntNullableWithAggregatesFilter<"Order"> | number | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
  }

  export type SimulationRecordCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    kpis?: KpiRecordCreateNestedManyWithoutSimulationInput
  }

  export type SimulationRecordUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    kpis?: KpiRecordUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationRecordUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    kpis?: KpiRecordUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    kpis?: KpiRecordUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationRecordCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
  }

  export type SimulationRecordUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SimulationRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type KpiRecordCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    key: string
    value: number
    name?: string | null
    simulation: SimulationRecordCreateNestedOneWithoutKpisInput
  }

  export type KpiRecordUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    key: string
    value: number
    name?: string | null
    simulationId: number
  }

  export type KpiRecordUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    simulation?: SimulationRecordUpdateOneRequiredWithoutKpisNestedInput
  }

  export type KpiRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    simulationId?: IntFieldUpdateOperationsInput | number
  }

  export type KpiRecordCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    key: string
    value: number
    name?: string | null
    simulationId: number
  }

  export type KpiRecordUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KpiRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    simulationId?: IntFieldUpdateOperationsInput | number
  }

  export type ResourceCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    faulty?: boolean | null
    faultyRate?: number
    Machine?: MachineCreateNestedOneWithoutResourceInput
    processStep?: ProcessStepCreateNestedOneWithoutResourcesInput
    transportSystem?: TransportSystemCreateNestedOneWithoutResourcesInput
    location: LocationCreateNestedOneWithoutResourcesInput
    Worker?: WorkerCreateNestedOneWithoutResourceInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    locationId: number
    processStepId?: number | null
    transportSystemId?: number | null
    faulty?: boolean | null
    faultyRate?: number
    Machine?: MachineUncheckedCreateNestedOneWithoutResourceInput
    Worker?: WorkerUncheckedCreateNestedOneWithoutResourceInput
  }

  export type ResourceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
    Machine?: MachineUpdateOneWithoutResourceNestedInput
    processStep?: ProcessStepUpdateOneWithoutResourcesNestedInput
    transportSystem?: TransportSystemUpdateOneWithoutResourcesNestedInput
    location?: LocationUpdateOneRequiredWithoutResourcesNestedInput
    Worker?: WorkerUpdateOneWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    locationId?: IntFieldUpdateOperationsInput | number
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
    Machine?: MachineUncheckedUpdateOneWithoutResourceNestedInput
    Worker?: WorkerUncheckedUpdateOneWithoutResourceNestedInput
  }

  export type ResourceCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    locationId: number
    processStepId?: number | null
    transportSystemId?: number | null
    faulty?: boolean | null
    faultyRate?: number
  }

  export type ResourceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    locationId?: IntFieldUpdateOperationsInput | number
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
  }

  export type MachineCreateInput = {
    resource: ResourceCreateNestedOneWithoutMachineInput
  }

  export type MachineUncheckedCreateInput = {
    id?: number
    resourceId: number
  }

  export type MachineUpdateInput = {
    resource?: ResourceUpdateOneRequiredWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    resourceId?: IntFieldUpdateOperationsInput | number
  }

  export type MachineCreateManyInput = {
    id?: number
    resourceId: number
  }

  export type MachineUpdateManyMutationInput = {

  }

  export type MachineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    resourceId?: IntFieldUpdateOperationsInput | number
  }

  export type WorkerCreateInput = {
    workerNumber: string
    fullName: string
    address: string
    resource: ResourceCreateNestedOneWithoutWorkerInput
    workerRoles?: WorkerRoleCreateNestedManyWithoutWorkersInput
  }

  export type WorkerUncheckedCreateInput = {
    id?: number
    workerNumber: string
    fullName: string
    address: string
    resourceId: number
    workerRoles?: WorkerRoleUncheckedCreateNestedManyWithoutWorkersInput
  }

  export type WorkerUpdateInput = {
    workerNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    resource?: ResourceUpdateOneRequiredWithoutWorkerNestedInput
    workerRoles?: WorkerRoleUpdateManyWithoutWorkersNestedInput
  }

  export type WorkerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workerNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    resourceId?: IntFieldUpdateOperationsInput | number
    workerRoles?: WorkerRoleUncheckedUpdateManyWithoutWorkersNestedInput
  }

  export type WorkerCreateManyInput = {
    id?: number
    workerNumber: string
    fullName: string
    address: string
    resourceId: number
  }

  export type WorkerUpdateManyMutationInput = {
    workerNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type WorkerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workerNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    resourceId?: IntFieldUpdateOperationsInput | number
  }

  export type WorkerRoleCreateInput = {
    name: string
    description?: string | null
    workers?: WorkerCreateNestedManyWithoutWorkerRolesInput
  }

  export type WorkerRoleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    workers?: WorkerUncheckedCreateNestedManyWithoutWorkerRolesInput
  }

  export type WorkerRoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workers?: WorkerUpdateManyWithoutWorkerRolesNestedInput
  }

  export type WorkerRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workers?: WorkerUncheckedUpdateManyWithoutWorkerRolesNestedInput
  }

  export type WorkerRoleCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type WorkerRoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkerRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    limit: number
    entries?: InventoryEntryCreateNestedManyWithoutInventoryInput
    processStep?: ProcessStepCreateNestedOneWithoutInventoryInput
    transportSystem?: TransportSystemCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    limit: number
    entries?: InventoryEntryUncheckedCreateNestedManyWithoutInventoryInput
    processStep?: ProcessStepUncheckedCreateNestedOneWithoutInventoryInput
    transportSystem?: TransportSystemUncheckedCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    limit?: IntFieldUpdateOperationsInput | number
    entries?: InventoryEntryUpdateManyWithoutInventoryNestedInput
    processStep?: ProcessStepUpdateOneWithoutInventoryNestedInput
    transportSystem?: TransportSystemUpdateOneWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    limit?: IntFieldUpdateOperationsInput | number
    entries?: InventoryEntryUncheckedUpdateManyWithoutInventoryNestedInput
    processStep?: ProcessStepUncheckedUpdateOneWithoutInventoryNestedInput
    transportSystem?: TransportSystemUncheckedUpdateOneWithoutInventoryNestedInput
  }

  export type InventoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    limit: number
  }

  export type InventoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    limit?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    limit?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryEntryCreateInput = {
    addedAt?: Date | string
    material: string
    inventory: InventoryCreateNestedOneWithoutEntriesInput
    Order?: OrderCreateNestedOneWithoutInventoryEntriesInput
  }

  export type InventoryEntryUncheckedCreateInput = {
    id?: number
    addedAt?: Date | string
    material: string
    inventoryId: number
    orderId?: number | null
  }

  export type InventoryEntryUpdateInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
    inventory?: InventoryUpdateOneRequiredWithoutEntriesNestedInput
    Order?: OrderUpdateOneWithoutInventoryEntriesNestedInput
  }

  export type InventoryEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
    inventoryId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventoryEntryCreateManyInput = {
    id?: number
    addedAt?: Date | string
    material: string
    inventoryId: number
    orderId?: number | null
  }

  export type InventoryEntryUpdateManyMutationInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
    inventoryId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LocationCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    processSteps?: ProcessStepCreateNestedManyWithoutLocationInput
    resources?: ResourceCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutLocationInput
    resources?: ResourceUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processSteps?: ProcessStepUpdateManyWithoutLocationNestedInput
    resources?: ResourceUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processSteps?: ProcessStepUncheckedUpdateManyWithoutLocationNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
  }

  export type LocationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProcessStepCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    errorRate?: number | null
    orders?: OrderCreateNestedManyWithoutProcessStepsInput
    recipe?: RecipeCreateNestedOneWithoutProcessStepsInput
    inventory: InventoryCreateNestedOneWithoutProcessStepInput
    location: LocationCreateNestedOneWithoutProcessStepsInput
    resources?: ResourceCreateNestedManyWithoutProcessStepInput
    sensors?: SensorCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemCreateNestedManyWithoutEndStepInput
    outputs?: TransportSystemCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    locationId: number
    inventoryId: number
    recipeId?: number | null
    errorRate?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutProcessStepsInput
    resources?: ResourceUncheckedCreateNestedManyWithoutProcessStepInput
    sensors?: SensorUncheckedCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemUncheckedCreateNestedManyWithoutEndStepInput
    outputs?: TransportSystemUncheckedCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUpdateManyWithoutProcessStepsNestedInput
    recipe?: RecipeUpdateOneWithoutProcessStepsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutProcessStepNestedInput
    location?: LocationUpdateOneRequiredWithoutProcessStepsNestedInput
    resources?: ResourceUpdateManyWithoutProcessStepNestedInput
    sensors?: SensorUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUpdateManyWithoutEndStepNestedInput
    outputs?: TransportSystemUpdateManyWithoutStartStepNestedInput
  }

  export type ProcessStepUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutProcessStepsNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutProcessStepNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUncheckedUpdateManyWithoutEndStepNestedInput
    outputs?: TransportSystemUncheckedUpdateManyWithoutStartStepNestedInput
  }

  export type ProcessStepCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    locationId: number
    inventoryId: number
    recipeId?: number | null
    errorRate?: number | null
  }

  export type ProcessStepUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProcessStepUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RecipeCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    processSteps?: ProcessStepCreateNestedManyWithoutRecipeInput
    inputs?: RecipeInputCreateNestedManyWithoutRecipeInput
    outputs?: RecipeOutputCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutRecipeInput
    inputs?: RecipeInputUncheckedCreateNestedManyWithoutRecipeInput
    outputs?: RecipeOutputUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    processSteps?: ProcessStepUpdateManyWithoutRecipeNestedInput
    inputs?: RecipeInputUpdateManyWithoutRecipeNestedInput
    outputs?: RecipeOutputUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    processSteps?: ProcessStepUncheckedUpdateManyWithoutRecipeNestedInput
    inputs?: RecipeInputUncheckedUpdateManyWithoutRecipeNestedInput
    outputs?: RecipeOutputUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
  }

  export type RecipeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeInputCreateInput = {
    material: string
    quantity: number
    Recipe?: RecipeCreateNestedOneWithoutInputsInput
  }

  export type RecipeInputUncheckedCreateInput = {
    id?: number
    material: string
    quantity: number
    recipeId?: number | null
  }

  export type RecipeInputUpdateInput = {
    material?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    Recipe?: RecipeUpdateOneWithoutInputsNestedInput
  }

  export type RecipeInputUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecipeInputCreateManyInput = {
    id?: number
    material: string
    quantity: number
    recipeId?: number | null
  }

  export type RecipeInputUpdateManyMutationInput = {
    material?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeInputUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecipeOutputCreateInput = {
    material: string
    quantity: number
    Recipe?: RecipeCreateNestedOneWithoutOutputsInput
  }

  export type RecipeOutputUncheckedCreateInput = {
    id?: number
    material: string
    quantity: number
    recipeId?: number | null
  }

  export type RecipeOutputUpdateInput = {
    material?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    Recipe?: RecipeUpdateOneWithoutOutputsNestedInput
  }

  export type RecipeOutputUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecipeOutputCreateManyInput = {
    id?: number
    material: string
    quantity: number
    recipeId?: number | null
  }

  export type RecipeOutputUpdateManyMutationInput = {
    material?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeOutputUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LogEntryCreateInput = {
    createdAt?: Date | string
    inputType: string
    materialId: number
    materialName: string
    processStepId?: number | null
    transportSystemId?: number | null
    sensor?: SensorCreateNestedOneWithoutLogEntriesInput
  }

  export type LogEntryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    inputType: string
    sensorId?: number | null
    materialId: number
    materialName: string
    processStepId?: number | null
    transportSystemId?: number | null
  }

  export type LogEntryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputType?: StringFieldUpdateOperationsInput | string
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    sensor?: SensorUpdateOneWithoutLogEntriesNestedInput
  }

  export type LogEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputType?: StringFieldUpdateOperationsInput | string
    sensorId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LogEntryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    inputType: string
    sensorId?: number | null
    materialId: number
    materialName: string
    processStepId?: number | null
    transportSystemId?: number | null
  }

  export type LogEntryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputType?: StringFieldUpdateOperationsInput | string
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LogEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputType?: StringFieldUpdateOperationsInput | string
    sensorId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SensorCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: string
    value?: number
    sensorDelay?: number
    active?: boolean
    processStep?: ProcessStepCreateNestedOneWithoutSensorsInput
    transportSystem?: TransportSystemCreateNestedOneWithoutSensorsInput
    logEntries?: LogEntryCreateNestedManyWithoutSensorInput
  }

  export type SensorUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: string
    value?: number
    sensorDelay?: number
    active?: boolean
    processStepId?: number | null
    transportSystemId?: number | null
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutSensorInput
  }

  export type SensorUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sensorDelay?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    processStep?: ProcessStepUpdateOneWithoutSensorsNestedInput
    transportSystem?: TransportSystemUpdateOneWithoutSensorsNestedInput
    logEntries?: LogEntryUpdateManyWithoutSensorNestedInput
  }

  export type SensorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sensorDelay?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    logEntries?: LogEntryUncheckedUpdateManyWithoutSensorNestedInput
  }

  export type SensorCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: string
    value?: number
    sensorDelay?: number
    active?: boolean
    processStepId?: number | null
    transportSystemId?: number | null
  }

  export type SensorUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sensorDelay?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SensorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sensorDelay?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FilterEntryCreateInput = {
    addedAt?: Date | string
    material: string
    filter: FilterCreateNestedOneWithoutEntriesInput
  }

  export type FilterEntryUncheckedCreateInput = {
    id?: number
    addedAt?: Date | string
    material: string
    filterId: number
  }

  export type FilterEntryUpdateInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
    filter?: FilterUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type FilterEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
    filterId?: IntFieldUpdateOperationsInput | number
  }

  export type FilterEntryCreateManyInput = {
    id?: number
    addedAt?: Date | string
    material: string
    filterId: number
  }

  export type FilterEntryUpdateManyMutationInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
  }

  export type FilterEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
    filterId?: IntFieldUpdateOperationsInput | number
  }

  export type FilterCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId?: number | null
    transportSystem: TransportSystemCreateNestedOneWithoutFilterInput
    entries?: FilterEntryCreateNestedManyWithoutFilterInput
  }

  export type FilterUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transportSystemId: number
    orderId?: number | null
    entries?: FilterEntryUncheckedCreateNestedManyWithoutFilterInput
  }

  export type FilterUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystem?: TransportSystemUpdateOneRequiredWithoutFilterNestedInput
    entries?: FilterEntryUpdateManyWithoutFilterNestedInput
  }

  export type FilterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transportSystemId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    entries?: FilterEntryUncheckedUpdateManyWithoutFilterNestedInput
  }

  export type FilterCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transportSystemId: number
    orderId?: number | null
  }

  export type FilterUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FilterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transportSystemId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransportSystemCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    minQuantity?: number | null
    transportDelay?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    endStep?: ProcessStepCreateNestedOneWithoutInputsInput
    startStep?: ProcessStepCreateNestedOneWithoutOutputsInput
    inventory: InventoryCreateNestedOneWithoutTransportSystemInput
    orders?: OrderCreateNestedManyWithoutTransportSystemsInput
    filter?: FilterCreateNestedOneWithoutTransportSystemInput
    sensors?: SensorCreateNestedManyWithoutTransportSystemInput
    resources?: ResourceCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    inventoryId: number
    minQuantity?: number | null
    transportDelay?: number | null
    startStepId?: number | null
    endStepId?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutTransportSystemsInput
    filter?: FilterUncheckedCreateNestedOneWithoutTransportSystemInput
    sensors?: SensorUncheckedCreateNestedManyWithoutTransportSystemInput
    resources?: ResourceUncheckedCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endStep?: ProcessStepUpdateOneWithoutInputsNestedInput
    startStep?: ProcessStepUpdateOneWithoutOutputsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutTransportSystemNestedInput
    orders?: OrderUpdateManyWithoutTransportSystemsNestedInput
    filter?: FilterUpdateOneWithoutTransportSystemNestedInput
    sensors?: SensorUpdateManyWithoutTransportSystemNestedInput
    resources?: ResourceUpdateManyWithoutTransportSystemNestedInput
  }

  export type TransportSystemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    startStepId?: NullableIntFieldUpdateOperationsInput | number | null
    endStepId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutTransportSystemsNestedInput
    filter?: FilterUncheckedUpdateOneWithoutTransportSystemNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutTransportSystemNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutTransportSystemNestedInput
  }

  export type TransportSystemCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    inventoryId: number
    minQuantity?: number | null
    transportDelay?: number | null
    startStepId?: number | null
    endStepId?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
  }

  export type TransportSystemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransportSystemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    startStepId?: NullableIntFieldUpdateOperationsInput | number | null
    endStepId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    priority?: number
    dueDate?: Date | string | null
    description?: string | null
    quantity?: number
    startedAt?: Date | string | null
    startedTick?: number | null
    completedTick?: number | null
    completedAt?: Date | string | null
    canceledAt?: Date | string | null
    inventoryEntries?: InventoryEntryCreateNestedManyWithoutOrderInput
    processSteps?: ProcessStepCreateNestedManyWithoutOrdersInput
    transportSystems?: TransportSystemCreateNestedManyWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    priority?: number
    dueDate?: Date | string | null
    description?: string | null
    quantity?: number
    startedAt?: Date | string | null
    startedTick?: number | null
    completedTick?: number | null
    completedAt?: Date | string | null
    canceledAt?: Date | string | null
    inventoryEntries?: InventoryEntryUncheckedCreateNestedManyWithoutOrderInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutOrdersInput
    transportSystems?: TransportSystemUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrderUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryEntries?: InventoryEntryUpdateManyWithoutOrderNestedInput
    processSteps?: ProcessStepUpdateManyWithoutOrdersNestedInput
    transportSystems?: TransportSystemUpdateManyWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryEntries?: InventoryEntryUncheckedUpdateManyWithoutOrderNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutOrdersNestedInput
    transportSystems?: TransportSystemUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    priority?: number
    dueDate?: Date | string | null
    description?: string | null
    quantity?: number
    startedAt?: Date | string | null
    startedTick?: number | null
    completedTick?: number | null
    completedAt?: Date | string | null
    canceledAt?: Date | string | null
  }

  export type OrderUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type KpiRecordListRelationFilter = {
    every?: KpiRecordWhereInput
    some?: KpiRecordWhereInput
    none?: KpiRecordWhereInput
  }

  export type KpiRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SimulationRecordCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type SimulationRecordAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SimulationRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type SimulationRecordMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type SimulationRecordSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SimulationRecordRelationFilter = {
    is?: SimulationRecordWhereInput
    isNot?: SimulationRecordWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type KpiRecordCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    value?: SortOrder
    name?: SortOrder
    simulationId?: SortOrder
  }

  export type KpiRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    simulationId?: SortOrder
  }

  export type KpiRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    value?: SortOrder
    name?: SortOrder
    simulationId?: SortOrder
  }

  export type KpiRecordMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    value?: SortOrder
    name?: SortOrder
    simulationId?: SortOrder
  }

  export type KpiRecordSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    simulationId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type MachineNullableRelationFilter = {
    is?: MachineWhereInput | null
    isNot?: MachineWhereInput | null
  }

  export type ProcessStepNullableRelationFilter = {
    is?: ProcessStepWhereInput | null
    isNot?: ProcessStepWhereInput | null
  }

  export type TransportSystemNullableRelationFilter = {
    is?: TransportSystemWhereInput | null
    isNot?: TransportSystemWhereInput | null
  }

  export type LocationRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type WorkerNullableRelationFilter = {
    is?: WorkerWhereInput | null
    isNot?: WorkerWhereInput | null
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    mandatory?: SortOrder
    productionResource?: SortOrder
    inventoryResource?: SortOrder
    locationId?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
    faulty?: SortOrder
    faultyRate?: SortOrder
  }

  export type ResourceAvgOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
    faultyRate?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    mandatory?: SortOrder
    productionResource?: SortOrder
    inventoryResource?: SortOrder
    locationId?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
    faulty?: SortOrder
    faultyRate?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    mandatory?: SortOrder
    productionResource?: SortOrder
    inventoryResource?: SortOrder
    locationId?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
    faulty?: SortOrder
    faultyRate?: SortOrder
  }

  export type ResourceSumOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
    faultyRate?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ResourceRelationFilter = {
    is?: ResourceWhereInput
    isNot?: ResourceWhereInput
  }

  export type MachineCountOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
  }

  export type MachineAvgOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
  }

  export type MachineMaxOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
  }

  export type MachineMinOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
  }

  export type MachineSumOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
  }

  export type WorkerRoleListRelationFilter = {
    every?: WorkerRoleWhereInput
    some?: WorkerRoleWhereInput
    none?: WorkerRoleWhereInput
  }

  export type WorkerRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkerCountOrderByAggregateInput = {
    id?: SortOrder
    workerNumber?: SortOrder
    fullName?: SortOrder
    address?: SortOrder
    resourceId?: SortOrder
  }

  export type WorkerAvgOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
  }

  export type WorkerMaxOrderByAggregateInput = {
    id?: SortOrder
    workerNumber?: SortOrder
    fullName?: SortOrder
    address?: SortOrder
    resourceId?: SortOrder
  }

  export type WorkerMinOrderByAggregateInput = {
    id?: SortOrder
    workerNumber?: SortOrder
    fullName?: SortOrder
    address?: SortOrder
    resourceId?: SortOrder
  }

  export type WorkerSumOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
  }

  export type WorkerListRelationFilter = {
    every?: WorkerWhereInput
    some?: WorkerWhereInput
    none?: WorkerWhereInput
  }

  export type WorkerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkerRoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type WorkerRoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WorkerRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type WorkerRoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type WorkerRoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InventoryEntryListRelationFilter = {
    every?: InventoryEntryWhereInput
    some?: InventoryEntryWhereInput
    none?: InventoryEntryWhereInput
  }

  export type InventoryEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    limit?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    id?: SortOrder
    limit?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    limit?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    limit?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    id?: SortOrder
    limit?: SortOrder
  }

  export type InventoryRelationFilter = {
    is?: InventoryWhereInput
    isNot?: InventoryWhereInput
  }

  export type OrderNullableRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type InventoryEntryCountOrderByAggregateInput = {
    id?: SortOrder
    addedAt?: SortOrder
    material?: SortOrder
    inventoryId?: SortOrder
    orderId?: SortOrder
  }

  export type InventoryEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    orderId?: SortOrder
  }

  export type InventoryEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    addedAt?: SortOrder
    material?: SortOrder
    inventoryId?: SortOrder
    orderId?: SortOrder
  }

  export type InventoryEntryMinOrderByAggregateInput = {
    id?: SortOrder
    addedAt?: SortOrder
    material?: SortOrder
    inventoryId?: SortOrder
    orderId?: SortOrder
  }

  export type InventoryEntrySumOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    orderId?: SortOrder
  }

  export type ProcessStepListRelationFilter = {
    every?: ProcessStepWhereInput
    some?: ProcessStepWhereInput
    none?: ProcessStepWhereInput
  }

  export type ResourceListRelationFilter = {
    every?: ResourceWhereInput
    some?: ResourceWhereInput
    none?: ResourceWhereInput
  }

  export type ProcessStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type RecipeNullableRelationFilter = {
    is?: RecipeWhereInput | null
    isNot?: RecipeWhereInput | null
  }

  export type SensorListRelationFilter = {
    every?: SensorWhereInput
    some?: SensorWhereInput
    none?: SensorWhereInput
  }

  export type TransportSystemListRelationFilter = {
    every?: TransportSystemWhereInput
    some?: TransportSystemWhereInput
    none?: TransportSystemWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SensorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransportSystemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessStepCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    active?: SortOrder
    inputSpeed?: SortOrder
    outputSpeed?: SortOrder
    recipeRate?: SortOrder
    duration?: SortOrder
    locationId?: SortOrder
    inventoryId?: SortOrder
    recipeId?: SortOrder
    errorRate?: SortOrder
  }

  export type ProcessStepAvgOrderByAggregateInput = {
    id?: SortOrder
    inputSpeed?: SortOrder
    outputSpeed?: SortOrder
    recipeRate?: SortOrder
    duration?: SortOrder
    locationId?: SortOrder
    inventoryId?: SortOrder
    recipeId?: SortOrder
    errorRate?: SortOrder
  }

  export type ProcessStepMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    active?: SortOrder
    inputSpeed?: SortOrder
    outputSpeed?: SortOrder
    recipeRate?: SortOrder
    duration?: SortOrder
    locationId?: SortOrder
    inventoryId?: SortOrder
    recipeId?: SortOrder
    errorRate?: SortOrder
  }

  export type ProcessStepMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    active?: SortOrder
    inputSpeed?: SortOrder
    outputSpeed?: SortOrder
    recipeRate?: SortOrder
    duration?: SortOrder
    locationId?: SortOrder
    inventoryId?: SortOrder
    recipeId?: SortOrder
    errorRate?: SortOrder
  }

  export type ProcessStepSumOrderByAggregateInput = {
    id?: SortOrder
    inputSpeed?: SortOrder
    outputSpeed?: SortOrder
    recipeRate?: SortOrder
    duration?: SortOrder
    locationId?: SortOrder
    inventoryId?: SortOrder
    recipeId?: SortOrder
    errorRate?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type RecipeInputListRelationFilter = {
    every?: RecipeInputWhereInput
    some?: RecipeInputWhereInput
    none?: RecipeInputWhereInput
  }

  export type RecipeOutputListRelationFilter = {
    every?: RecipeOutputWhereInput
    some?: RecipeOutputWhereInput
    none?: RecipeOutputWhereInput
  }

  export type RecipeInputOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeOutputOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type RecipeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type RecipeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecipeInputMaterialRecipeIdCompoundUniqueInput = {
    material: string
    recipeId: number
  }

  export type RecipeInputCountOrderByAggregateInput = {
    id?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    recipeId?: SortOrder
  }

  export type RecipeInputAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    recipeId?: SortOrder
  }

  export type RecipeInputMaxOrderByAggregateInput = {
    id?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    recipeId?: SortOrder
  }

  export type RecipeInputMinOrderByAggregateInput = {
    id?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    recipeId?: SortOrder
  }

  export type RecipeInputSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    recipeId?: SortOrder
  }

  export type RecipeOutputCountOrderByAggregateInput = {
    id?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    recipeId?: SortOrder
  }

  export type RecipeOutputAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    recipeId?: SortOrder
  }

  export type RecipeOutputMaxOrderByAggregateInput = {
    id?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    recipeId?: SortOrder
  }

  export type RecipeOutputMinOrderByAggregateInput = {
    id?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    recipeId?: SortOrder
  }

  export type RecipeOutputSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    recipeId?: SortOrder
  }

  export type SensorNullableRelationFilter = {
    is?: SensorWhereInput | null
    isNot?: SensorWhereInput | null
  }

  export type LogEntryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    inputType?: SortOrder
    sensorId?: SortOrder
    materialId?: SortOrder
    materialName?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
  }

  export type LogEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    sensorId?: SortOrder
    materialId?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
  }

  export type LogEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    inputType?: SortOrder
    sensorId?: SortOrder
    materialId?: SortOrder
    materialName?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
  }

  export type LogEntryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    inputType?: SortOrder
    sensorId?: SortOrder
    materialId?: SortOrder
    materialName?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
  }

  export type LogEntrySumOrderByAggregateInput = {
    id?: SortOrder
    sensorId?: SortOrder
    materialId?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
  }

  export type LogEntryListRelationFilter = {
    every?: LogEntryWhereInput
    some?: LogEntryWhereInput
    none?: LogEntryWhereInput
  }

  export type LogEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SensorCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    sensorDelay?: SortOrder
    active?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
  }

  export type SensorAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    sensorDelay?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
  }

  export type SensorMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    sensorDelay?: SortOrder
    active?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
  }

  export type SensorMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    sensorDelay?: SortOrder
    active?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
  }

  export type SensorSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    sensorDelay?: SortOrder
    processStepId?: SortOrder
    transportSystemId?: SortOrder
  }

  export type FilterRelationFilter = {
    is?: FilterWhereInput
    isNot?: FilterWhereInput
  }

  export type FilterEntryCountOrderByAggregateInput = {
    id?: SortOrder
    addedAt?: SortOrder
    material?: SortOrder
    filterId?: SortOrder
  }

  export type FilterEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    filterId?: SortOrder
  }

  export type FilterEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    addedAt?: SortOrder
    material?: SortOrder
    filterId?: SortOrder
  }

  export type FilterEntryMinOrderByAggregateInput = {
    id?: SortOrder
    addedAt?: SortOrder
    material?: SortOrder
    filterId?: SortOrder
  }

  export type FilterEntrySumOrderByAggregateInput = {
    id?: SortOrder
    filterId?: SortOrder
  }

  export type TransportSystemRelationFilter = {
    is?: TransportSystemWhereInput
    isNot?: TransportSystemWhereInput
  }

  export type FilterEntryListRelationFilter = {
    every?: FilterEntryWhereInput
    some?: FilterEntryWhereInput
    none?: FilterEntryWhereInput
  }

  export type FilterEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FilterCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transportSystemId?: SortOrder
    orderId?: SortOrder
  }

  export type FilterAvgOrderByAggregateInput = {
    id?: SortOrder
    transportSystemId?: SortOrder
    orderId?: SortOrder
  }

  export type FilterMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transportSystemId?: SortOrder
    orderId?: SortOrder
  }

  export type FilterMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transportSystemId?: SortOrder
    orderId?: SortOrder
  }

  export type FilterSumOrderByAggregateInput = {
    id?: SortOrder
    transportSystemId?: SortOrder
    orderId?: SortOrder
  }

  export type FilterNullableRelationFilter = {
    is?: FilterWhereInput | null
    isNot?: FilterWhereInput | null
  }

  export type TransportSystemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    active?: SortOrder
    name?: SortOrder
    inputSpeed?: SortOrder
    outputSpeed?: SortOrder
    inventoryId?: SortOrder
    minQuantity?: SortOrder
    transportDelay?: SortOrder
    startStepId?: SortOrder
    endStepId?: SortOrder
    type?: SortOrder
    startTSId?: SortOrder
    endTSId?: SortOrder
  }

  export type TransportSystemAvgOrderByAggregateInput = {
    id?: SortOrder
    inputSpeed?: SortOrder
    outputSpeed?: SortOrder
    inventoryId?: SortOrder
    minQuantity?: SortOrder
    transportDelay?: SortOrder
    startStepId?: SortOrder
    endStepId?: SortOrder
    startTSId?: SortOrder
    endTSId?: SortOrder
  }

  export type TransportSystemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    active?: SortOrder
    name?: SortOrder
    inputSpeed?: SortOrder
    outputSpeed?: SortOrder
    inventoryId?: SortOrder
    minQuantity?: SortOrder
    transportDelay?: SortOrder
    startStepId?: SortOrder
    endStepId?: SortOrder
    type?: SortOrder
    startTSId?: SortOrder
    endTSId?: SortOrder
  }

  export type TransportSystemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    active?: SortOrder
    name?: SortOrder
    inputSpeed?: SortOrder
    outputSpeed?: SortOrder
    inventoryId?: SortOrder
    minQuantity?: SortOrder
    transportDelay?: SortOrder
    startStepId?: SortOrder
    endStepId?: SortOrder
    type?: SortOrder
    startTSId?: SortOrder
    endTSId?: SortOrder
  }

  export type TransportSystemSumOrderByAggregateInput = {
    id?: SortOrder
    inputSpeed?: SortOrder
    outputSpeed?: SortOrder
    inventoryId?: SortOrder
    minQuantity?: SortOrder
    transportDelay?: SortOrder
    startStepId?: SortOrder
    endStepId?: SortOrder
    startTSId?: SortOrder
    endTSId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    startedAt?: SortOrder
    startedTick?: SortOrder
    completedTick?: SortOrder
    completedAt?: SortOrder
    canceledAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
    quantity?: SortOrder
    startedTick?: SortOrder
    completedTick?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    startedAt?: SortOrder
    startedTick?: SortOrder
    completedTick?: SortOrder
    completedAt?: SortOrder
    canceledAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    startedAt?: SortOrder
    startedTick?: SortOrder
    completedTick?: SortOrder
    completedAt?: SortOrder
    canceledAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
    quantity?: SortOrder
    startedTick?: SortOrder
    completedTick?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type KpiRecordCreateNestedManyWithoutSimulationInput = {
    create?: XOR<KpiRecordCreateWithoutSimulationInput, KpiRecordUncheckedCreateWithoutSimulationInput> | KpiRecordCreateWithoutSimulationInput[] | KpiRecordUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: KpiRecordCreateOrConnectWithoutSimulationInput | KpiRecordCreateOrConnectWithoutSimulationInput[]
    createMany?: KpiRecordCreateManySimulationInputEnvelope
    connect?: KpiRecordWhereUniqueInput | KpiRecordWhereUniqueInput[]
  }

  export type KpiRecordUncheckedCreateNestedManyWithoutSimulationInput = {
    create?: XOR<KpiRecordCreateWithoutSimulationInput, KpiRecordUncheckedCreateWithoutSimulationInput> | KpiRecordCreateWithoutSimulationInput[] | KpiRecordUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: KpiRecordCreateOrConnectWithoutSimulationInput | KpiRecordCreateOrConnectWithoutSimulationInput[]
    createMany?: KpiRecordCreateManySimulationInputEnvelope
    connect?: KpiRecordWhereUniqueInput | KpiRecordWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type KpiRecordUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<KpiRecordCreateWithoutSimulationInput, KpiRecordUncheckedCreateWithoutSimulationInput> | KpiRecordCreateWithoutSimulationInput[] | KpiRecordUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: KpiRecordCreateOrConnectWithoutSimulationInput | KpiRecordCreateOrConnectWithoutSimulationInput[]
    upsert?: KpiRecordUpsertWithWhereUniqueWithoutSimulationInput | KpiRecordUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: KpiRecordCreateManySimulationInputEnvelope
    set?: KpiRecordWhereUniqueInput | KpiRecordWhereUniqueInput[]
    disconnect?: KpiRecordWhereUniqueInput | KpiRecordWhereUniqueInput[]
    delete?: KpiRecordWhereUniqueInput | KpiRecordWhereUniqueInput[]
    connect?: KpiRecordWhereUniqueInput | KpiRecordWhereUniqueInput[]
    update?: KpiRecordUpdateWithWhereUniqueWithoutSimulationInput | KpiRecordUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: KpiRecordUpdateManyWithWhereWithoutSimulationInput | KpiRecordUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: KpiRecordScalarWhereInput | KpiRecordScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type KpiRecordUncheckedUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<KpiRecordCreateWithoutSimulationInput, KpiRecordUncheckedCreateWithoutSimulationInput> | KpiRecordCreateWithoutSimulationInput[] | KpiRecordUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: KpiRecordCreateOrConnectWithoutSimulationInput | KpiRecordCreateOrConnectWithoutSimulationInput[]
    upsert?: KpiRecordUpsertWithWhereUniqueWithoutSimulationInput | KpiRecordUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: KpiRecordCreateManySimulationInputEnvelope
    set?: KpiRecordWhereUniqueInput | KpiRecordWhereUniqueInput[]
    disconnect?: KpiRecordWhereUniqueInput | KpiRecordWhereUniqueInput[]
    delete?: KpiRecordWhereUniqueInput | KpiRecordWhereUniqueInput[]
    connect?: KpiRecordWhereUniqueInput | KpiRecordWhereUniqueInput[]
    update?: KpiRecordUpdateWithWhereUniqueWithoutSimulationInput | KpiRecordUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: KpiRecordUpdateManyWithWhereWithoutSimulationInput | KpiRecordUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: KpiRecordScalarWhereInput | KpiRecordScalarWhereInput[]
  }

  export type SimulationRecordCreateNestedOneWithoutKpisInput = {
    create?: XOR<SimulationRecordCreateWithoutKpisInput, SimulationRecordUncheckedCreateWithoutKpisInput>
    connectOrCreate?: SimulationRecordCreateOrConnectWithoutKpisInput
    connect?: SimulationRecordWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type SimulationRecordUpdateOneRequiredWithoutKpisNestedInput = {
    create?: XOR<SimulationRecordCreateWithoutKpisInput, SimulationRecordUncheckedCreateWithoutKpisInput>
    connectOrCreate?: SimulationRecordCreateOrConnectWithoutKpisInput
    upsert?: SimulationRecordUpsertWithoutKpisInput
    connect?: SimulationRecordWhereUniqueInput
    update?: XOR<XOR<SimulationRecordUpdateToOneWithWhereWithoutKpisInput, SimulationRecordUpdateWithoutKpisInput>, SimulationRecordUncheckedUpdateWithoutKpisInput>
  }

  export type MachineCreateNestedOneWithoutResourceInput = {
    create?: XOR<MachineCreateWithoutResourceInput, MachineUncheckedCreateWithoutResourceInput>
    connectOrCreate?: MachineCreateOrConnectWithoutResourceInput
    connect?: MachineWhereUniqueInput
  }

  export type ProcessStepCreateNestedOneWithoutResourcesInput = {
    create?: XOR<ProcessStepCreateWithoutResourcesInput, ProcessStepUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutResourcesInput
    connect?: ProcessStepWhereUniqueInput
  }

  export type TransportSystemCreateNestedOneWithoutResourcesInput = {
    create?: XOR<TransportSystemCreateWithoutResourcesInput, TransportSystemUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: TransportSystemCreateOrConnectWithoutResourcesInput
    connect?: TransportSystemWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutResourcesInput = {
    create?: XOR<LocationCreateWithoutResourcesInput, LocationUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutResourcesInput
    connect?: LocationWhereUniqueInput
  }

  export type WorkerCreateNestedOneWithoutResourceInput = {
    create?: XOR<WorkerCreateWithoutResourceInput, WorkerUncheckedCreateWithoutResourceInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutResourceInput
    connect?: WorkerWhereUniqueInput
  }

  export type MachineUncheckedCreateNestedOneWithoutResourceInput = {
    create?: XOR<MachineCreateWithoutResourceInput, MachineUncheckedCreateWithoutResourceInput>
    connectOrCreate?: MachineCreateOrConnectWithoutResourceInput
    connect?: MachineWhereUniqueInput
  }

  export type WorkerUncheckedCreateNestedOneWithoutResourceInput = {
    create?: XOR<WorkerCreateWithoutResourceInput, WorkerUncheckedCreateWithoutResourceInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutResourceInput
    connect?: WorkerWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type MachineUpdateOneWithoutResourceNestedInput = {
    create?: XOR<MachineCreateWithoutResourceInput, MachineUncheckedCreateWithoutResourceInput>
    connectOrCreate?: MachineCreateOrConnectWithoutResourceInput
    upsert?: MachineUpsertWithoutResourceInput
    disconnect?: MachineWhereInput | boolean
    delete?: MachineWhereInput | boolean
    connect?: MachineWhereUniqueInput
    update?: XOR<XOR<MachineUpdateToOneWithWhereWithoutResourceInput, MachineUpdateWithoutResourceInput>, MachineUncheckedUpdateWithoutResourceInput>
  }

  export type ProcessStepUpdateOneWithoutResourcesNestedInput = {
    create?: XOR<ProcessStepCreateWithoutResourcesInput, ProcessStepUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutResourcesInput
    upsert?: ProcessStepUpsertWithoutResourcesInput
    disconnect?: ProcessStepWhereInput | boolean
    delete?: ProcessStepWhereInput | boolean
    connect?: ProcessStepWhereUniqueInput
    update?: XOR<XOR<ProcessStepUpdateToOneWithWhereWithoutResourcesInput, ProcessStepUpdateWithoutResourcesInput>, ProcessStepUncheckedUpdateWithoutResourcesInput>
  }

  export type TransportSystemUpdateOneWithoutResourcesNestedInput = {
    create?: XOR<TransportSystemCreateWithoutResourcesInput, TransportSystemUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: TransportSystemCreateOrConnectWithoutResourcesInput
    upsert?: TransportSystemUpsertWithoutResourcesInput
    disconnect?: TransportSystemWhereInput | boolean
    delete?: TransportSystemWhereInput | boolean
    connect?: TransportSystemWhereUniqueInput
    update?: XOR<XOR<TransportSystemUpdateToOneWithWhereWithoutResourcesInput, TransportSystemUpdateWithoutResourcesInput>, TransportSystemUncheckedUpdateWithoutResourcesInput>
  }

  export type LocationUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<LocationCreateWithoutResourcesInput, LocationUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutResourcesInput
    upsert?: LocationUpsertWithoutResourcesInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutResourcesInput, LocationUpdateWithoutResourcesInput>, LocationUncheckedUpdateWithoutResourcesInput>
  }

  export type WorkerUpdateOneWithoutResourceNestedInput = {
    create?: XOR<WorkerCreateWithoutResourceInput, WorkerUncheckedCreateWithoutResourceInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutResourceInput
    upsert?: WorkerUpsertWithoutResourceInput
    disconnect?: WorkerWhereInput | boolean
    delete?: WorkerWhereInput | boolean
    connect?: WorkerWhereUniqueInput
    update?: XOR<XOR<WorkerUpdateToOneWithWhereWithoutResourceInput, WorkerUpdateWithoutResourceInput>, WorkerUncheckedUpdateWithoutResourceInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MachineUncheckedUpdateOneWithoutResourceNestedInput = {
    create?: XOR<MachineCreateWithoutResourceInput, MachineUncheckedCreateWithoutResourceInput>
    connectOrCreate?: MachineCreateOrConnectWithoutResourceInput
    upsert?: MachineUpsertWithoutResourceInput
    disconnect?: MachineWhereInput | boolean
    delete?: MachineWhereInput | boolean
    connect?: MachineWhereUniqueInput
    update?: XOR<XOR<MachineUpdateToOneWithWhereWithoutResourceInput, MachineUpdateWithoutResourceInput>, MachineUncheckedUpdateWithoutResourceInput>
  }

  export type WorkerUncheckedUpdateOneWithoutResourceNestedInput = {
    create?: XOR<WorkerCreateWithoutResourceInput, WorkerUncheckedCreateWithoutResourceInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutResourceInput
    upsert?: WorkerUpsertWithoutResourceInput
    disconnect?: WorkerWhereInput | boolean
    delete?: WorkerWhereInput | boolean
    connect?: WorkerWhereUniqueInput
    update?: XOR<XOR<WorkerUpdateToOneWithWhereWithoutResourceInput, WorkerUpdateWithoutResourceInput>, WorkerUncheckedUpdateWithoutResourceInput>
  }

  export type ResourceCreateNestedOneWithoutMachineInput = {
    create?: XOR<ResourceCreateWithoutMachineInput, ResourceUncheckedCreateWithoutMachineInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutMachineInput
    connect?: ResourceWhereUniqueInput
  }

  export type ResourceUpdateOneRequiredWithoutMachineNestedInput = {
    create?: XOR<ResourceCreateWithoutMachineInput, ResourceUncheckedCreateWithoutMachineInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutMachineInput
    upsert?: ResourceUpsertWithoutMachineInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutMachineInput, ResourceUpdateWithoutMachineInput>, ResourceUncheckedUpdateWithoutMachineInput>
  }

  export type ResourceCreateNestedOneWithoutWorkerInput = {
    create?: XOR<ResourceCreateWithoutWorkerInput, ResourceUncheckedCreateWithoutWorkerInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutWorkerInput
    connect?: ResourceWhereUniqueInput
  }

  export type WorkerRoleCreateNestedManyWithoutWorkersInput = {
    create?: XOR<WorkerRoleCreateWithoutWorkersInput, WorkerRoleUncheckedCreateWithoutWorkersInput> | WorkerRoleCreateWithoutWorkersInput[] | WorkerRoleUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: WorkerRoleCreateOrConnectWithoutWorkersInput | WorkerRoleCreateOrConnectWithoutWorkersInput[]
    connect?: WorkerRoleWhereUniqueInput | WorkerRoleWhereUniqueInput[]
  }

  export type WorkerRoleUncheckedCreateNestedManyWithoutWorkersInput = {
    create?: XOR<WorkerRoleCreateWithoutWorkersInput, WorkerRoleUncheckedCreateWithoutWorkersInput> | WorkerRoleCreateWithoutWorkersInput[] | WorkerRoleUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: WorkerRoleCreateOrConnectWithoutWorkersInput | WorkerRoleCreateOrConnectWithoutWorkersInput[]
    connect?: WorkerRoleWhereUniqueInput | WorkerRoleWhereUniqueInput[]
  }

  export type ResourceUpdateOneRequiredWithoutWorkerNestedInput = {
    create?: XOR<ResourceCreateWithoutWorkerInput, ResourceUncheckedCreateWithoutWorkerInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutWorkerInput
    upsert?: ResourceUpsertWithoutWorkerInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutWorkerInput, ResourceUpdateWithoutWorkerInput>, ResourceUncheckedUpdateWithoutWorkerInput>
  }

  export type WorkerRoleUpdateManyWithoutWorkersNestedInput = {
    create?: XOR<WorkerRoleCreateWithoutWorkersInput, WorkerRoleUncheckedCreateWithoutWorkersInput> | WorkerRoleCreateWithoutWorkersInput[] | WorkerRoleUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: WorkerRoleCreateOrConnectWithoutWorkersInput | WorkerRoleCreateOrConnectWithoutWorkersInput[]
    upsert?: WorkerRoleUpsertWithWhereUniqueWithoutWorkersInput | WorkerRoleUpsertWithWhereUniqueWithoutWorkersInput[]
    set?: WorkerRoleWhereUniqueInput | WorkerRoleWhereUniqueInput[]
    disconnect?: WorkerRoleWhereUniqueInput | WorkerRoleWhereUniqueInput[]
    delete?: WorkerRoleWhereUniqueInput | WorkerRoleWhereUniqueInput[]
    connect?: WorkerRoleWhereUniqueInput | WorkerRoleWhereUniqueInput[]
    update?: WorkerRoleUpdateWithWhereUniqueWithoutWorkersInput | WorkerRoleUpdateWithWhereUniqueWithoutWorkersInput[]
    updateMany?: WorkerRoleUpdateManyWithWhereWithoutWorkersInput | WorkerRoleUpdateManyWithWhereWithoutWorkersInput[]
    deleteMany?: WorkerRoleScalarWhereInput | WorkerRoleScalarWhereInput[]
  }

  export type WorkerRoleUncheckedUpdateManyWithoutWorkersNestedInput = {
    create?: XOR<WorkerRoleCreateWithoutWorkersInput, WorkerRoleUncheckedCreateWithoutWorkersInput> | WorkerRoleCreateWithoutWorkersInput[] | WorkerRoleUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: WorkerRoleCreateOrConnectWithoutWorkersInput | WorkerRoleCreateOrConnectWithoutWorkersInput[]
    upsert?: WorkerRoleUpsertWithWhereUniqueWithoutWorkersInput | WorkerRoleUpsertWithWhereUniqueWithoutWorkersInput[]
    set?: WorkerRoleWhereUniqueInput | WorkerRoleWhereUniqueInput[]
    disconnect?: WorkerRoleWhereUniqueInput | WorkerRoleWhereUniqueInput[]
    delete?: WorkerRoleWhereUniqueInput | WorkerRoleWhereUniqueInput[]
    connect?: WorkerRoleWhereUniqueInput | WorkerRoleWhereUniqueInput[]
    update?: WorkerRoleUpdateWithWhereUniqueWithoutWorkersInput | WorkerRoleUpdateWithWhereUniqueWithoutWorkersInput[]
    updateMany?: WorkerRoleUpdateManyWithWhereWithoutWorkersInput | WorkerRoleUpdateManyWithWhereWithoutWorkersInput[]
    deleteMany?: WorkerRoleScalarWhereInput | WorkerRoleScalarWhereInput[]
  }

  export type WorkerCreateNestedManyWithoutWorkerRolesInput = {
    create?: XOR<WorkerCreateWithoutWorkerRolesInput, WorkerUncheckedCreateWithoutWorkerRolesInput> | WorkerCreateWithoutWorkerRolesInput[] | WorkerUncheckedCreateWithoutWorkerRolesInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutWorkerRolesInput | WorkerCreateOrConnectWithoutWorkerRolesInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
  }

  export type WorkerUncheckedCreateNestedManyWithoutWorkerRolesInput = {
    create?: XOR<WorkerCreateWithoutWorkerRolesInput, WorkerUncheckedCreateWithoutWorkerRolesInput> | WorkerCreateWithoutWorkerRolesInput[] | WorkerUncheckedCreateWithoutWorkerRolesInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutWorkerRolesInput | WorkerCreateOrConnectWithoutWorkerRolesInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
  }

  export type WorkerUpdateManyWithoutWorkerRolesNestedInput = {
    create?: XOR<WorkerCreateWithoutWorkerRolesInput, WorkerUncheckedCreateWithoutWorkerRolesInput> | WorkerCreateWithoutWorkerRolesInput[] | WorkerUncheckedCreateWithoutWorkerRolesInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutWorkerRolesInput | WorkerCreateOrConnectWithoutWorkerRolesInput[]
    upsert?: WorkerUpsertWithWhereUniqueWithoutWorkerRolesInput | WorkerUpsertWithWhereUniqueWithoutWorkerRolesInput[]
    set?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    disconnect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    delete?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    update?: WorkerUpdateWithWhereUniqueWithoutWorkerRolesInput | WorkerUpdateWithWhereUniqueWithoutWorkerRolesInput[]
    updateMany?: WorkerUpdateManyWithWhereWithoutWorkerRolesInput | WorkerUpdateManyWithWhereWithoutWorkerRolesInput[]
    deleteMany?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
  }

  export type WorkerUncheckedUpdateManyWithoutWorkerRolesNestedInput = {
    create?: XOR<WorkerCreateWithoutWorkerRolesInput, WorkerUncheckedCreateWithoutWorkerRolesInput> | WorkerCreateWithoutWorkerRolesInput[] | WorkerUncheckedCreateWithoutWorkerRolesInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutWorkerRolesInput | WorkerCreateOrConnectWithoutWorkerRolesInput[]
    upsert?: WorkerUpsertWithWhereUniqueWithoutWorkerRolesInput | WorkerUpsertWithWhereUniqueWithoutWorkerRolesInput[]
    set?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    disconnect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    delete?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    update?: WorkerUpdateWithWhereUniqueWithoutWorkerRolesInput | WorkerUpdateWithWhereUniqueWithoutWorkerRolesInput[]
    updateMany?: WorkerUpdateManyWithWhereWithoutWorkerRolesInput | WorkerUpdateManyWithWhereWithoutWorkerRolesInput[]
    deleteMany?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
  }

  export type InventoryEntryCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryEntryCreateWithoutInventoryInput, InventoryEntryUncheckedCreateWithoutInventoryInput> | InventoryEntryCreateWithoutInventoryInput[] | InventoryEntryUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryEntryCreateOrConnectWithoutInventoryInput | InventoryEntryCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryEntryCreateManyInventoryInputEnvelope
    connect?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
  }

  export type ProcessStepCreateNestedOneWithoutInventoryInput = {
    create?: XOR<ProcessStepCreateWithoutInventoryInput, ProcessStepUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutInventoryInput
    connect?: ProcessStepWhereUniqueInput
  }

  export type TransportSystemCreateNestedOneWithoutInventoryInput = {
    create?: XOR<TransportSystemCreateWithoutInventoryInput, TransportSystemUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: TransportSystemCreateOrConnectWithoutInventoryInput
    connect?: TransportSystemWhereUniqueInput
  }

  export type InventoryEntryUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryEntryCreateWithoutInventoryInput, InventoryEntryUncheckedCreateWithoutInventoryInput> | InventoryEntryCreateWithoutInventoryInput[] | InventoryEntryUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryEntryCreateOrConnectWithoutInventoryInput | InventoryEntryCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryEntryCreateManyInventoryInputEnvelope
    connect?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
  }

  export type ProcessStepUncheckedCreateNestedOneWithoutInventoryInput = {
    create?: XOR<ProcessStepCreateWithoutInventoryInput, ProcessStepUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutInventoryInput
    connect?: ProcessStepWhereUniqueInput
  }

  export type TransportSystemUncheckedCreateNestedOneWithoutInventoryInput = {
    create?: XOR<TransportSystemCreateWithoutInventoryInput, TransportSystemUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: TransportSystemCreateOrConnectWithoutInventoryInput
    connect?: TransportSystemWhereUniqueInput
  }

  export type InventoryEntryUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryEntryCreateWithoutInventoryInput, InventoryEntryUncheckedCreateWithoutInventoryInput> | InventoryEntryCreateWithoutInventoryInput[] | InventoryEntryUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryEntryCreateOrConnectWithoutInventoryInput | InventoryEntryCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryEntryUpsertWithWhereUniqueWithoutInventoryInput | InventoryEntryUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryEntryCreateManyInventoryInputEnvelope
    set?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    disconnect?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    delete?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    connect?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    update?: InventoryEntryUpdateWithWhereUniqueWithoutInventoryInput | InventoryEntryUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryEntryUpdateManyWithWhereWithoutInventoryInput | InventoryEntryUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryEntryScalarWhereInput | InventoryEntryScalarWhereInput[]
  }

  export type ProcessStepUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<ProcessStepCreateWithoutInventoryInput, ProcessStepUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutInventoryInput
    upsert?: ProcessStepUpsertWithoutInventoryInput
    disconnect?: ProcessStepWhereInput | boolean
    delete?: ProcessStepWhereInput | boolean
    connect?: ProcessStepWhereUniqueInput
    update?: XOR<XOR<ProcessStepUpdateToOneWithWhereWithoutInventoryInput, ProcessStepUpdateWithoutInventoryInput>, ProcessStepUncheckedUpdateWithoutInventoryInput>
  }

  export type TransportSystemUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<TransportSystemCreateWithoutInventoryInput, TransportSystemUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: TransportSystemCreateOrConnectWithoutInventoryInput
    upsert?: TransportSystemUpsertWithoutInventoryInput
    disconnect?: TransportSystemWhereInput | boolean
    delete?: TransportSystemWhereInput | boolean
    connect?: TransportSystemWhereUniqueInput
    update?: XOR<XOR<TransportSystemUpdateToOneWithWhereWithoutInventoryInput, TransportSystemUpdateWithoutInventoryInput>, TransportSystemUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryEntryUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryEntryCreateWithoutInventoryInput, InventoryEntryUncheckedCreateWithoutInventoryInput> | InventoryEntryCreateWithoutInventoryInput[] | InventoryEntryUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryEntryCreateOrConnectWithoutInventoryInput | InventoryEntryCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryEntryUpsertWithWhereUniqueWithoutInventoryInput | InventoryEntryUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryEntryCreateManyInventoryInputEnvelope
    set?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    disconnect?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    delete?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    connect?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    update?: InventoryEntryUpdateWithWhereUniqueWithoutInventoryInput | InventoryEntryUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryEntryUpdateManyWithWhereWithoutInventoryInput | InventoryEntryUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryEntryScalarWhereInput | InventoryEntryScalarWhereInput[]
  }

  export type ProcessStepUncheckedUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<ProcessStepCreateWithoutInventoryInput, ProcessStepUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutInventoryInput
    upsert?: ProcessStepUpsertWithoutInventoryInput
    disconnect?: ProcessStepWhereInput | boolean
    delete?: ProcessStepWhereInput | boolean
    connect?: ProcessStepWhereUniqueInput
    update?: XOR<XOR<ProcessStepUpdateToOneWithWhereWithoutInventoryInput, ProcessStepUpdateWithoutInventoryInput>, ProcessStepUncheckedUpdateWithoutInventoryInput>
  }

  export type TransportSystemUncheckedUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<TransportSystemCreateWithoutInventoryInput, TransportSystemUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: TransportSystemCreateOrConnectWithoutInventoryInput
    upsert?: TransportSystemUpsertWithoutInventoryInput
    disconnect?: TransportSystemWhereInput | boolean
    delete?: TransportSystemWhereInput | boolean
    connect?: TransportSystemWhereUniqueInput
    update?: XOR<XOR<TransportSystemUpdateToOneWithWhereWithoutInventoryInput, TransportSystemUpdateWithoutInventoryInput>, TransportSystemUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryCreateNestedOneWithoutEntriesInput = {
    create?: XOR<InventoryCreateWithoutEntriesInput, InventoryUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutEntriesInput
    connect?: InventoryWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutInventoryEntriesInput = {
    create?: XOR<OrderCreateWithoutInventoryEntriesInput, OrderUncheckedCreateWithoutInventoryEntriesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInventoryEntriesInput
    connect?: OrderWhereUniqueInput
  }

  export type InventoryUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<InventoryCreateWithoutEntriesInput, InventoryUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutEntriesInput
    upsert?: InventoryUpsertWithoutEntriesInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutEntriesInput, InventoryUpdateWithoutEntriesInput>, InventoryUncheckedUpdateWithoutEntriesInput>
  }

  export type OrderUpdateOneWithoutInventoryEntriesNestedInput = {
    create?: XOR<OrderCreateWithoutInventoryEntriesInput, OrderUncheckedCreateWithoutInventoryEntriesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInventoryEntriesInput
    upsert?: OrderUpsertWithoutInventoryEntriesInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutInventoryEntriesInput, OrderUpdateWithoutInventoryEntriesInput>, OrderUncheckedUpdateWithoutInventoryEntriesInput>
  }

  export type ProcessStepCreateNestedManyWithoutLocationInput = {
    create?: XOR<ProcessStepCreateWithoutLocationInput, ProcessStepUncheckedCreateWithoutLocationInput> | ProcessStepCreateWithoutLocationInput[] | ProcessStepUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutLocationInput | ProcessStepCreateOrConnectWithoutLocationInput[]
    createMany?: ProcessStepCreateManyLocationInputEnvelope
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
  }

  export type ResourceCreateNestedManyWithoutLocationInput = {
    create?: XOR<ResourceCreateWithoutLocationInput, ResourceUncheckedCreateWithoutLocationInput> | ResourceCreateWithoutLocationInput[] | ResourceUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutLocationInput | ResourceCreateOrConnectWithoutLocationInput[]
    createMany?: ResourceCreateManyLocationInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type ProcessStepUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<ProcessStepCreateWithoutLocationInput, ProcessStepUncheckedCreateWithoutLocationInput> | ProcessStepCreateWithoutLocationInput[] | ProcessStepUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutLocationInput | ProcessStepCreateOrConnectWithoutLocationInput[]
    createMany?: ProcessStepCreateManyLocationInputEnvelope
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<ResourceCreateWithoutLocationInput, ResourceUncheckedCreateWithoutLocationInput> | ResourceCreateWithoutLocationInput[] | ResourceUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutLocationInput | ResourceCreateOrConnectWithoutLocationInput[]
    createMany?: ResourceCreateManyLocationInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type ProcessStepUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ProcessStepCreateWithoutLocationInput, ProcessStepUncheckedCreateWithoutLocationInput> | ProcessStepCreateWithoutLocationInput[] | ProcessStepUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutLocationInput | ProcessStepCreateOrConnectWithoutLocationInput[]
    upsert?: ProcessStepUpsertWithWhereUniqueWithoutLocationInput | ProcessStepUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ProcessStepCreateManyLocationInputEnvelope
    set?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    disconnect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    delete?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    update?: ProcessStepUpdateWithWhereUniqueWithoutLocationInput | ProcessStepUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ProcessStepUpdateManyWithWhereWithoutLocationInput | ProcessStepUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
  }

  export type ResourceUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ResourceCreateWithoutLocationInput, ResourceUncheckedCreateWithoutLocationInput> | ResourceCreateWithoutLocationInput[] | ResourceUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutLocationInput | ResourceCreateOrConnectWithoutLocationInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutLocationInput | ResourceUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ResourceCreateManyLocationInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutLocationInput | ResourceUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutLocationInput | ResourceUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type ProcessStepUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ProcessStepCreateWithoutLocationInput, ProcessStepUncheckedCreateWithoutLocationInput> | ProcessStepCreateWithoutLocationInput[] | ProcessStepUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutLocationInput | ProcessStepCreateOrConnectWithoutLocationInput[]
    upsert?: ProcessStepUpsertWithWhereUniqueWithoutLocationInput | ProcessStepUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ProcessStepCreateManyLocationInputEnvelope
    set?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    disconnect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    delete?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    update?: ProcessStepUpdateWithWhereUniqueWithoutLocationInput | ProcessStepUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ProcessStepUpdateManyWithWhereWithoutLocationInput | ProcessStepUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ResourceCreateWithoutLocationInput, ResourceUncheckedCreateWithoutLocationInput> | ResourceCreateWithoutLocationInput[] | ResourceUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutLocationInput | ResourceCreateOrConnectWithoutLocationInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutLocationInput | ResourceUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ResourceCreateManyLocationInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutLocationInput | ResourceUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutLocationInput | ResourceUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutProcessStepsInput = {
    create?: XOR<OrderCreateWithoutProcessStepsInput, OrderUncheckedCreateWithoutProcessStepsInput> | OrderCreateWithoutProcessStepsInput[] | OrderUncheckedCreateWithoutProcessStepsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProcessStepsInput | OrderCreateOrConnectWithoutProcessStepsInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type RecipeCreateNestedOneWithoutProcessStepsInput = {
    create?: XOR<RecipeCreateWithoutProcessStepsInput, RecipeUncheckedCreateWithoutProcessStepsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutProcessStepsInput
    connect?: RecipeWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutProcessStepInput = {
    create?: XOR<InventoryCreateWithoutProcessStepInput, InventoryUncheckedCreateWithoutProcessStepInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutProcessStepInput
    connect?: InventoryWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutProcessStepsInput = {
    create?: XOR<LocationCreateWithoutProcessStepsInput, LocationUncheckedCreateWithoutProcessStepsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutProcessStepsInput
    connect?: LocationWhereUniqueInput
  }

  export type ResourceCreateNestedManyWithoutProcessStepInput = {
    create?: XOR<ResourceCreateWithoutProcessStepInput, ResourceUncheckedCreateWithoutProcessStepInput> | ResourceCreateWithoutProcessStepInput[] | ResourceUncheckedCreateWithoutProcessStepInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutProcessStepInput | ResourceCreateOrConnectWithoutProcessStepInput[]
    createMany?: ResourceCreateManyProcessStepInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type SensorCreateNestedManyWithoutProcessStepInput = {
    create?: XOR<SensorCreateWithoutProcessStepInput, SensorUncheckedCreateWithoutProcessStepInput> | SensorCreateWithoutProcessStepInput[] | SensorUncheckedCreateWithoutProcessStepInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutProcessStepInput | SensorCreateOrConnectWithoutProcessStepInput[]
    createMany?: SensorCreateManyProcessStepInputEnvelope
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
  }

  export type TransportSystemCreateNestedManyWithoutEndStepInput = {
    create?: XOR<TransportSystemCreateWithoutEndStepInput, TransportSystemUncheckedCreateWithoutEndStepInput> | TransportSystemCreateWithoutEndStepInput[] | TransportSystemUncheckedCreateWithoutEndStepInput[]
    connectOrCreate?: TransportSystemCreateOrConnectWithoutEndStepInput | TransportSystemCreateOrConnectWithoutEndStepInput[]
    createMany?: TransportSystemCreateManyEndStepInputEnvelope
    connect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
  }

  export type TransportSystemCreateNestedManyWithoutStartStepInput = {
    create?: XOR<TransportSystemCreateWithoutStartStepInput, TransportSystemUncheckedCreateWithoutStartStepInput> | TransportSystemCreateWithoutStartStepInput[] | TransportSystemUncheckedCreateWithoutStartStepInput[]
    connectOrCreate?: TransportSystemCreateOrConnectWithoutStartStepInput | TransportSystemCreateOrConnectWithoutStartStepInput[]
    createMany?: TransportSystemCreateManyStartStepInputEnvelope
    connect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutProcessStepsInput = {
    create?: XOR<OrderCreateWithoutProcessStepsInput, OrderUncheckedCreateWithoutProcessStepsInput> | OrderCreateWithoutProcessStepsInput[] | OrderUncheckedCreateWithoutProcessStepsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProcessStepsInput | OrderCreateOrConnectWithoutProcessStepsInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutProcessStepInput = {
    create?: XOR<ResourceCreateWithoutProcessStepInput, ResourceUncheckedCreateWithoutProcessStepInput> | ResourceCreateWithoutProcessStepInput[] | ResourceUncheckedCreateWithoutProcessStepInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutProcessStepInput | ResourceCreateOrConnectWithoutProcessStepInput[]
    createMany?: ResourceCreateManyProcessStepInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type SensorUncheckedCreateNestedManyWithoutProcessStepInput = {
    create?: XOR<SensorCreateWithoutProcessStepInput, SensorUncheckedCreateWithoutProcessStepInput> | SensorCreateWithoutProcessStepInput[] | SensorUncheckedCreateWithoutProcessStepInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutProcessStepInput | SensorCreateOrConnectWithoutProcessStepInput[]
    createMany?: SensorCreateManyProcessStepInputEnvelope
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
  }

  export type TransportSystemUncheckedCreateNestedManyWithoutEndStepInput = {
    create?: XOR<TransportSystemCreateWithoutEndStepInput, TransportSystemUncheckedCreateWithoutEndStepInput> | TransportSystemCreateWithoutEndStepInput[] | TransportSystemUncheckedCreateWithoutEndStepInput[]
    connectOrCreate?: TransportSystemCreateOrConnectWithoutEndStepInput | TransportSystemCreateOrConnectWithoutEndStepInput[]
    createMany?: TransportSystemCreateManyEndStepInputEnvelope
    connect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
  }

  export type TransportSystemUncheckedCreateNestedManyWithoutStartStepInput = {
    create?: XOR<TransportSystemCreateWithoutStartStepInput, TransportSystemUncheckedCreateWithoutStartStepInput> | TransportSystemCreateWithoutStartStepInput[] | TransportSystemUncheckedCreateWithoutStartStepInput[]
    connectOrCreate?: TransportSystemCreateOrConnectWithoutStartStepInput | TransportSystemCreateOrConnectWithoutStartStepInput[]
    createMany?: TransportSystemCreateManyStartStepInputEnvelope
    connect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderUpdateManyWithoutProcessStepsNestedInput = {
    create?: XOR<OrderCreateWithoutProcessStepsInput, OrderUncheckedCreateWithoutProcessStepsInput> | OrderCreateWithoutProcessStepsInput[] | OrderUncheckedCreateWithoutProcessStepsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProcessStepsInput | OrderCreateOrConnectWithoutProcessStepsInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutProcessStepsInput | OrderUpsertWithWhereUniqueWithoutProcessStepsInput[]
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutProcessStepsInput | OrderUpdateWithWhereUniqueWithoutProcessStepsInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutProcessStepsInput | OrderUpdateManyWithWhereWithoutProcessStepsInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type RecipeUpdateOneWithoutProcessStepsNestedInput = {
    create?: XOR<RecipeCreateWithoutProcessStepsInput, RecipeUncheckedCreateWithoutProcessStepsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutProcessStepsInput
    upsert?: RecipeUpsertWithoutProcessStepsInput
    disconnect?: RecipeWhereInput | boolean
    delete?: RecipeWhereInput | boolean
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutProcessStepsInput, RecipeUpdateWithoutProcessStepsInput>, RecipeUncheckedUpdateWithoutProcessStepsInput>
  }

  export type InventoryUpdateOneRequiredWithoutProcessStepNestedInput = {
    create?: XOR<InventoryCreateWithoutProcessStepInput, InventoryUncheckedCreateWithoutProcessStepInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutProcessStepInput
    upsert?: InventoryUpsertWithoutProcessStepInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutProcessStepInput, InventoryUpdateWithoutProcessStepInput>, InventoryUncheckedUpdateWithoutProcessStepInput>
  }

  export type LocationUpdateOneRequiredWithoutProcessStepsNestedInput = {
    create?: XOR<LocationCreateWithoutProcessStepsInput, LocationUncheckedCreateWithoutProcessStepsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutProcessStepsInput
    upsert?: LocationUpsertWithoutProcessStepsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutProcessStepsInput, LocationUpdateWithoutProcessStepsInput>, LocationUncheckedUpdateWithoutProcessStepsInput>
  }

  export type ResourceUpdateManyWithoutProcessStepNestedInput = {
    create?: XOR<ResourceCreateWithoutProcessStepInput, ResourceUncheckedCreateWithoutProcessStepInput> | ResourceCreateWithoutProcessStepInput[] | ResourceUncheckedCreateWithoutProcessStepInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutProcessStepInput | ResourceCreateOrConnectWithoutProcessStepInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutProcessStepInput | ResourceUpsertWithWhereUniqueWithoutProcessStepInput[]
    createMany?: ResourceCreateManyProcessStepInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutProcessStepInput | ResourceUpdateWithWhereUniqueWithoutProcessStepInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutProcessStepInput | ResourceUpdateManyWithWhereWithoutProcessStepInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type SensorUpdateManyWithoutProcessStepNestedInput = {
    create?: XOR<SensorCreateWithoutProcessStepInput, SensorUncheckedCreateWithoutProcessStepInput> | SensorCreateWithoutProcessStepInput[] | SensorUncheckedCreateWithoutProcessStepInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutProcessStepInput | SensorCreateOrConnectWithoutProcessStepInput[]
    upsert?: SensorUpsertWithWhereUniqueWithoutProcessStepInput | SensorUpsertWithWhereUniqueWithoutProcessStepInput[]
    createMany?: SensorCreateManyProcessStepInputEnvelope
    set?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    disconnect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    delete?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    update?: SensorUpdateWithWhereUniqueWithoutProcessStepInput | SensorUpdateWithWhereUniqueWithoutProcessStepInput[]
    updateMany?: SensorUpdateManyWithWhereWithoutProcessStepInput | SensorUpdateManyWithWhereWithoutProcessStepInput[]
    deleteMany?: SensorScalarWhereInput | SensorScalarWhereInput[]
  }

  export type TransportSystemUpdateManyWithoutEndStepNestedInput = {
    create?: XOR<TransportSystemCreateWithoutEndStepInput, TransportSystemUncheckedCreateWithoutEndStepInput> | TransportSystemCreateWithoutEndStepInput[] | TransportSystemUncheckedCreateWithoutEndStepInput[]
    connectOrCreate?: TransportSystemCreateOrConnectWithoutEndStepInput | TransportSystemCreateOrConnectWithoutEndStepInput[]
    upsert?: TransportSystemUpsertWithWhereUniqueWithoutEndStepInput | TransportSystemUpsertWithWhereUniqueWithoutEndStepInput[]
    createMany?: TransportSystemCreateManyEndStepInputEnvelope
    set?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    disconnect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    delete?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    connect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    update?: TransportSystemUpdateWithWhereUniqueWithoutEndStepInput | TransportSystemUpdateWithWhereUniqueWithoutEndStepInput[]
    updateMany?: TransportSystemUpdateManyWithWhereWithoutEndStepInput | TransportSystemUpdateManyWithWhereWithoutEndStepInput[]
    deleteMany?: TransportSystemScalarWhereInput | TransportSystemScalarWhereInput[]
  }

  export type TransportSystemUpdateManyWithoutStartStepNestedInput = {
    create?: XOR<TransportSystemCreateWithoutStartStepInput, TransportSystemUncheckedCreateWithoutStartStepInput> | TransportSystemCreateWithoutStartStepInput[] | TransportSystemUncheckedCreateWithoutStartStepInput[]
    connectOrCreate?: TransportSystemCreateOrConnectWithoutStartStepInput | TransportSystemCreateOrConnectWithoutStartStepInput[]
    upsert?: TransportSystemUpsertWithWhereUniqueWithoutStartStepInput | TransportSystemUpsertWithWhereUniqueWithoutStartStepInput[]
    createMany?: TransportSystemCreateManyStartStepInputEnvelope
    set?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    disconnect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    delete?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    connect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    update?: TransportSystemUpdateWithWhereUniqueWithoutStartStepInput | TransportSystemUpdateWithWhereUniqueWithoutStartStepInput[]
    updateMany?: TransportSystemUpdateManyWithWhereWithoutStartStepInput | TransportSystemUpdateManyWithWhereWithoutStartStepInput[]
    deleteMany?: TransportSystemScalarWhereInput | TransportSystemScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutProcessStepsNestedInput = {
    create?: XOR<OrderCreateWithoutProcessStepsInput, OrderUncheckedCreateWithoutProcessStepsInput> | OrderCreateWithoutProcessStepsInput[] | OrderUncheckedCreateWithoutProcessStepsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProcessStepsInput | OrderCreateOrConnectWithoutProcessStepsInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutProcessStepsInput | OrderUpsertWithWhereUniqueWithoutProcessStepsInput[]
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutProcessStepsInput | OrderUpdateWithWhereUniqueWithoutProcessStepsInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutProcessStepsInput | OrderUpdateManyWithWhereWithoutProcessStepsInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutProcessStepNestedInput = {
    create?: XOR<ResourceCreateWithoutProcessStepInput, ResourceUncheckedCreateWithoutProcessStepInput> | ResourceCreateWithoutProcessStepInput[] | ResourceUncheckedCreateWithoutProcessStepInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutProcessStepInput | ResourceCreateOrConnectWithoutProcessStepInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutProcessStepInput | ResourceUpsertWithWhereUniqueWithoutProcessStepInput[]
    createMany?: ResourceCreateManyProcessStepInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutProcessStepInput | ResourceUpdateWithWhereUniqueWithoutProcessStepInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutProcessStepInput | ResourceUpdateManyWithWhereWithoutProcessStepInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type SensorUncheckedUpdateManyWithoutProcessStepNestedInput = {
    create?: XOR<SensorCreateWithoutProcessStepInput, SensorUncheckedCreateWithoutProcessStepInput> | SensorCreateWithoutProcessStepInput[] | SensorUncheckedCreateWithoutProcessStepInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutProcessStepInput | SensorCreateOrConnectWithoutProcessStepInput[]
    upsert?: SensorUpsertWithWhereUniqueWithoutProcessStepInput | SensorUpsertWithWhereUniqueWithoutProcessStepInput[]
    createMany?: SensorCreateManyProcessStepInputEnvelope
    set?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    disconnect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    delete?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    update?: SensorUpdateWithWhereUniqueWithoutProcessStepInput | SensorUpdateWithWhereUniqueWithoutProcessStepInput[]
    updateMany?: SensorUpdateManyWithWhereWithoutProcessStepInput | SensorUpdateManyWithWhereWithoutProcessStepInput[]
    deleteMany?: SensorScalarWhereInput | SensorScalarWhereInput[]
  }

  export type TransportSystemUncheckedUpdateManyWithoutEndStepNestedInput = {
    create?: XOR<TransportSystemCreateWithoutEndStepInput, TransportSystemUncheckedCreateWithoutEndStepInput> | TransportSystemCreateWithoutEndStepInput[] | TransportSystemUncheckedCreateWithoutEndStepInput[]
    connectOrCreate?: TransportSystemCreateOrConnectWithoutEndStepInput | TransportSystemCreateOrConnectWithoutEndStepInput[]
    upsert?: TransportSystemUpsertWithWhereUniqueWithoutEndStepInput | TransportSystemUpsertWithWhereUniqueWithoutEndStepInput[]
    createMany?: TransportSystemCreateManyEndStepInputEnvelope
    set?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    disconnect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    delete?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    connect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    update?: TransportSystemUpdateWithWhereUniqueWithoutEndStepInput | TransportSystemUpdateWithWhereUniqueWithoutEndStepInput[]
    updateMany?: TransportSystemUpdateManyWithWhereWithoutEndStepInput | TransportSystemUpdateManyWithWhereWithoutEndStepInput[]
    deleteMany?: TransportSystemScalarWhereInput | TransportSystemScalarWhereInput[]
  }

  export type TransportSystemUncheckedUpdateManyWithoutStartStepNestedInput = {
    create?: XOR<TransportSystemCreateWithoutStartStepInput, TransportSystemUncheckedCreateWithoutStartStepInput> | TransportSystemCreateWithoutStartStepInput[] | TransportSystemUncheckedCreateWithoutStartStepInput[]
    connectOrCreate?: TransportSystemCreateOrConnectWithoutStartStepInput | TransportSystemCreateOrConnectWithoutStartStepInput[]
    upsert?: TransportSystemUpsertWithWhereUniqueWithoutStartStepInput | TransportSystemUpsertWithWhereUniqueWithoutStartStepInput[]
    createMany?: TransportSystemCreateManyStartStepInputEnvelope
    set?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    disconnect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    delete?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    connect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    update?: TransportSystemUpdateWithWhereUniqueWithoutStartStepInput | TransportSystemUpdateWithWhereUniqueWithoutStartStepInput[]
    updateMany?: TransportSystemUpdateManyWithWhereWithoutStartStepInput | TransportSystemUpdateManyWithWhereWithoutStartStepInput[]
    deleteMany?: TransportSystemScalarWhereInput | TransportSystemScalarWhereInput[]
  }

  export type ProcessStepCreateNestedManyWithoutRecipeInput = {
    create?: XOR<ProcessStepCreateWithoutRecipeInput, ProcessStepUncheckedCreateWithoutRecipeInput> | ProcessStepCreateWithoutRecipeInput[] | ProcessStepUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutRecipeInput | ProcessStepCreateOrConnectWithoutRecipeInput[]
    createMany?: ProcessStepCreateManyRecipeInputEnvelope
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
  }

  export type RecipeInputCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeInputCreateWithoutRecipeInput, RecipeInputUncheckedCreateWithoutRecipeInput> | RecipeInputCreateWithoutRecipeInput[] | RecipeInputUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeInputCreateOrConnectWithoutRecipeInput | RecipeInputCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeInputCreateManyRecipeInputEnvelope
    connect?: RecipeInputWhereUniqueInput | RecipeInputWhereUniqueInput[]
  }

  export type RecipeOutputCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeOutputCreateWithoutRecipeInput, RecipeOutputUncheckedCreateWithoutRecipeInput> | RecipeOutputCreateWithoutRecipeInput[] | RecipeOutputUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeOutputCreateOrConnectWithoutRecipeInput | RecipeOutputCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeOutputCreateManyRecipeInputEnvelope
    connect?: RecipeOutputWhereUniqueInput | RecipeOutputWhereUniqueInput[]
  }

  export type ProcessStepUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<ProcessStepCreateWithoutRecipeInput, ProcessStepUncheckedCreateWithoutRecipeInput> | ProcessStepCreateWithoutRecipeInput[] | ProcessStepUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutRecipeInput | ProcessStepCreateOrConnectWithoutRecipeInput[]
    createMany?: ProcessStepCreateManyRecipeInputEnvelope
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
  }

  export type RecipeInputUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeInputCreateWithoutRecipeInput, RecipeInputUncheckedCreateWithoutRecipeInput> | RecipeInputCreateWithoutRecipeInput[] | RecipeInputUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeInputCreateOrConnectWithoutRecipeInput | RecipeInputCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeInputCreateManyRecipeInputEnvelope
    connect?: RecipeInputWhereUniqueInput | RecipeInputWhereUniqueInput[]
  }

  export type RecipeOutputUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeOutputCreateWithoutRecipeInput, RecipeOutputUncheckedCreateWithoutRecipeInput> | RecipeOutputCreateWithoutRecipeInput[] | RecipeOutputUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeOutputCreateOrConnectWithoutRecipeInput | RecipeOutputCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeOutputCreateManyRecipeInputEnvelope
    connect?: RecipeOutputWhereUniqueInput | RecipeOutputWhereUniqueInput[]
  }

  export type ProcessStepUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<ProcessStepCreateWithoutRecipeInput, ProcessStepUncheckedCreateWithoutRecipeInput> | ProcessStepCreateWithoutRecipeInput[] | ProcessStepUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutRecipeInput | ProcessStepCreateOrConnectWithoutRecipeInput[]
    upsert?: ProcessStepUpsertWithWhereUniqueWithoutRecipeInput | ProcessStepUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: ProcessStepCreateManyRecipeInputEnvelope
    set?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    disconnect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    delete?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    update?: ProcessStepUpdateWithWhereUniqueWithoutRecipeInput | ProcessStepUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: ProcessStepUpdateManyWithWhereWithoutRecipeInput | ProcessStepUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
  }

  export type RecipeInputUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeInputCreateWithoutRecipeInput, RecipeInputUncheckedCreateWithoutRecipeInput> | RecipeInputCreateWithoutRecipeInput[] | RecipeInputUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeInputCreateOrConnectWithoutRecipeInput | RecipeInputCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeInputUpsertWithWhereUniqueWithoutRecipeInput | RecipeInputUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeInputCreateManyRecipeInputEnvelope
    set?: RecipeInputWhereUniqueInput | RecipeInputWhereUniqueInput[]
    disconnect?: RecipeInputWhereUniqueInput | RecipeInputWhereUniqueInput[]
    delete?: RecipeInputWhereUniqueInput | RecipeInputWhereUniqueInput[]
    connect?: RecipeInputWhereUniqueInput | RecipeInputWhereUniqueInput[]
    update?: RecipeInputUpdateWithWhereUniqueWithoutRecipeInput | RecipeInputUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeInputUpdateManyWithWhereWithoutRecipeInput | RecipeInputUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeInputScalarWhereInput | RecipeInputScalarWhereInput[]
  }

  export type RecipeOutputUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeOutputCreateWithoutRecipeInput, RecipeOutputUncheckedCreateWithoutRecipeInput> | RecipeOutputCreateWithoutRecipeInput[] | RecipeOutputUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeOutputCreateOrConnectWithoutRecipeInput | RecipeOutputCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeOutputUpsertWithWhereUniqueWithoutRecipeInput | RecipeOutputUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeOutputCreateManyRecipeInputEnvelope
    set?: RecipeOutputWhereUniqueInput | RecipeOutputWhereUniqueInput[]
    disconnect?: RecipeOutputWhereUniqueInput | RecipeOutputWhereUniqueInput[]
    delete?: RecipeOutputWhereUniqueInput | RecipeOutputWhereUniqueInput[]
    connect?: RecipeOutputWhereUniqueInput | RecipeOutputWhereUniqueInput[]
    update?: RecipeOutputUpdateWithWhereUniqueWithoutRecipeInput | RecipeOutputUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeOutputUpdateManyWithWhereWithoutRecipeInput | RecipeOutputUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeOutputScalarWhereInput | RecipeOutputScalarWhereInput[]
  }

  export type ProcessStepUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<ProcessStepCreateWithoutRecipeInput, ProcessStepUncheckedCreateWithoutRecipeInput> | ProcessStepCreateWithoutRecipeInput[] | ProcessStepUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutRecipeInput | ProcessStepCreateOrConnectWithoutRecipeInput[]
    upsert?: ProcessStepUpsertWithWhereUniqueWithoutRecipeInput | ProcessStepUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: ProcessStepCreateManyRecipeInputEnvelope
    set?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    disconnect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    delete?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    update?: ProcessStepUpdateWithWhereUniqueWithoutRecipeInput | ProcessStepUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: ProcessStepUpdateManyWithWhereWithoutRecipeInput | ProcessStepUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
  }

  export type RecipeInputUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeInputCreateWithoutRecipeInput, RecipeInputUncheckedCreateWithoutRecipeInput> | RecipeInputCreateWithoutRecipeInput[] | RecipeInputUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeInputCreateOrConnectWithoutRecipeInput | RecipeInputCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeInputUpsertWithWhereUniqueWithoutRecipeInput | RecipeInputUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeInputCreateManyRecipeInputEnvelope
    set?: RecipeInputWhereUniqueInput | RecipeInputWhereUniqueInput[]
    disconnect?: RecipeInputWhereUniqueInput | RecipeInputWhereUniqueInput[]
    delete?: RecipeInputWhereUniqueInput | RecipeInputWhereUniqueInput[]
    connect?: RecipeInputWhereUniqueInput | RecipeInputWhereUniqueInput[]
    update?: RecipeInputUpdateWithWhereUniqueWithoutRecipeInput | RecipeInputUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeInputUpdateManyWithWhereWithoutRecipeInput | RecipeInputUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeInputScalarWhereInput | RecipeInputScalarWhereInput[]
  }

  export type RecipeOutputUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeOutputCreateWithoutRecipeInput, RecipeOutputUncheckedCreateWithoutRecipeInput> | RecipeOutputCreateWithoutRecipeInput[] | RecipeOutputUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeOutputCreateOrConnectWithoutRecipeInput | RecipeOutputCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeOutputUpsertWithWhereUniqueWithoutRecipeInput | RecipeOutputUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeOutputCreateManyRecipeInputEnvelope
    set?: RecipeOutputWhereUniqueInput | RecipeOutputWhereUniqueInput[]
    disconnect?: RecipeOutputWhereUniqueInput | RecipeOutputWhereUniqueInput[]
    delete?: RecipeOutputWhereUniqueInput | RecipeOutputWhereUniqueInput[]
    connect?: RecipeOutputWhereUniqueInput | RecipeOutputWhereUniqueInput[]
    update?: RecipeOutputUpdateWithWhereUniqueWithoutRecipeInput | RecipeOutputUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeOutputUpdateManyWithWhereWithoutRecipeInput | RecipeOutputUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeOutputScalarWhereInput | RecipeOutputScalarWhereInput[]
  }

  export type RecipeCreateNestedOneWithoutInputsInput = {
    create?: XOR<RecipeCreateWithoutInputsInput, RecipeUncheckedCreateWithoutInputsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutInputsInput
    connect?: RecipeWhereUniqueInput
  }

  export type RecipeUpdateOneWithoutInputsNestedInput = {
    create?: XOR<RecipeCreateWithoutInputsInput, RecipeUncheckedCreateWithoutInputsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutInputsInput
    upsert?: RecipeUpsertWithoutInputsInput
    disconnect?: RecipeWhereInput | boolean
    delete?: RecipeWhereInput | boolean
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutInputsInput, RecipeUpdateWithoutInputsInput>, RecipeUncheckedUpdateWithoutInputsInput>
  }

  export type RecipeCreateNestedOneWithoutOutputsInput = {
    create?: XOR<RecipeCreateWithoutOutputsInput, RecipeUncheckedCreateWithoutOutputsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutOutputsInput
    connect?: RecipeWhereUniqueInput
  }

  export type RecipeUpdateOneWithoutOutputsNestedInput = {
    create?: XOR<RecipeCreateWithoutOutputsInput, RecipeUncheckedCreateWithoutOutputsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutOutputsInput
    upsert?: RecipeUpsertWithoutOutputsInput
    disconnect?: RecipeWhereInput | boolean
    delete?: RecipeWhereInput | boolean
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutOutputsInput, RecipeUpdateWithoutOutputsInput>, RecipeUncheckedUpdateWithoutOutputsInput>
  }

  export type SensorCreateNestedOneWithoutLogEntriesInput = {
    create?: XOR<SensorCreateWithoutLogEntriesInput, SensorUncheckedCreateWithoutLogEntriesInput>
    connectOrCreate?: SensorCreateOrConnectWithoutLogEntriesInput
    connect?: SensorWhereUniqueInput
  }

  export type SensorUpdateOneWithoutLogEntriesNestedInput = {
    create?: XOR<SensorCreateWithoutLogEntriesInput, SensorUncheckedCreateWithoutLogEntriesInput>
    connectOrCreate?: SensorCreateOrConnectWithoutLogEntriesInput
    upsert?: SensorUpsertWithoutLogEntriesInput
    disconnect?: SensorWhereInput | boolean
    delete?: SensorWhereInput | boolean
    connect?: SensorWhereUniqueInput
    update?: XOR<XOR<SensorUpdateToOneWithWhereWithoutLogEntriesInput, SensorUpdateWithoutLogEntriesInput>, SensorUncheckedUpdateWithoutLogEntriesInput>
  }

  export type ProcessStepCreateNestedOneWithoutSensorsInput = {
    create?: XOR<ProcessStepCreateWithoutSensorsInput, ProcessStepUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutSensorsInput
    connect?: ProcessStepWhereUniqueInput
  }

  export type TransportSystemCreateNestedOneWithoutSensorsInput = {
    create?: XOR<TransportSystemCreateWithoutSensorsInput, TransportSystemUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: TransportSystemCreateOrConnectWithoutSensorsInput
    connect?: TransportSystemWhereUniqueInput
  }

  export type LogEntryCreateNestedManyWithoutSensorInput = {
    create?: XOR<LogEntryCreateWithoutSensorInput, LogEntryUncheckedCreateWithoutSensorInput> | LogEntryCreateWithoutSensorInput[] | LogEntryUncheckedCreateWithoutSensorInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutSensorInput | LogEntryCreateOrConnectWithoutSensorInput[]
    createMany?: LogEntryCreateManySensorInputEnvelope
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
  }

  export type LogEntryUncheckedCreateNestedManyWithoutSensorInput = {
    create?: XOR<LogEntryCreateWithoutSensorInput, LogEntryUncheckedCreateWithoutSensorInput> | LogEntryCreateWithoutSensorInput[] | LogEntryUncheckedCreateWithoutSensorInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutSensorInput | LogEntryCreateOrConnectWithoutSensorInput[]
    createMany?: LogEntryCreateManySensorInputEnvelope
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
  }

  export type ProcessStepUpdateOneWithoutSensorsNestedInput = {
    create?: XOR<ProcessStepCreateWithoutSensorsInput, ProcessStepUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutSensorsInput
    upsert?: ProcessStepUpsertWithoutSensorsInput
    disconnect?: ProcessStepWhereInput | boolean
    delete?: ProcessStepWhereInput | boolean
    connect?: ProcessStepWhereUniqueInput
    update?: XOR<XOR<ProcessStepUpdateToOneWithWhereWithoutSensorsInput, ProcessStepUpdateWithoutSensorsInput>, ProcessStepUncheckedUpdateWithoutSensorsInput>
  }

  export type TransportSystemUpdateOneWithoutSensorsNestedInput = {
    create?: XOR<TransportSystemCreateWithoutSensorsInput, TransportSystemUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: TransportSystemCreateOrConnectWithoutSensorsInput
    upsert?: TransportSystemUpsertWithoutSensorsInput
    disconnect?: TransportSystemWhereInput | boolean
    delete?: TransportSystemWhereInput | boolean
    connect?: TransportSystemWhereUniqueInput
    update?: XOR<XOR<TransportSystemUpdateToOneWithWhereWithoutSensorsInput, TransportSystemUpdateWithoutSensorsInput>, TransportSystemUncheckedUpdateWithoutSensorsInput>
  }

  export type LogEntryUpdateManyWithoutSensorNestedInput = {
    create?: XOR<LogEntryCreateWithoutSensorInput, LogEntryUncheckedCreateWithoutSensorInput> | LogEntryCreateWithoutSensorInput[] | LogEntryUncheckedCreateWithoutSensorInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutSensorInput | LogEntryCreateOrConnectWithoutSensorInput[]
    upsert?: LogEntryUpsertWithWhereUniqueWithoutSensorInput | LogEntryUpsertWithWhereUniqueWithoutSensorInput[]
    createMany?: LogEntryCreateManySensorInputEnvelope
    set?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    disconnect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    delete?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    update?: LogEntryUpdateWithWhereUniqueWithoutSensorInput | LogEntryUpdateWithWhereUniqueWithoutSensorInput[]
    updateMany?: LogEntryUpdateManyWithWhereWithoutSensorInput | LogEntryUpdateManyWithWhereWithoutSensorInput[]
    deleteMany?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
  }

  export type LogEntryUncheckedUpdateManyWithoutSensorNestedInput = {
    create?: XOR<LogEntryCreateWithoutSensorInput, LogEntryUncheckedCreateWithoutSensorInput> | LogEntryCreateWithoutSensorInput[] | LogEntryUncheckedCreateWithoutSensorInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutSensorInput | LogEntryCreateOrConnectWithoutSensorInput[]
    upsert?: LogEntryUpsertWithWhereUniqueWithoutSensorInput | LogEntryUpsertWithWhereUniqueWithoutSensorInput[]
    createMany?: LogEntryCreateManySensorInputEnvelope
    set?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    disconnect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    delete?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    update?: LogEntryUpdateWithWhereUniqueWithoutSensorInput | LogEntryUpdateWithWhereUniqueWithoutSensorInput[]
    updateMany?: LogEntryUpdateManyWithWhereWithoutSensorInput | LogEntryUpdateManyWithWhereWithoutSensorInput[]
    deleteMany?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
  }

  export type FilterCreateNestedOneWithoutEntriesInput = {
    create?: XOR<FilterCreateWithoutEntriesInput, FilterUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: FilterCreateOrConnectWithoutEntriesInput
    connect?: FilterWhereUniqueInput
  }

  export type FilterUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<FilterCreateWithoutEntriesInput, FilterUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: FilterCreateOrConnectWithoutEntriesInput
    upsert?: FilterUpsertWithoutEntriesInput
    connect?: FilterWhereUniqueInput
    update?: XOR<XOR<FilterUpdateToOneWithWhereWithoutEntriesInput, FilterUpdateWithoutEntriesInput>, FilterUncheckedUpdateWithoutEntriesInput>
  }

  export type TransportSystemCreateNestedOneWithoutFilterInput = {
    create?: XOR<TransportSystemCreateWithoutFilterInput, TransportSystemUncheckedCreateWithoutFilterInput>
    connectOrCreate?: TransportSystemCreateOrConnectWithoutFilterInput
    connect?: TransportSystemWhereUniqueInput
  }

  export type FilterEntryCreateNestedManyWithoutFilterInput = {
    create?: XOR<FilterEntryCreateWithoutFilterInput, FilterEntryUncheckedCreateWithoutFilterInput> | FilterEntryCreateWithoutFilterInput[] | FilterEntryUncheckedCreateWithoutFilterInput[]
    connectOrCreate?: FilterEntryCreateOrConnectWithoutFilterInput | FilterEntryCreateOrConnectWithoutFilterInput[]
    createMany?: FilterEntryCreateManyFilterInputEnvelope
    connect?: FilterEntryWhereUniqueInput | FilterEntryWhereUniqueInput[]
  }

  export type FilterEntryUncheckedCreateNestedManyWithoutFilterInput = {
    create?: XOR<FilterEntryCreateWithoutFilterInput, FilterEntryUncheckedCreateWithoutFilterInput> | FilterEntryCreateWithoutFilterInput[] | FilterEntryUncheckedCreateWithoutFilterInput[]
    connectOrCreate?: FilterEntryCreateOrConnectWithoutFilterInput | FilterEntryCreateOrConnectWithoutFilterInput[]
    createMany?: FilterEntryCreateManyFilterInputEnvelope
    connect?: FilterEntryWhereUniqueInput | FilterEntryWhereUniqueInput[]
  }

  export type TransportSystemUpdateOneRequiredWithoutFilterNestedInput = {
    create?: XOR<TransportSystemCreateWithoutFilterInput, TransportSystemUncheckedCreateWithoutFilterInput>
    connectOrCreate?: TransportSystemCreateOrConnectWithoutFilterInput
    upsert?: TransportSystemUpsertWithoutFilterInput
    connect?: TransportSystemWhereUniqueInput
    update?: XOR<XOR<TransportSystemUpdateToOneWithWhereWithoutFilterInput, TransportSystemUpdateWithoutFilterInput>, TransportSystemUncheckedUpdateWithoutFilterInput>
  }

  export type FilterEntryUpdateManyWithoutFilterNestedInput = {
    create?: XOR<FilterEntryCreateWithoutFilterInput, FilterEntryUncheckedCreateWithoutFilterInput> | FilterEntryCreateWithoutFilterInput[] | FilterEntryUncheckedCreateWithoutFilterInput[]
    connectOrCreate?: FilterEntryCreateOrConnectWithoutFilterInput | FilterEntryCreateOrConnectWithoutFilterInput[]
    upsert?: FilterEntryUpsertWithWhereUniqueWithoutFilterInput | FilterEntryUpsertWithWhereUniqueWithoutFilterInput[]
    createMany?: FilterEntryCreateManyFilterInputEnvelope
    set?: FilterEntryWhereUniqueInput | FilterEntryWhereUniqueInput[]
    disconnect?: FilterEntryWhereUniqueInput | FilterEntryWhereUniqueInput[]
    delete?: FilterEntryWhereUniqueInput | FilterEntryWhereUniqueInput[]
    connect?: FilterEntryWhereUniqueInput | FilterEntryWhereUniqueInput[]
    update?: FilterEntryUpdateWithWhereUniqueWithoutFilterInput | FilterEntryUpdateWithWhereUniqueWithoutFilterInput[]
    updateMany?: FilterEntryUpdateManyWithWhereWithoutFilterInput | FilterEntryUpdateManyWithWhereWithoutFilterInput[]
    deleteMany?: FilterEntryScalarWhereInput | FilterEntryScalarWhereInput[]
  }

  export type FilterEntryUncheckedUpdateManyWithoutFilterNestedInput = {
    create?: XOR<FilterEntryCreateWithoutFilterInput, FilterEntryUncheckedCreateWithoutFilterInput> | FilterEntryCreateWithoutFilterInput[] | FilterEntryUncheckedCreateWithoutFilterInput[]
    connectOrCreate?: FilterEntryCreateOrConnectWithoutFilterInput | FilterEntryCreateOrConnectWithoutFilterInput[]
    upsert?: FilterEntryUpsertWithWhereUniqueWithoutFilterInput | FilterEntryUpsertWithWhereUniqueWithoutFilterInput[]
    createMany?: FilterEntryCreateManyFilterInputEnvelope
    set?: FilterEntryWhereUniqueInput | FilterEntryWhereUniqueInput[]
    disconnect?: FilterEntryWhereUniqueInput | FilterEntryWhereUniqueInput[]
    delete?: FilterEntryWhereUniqueInput | FilterEntryWhereUniqueInput[]
    connect?: FilterEntryWhereUniqueInput | FilterEntryWhereUniqueInput[]
    update?: FilterEntryUpdateWithWhereUniqueWithoutFilterInput | FilterEntryUpdateWithWhereUniqueWithoutFilterInput[]
    updateMany?: FilterEntryUpdateManyWithWhereWithoutFilterInput | FilterEntryUpdateManyWithWhereWithoutFilterInput[]
    deleteMany?: FilterEntryScalarWhereInput | FilterEntryScalarWhereInput[]
  }

  export type ProcessStepCreateNestedOneWithoutInputsInput = {
    create?: XOR<ProcessStepCreateWithoutInputsInput, ProcessStepUncheckedCreateWithoutInputsInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutInputsInput
    connect?: ProcessStepWhereUniqueInput
  }

  export type ProcessStepCreateNestedOneWithoutOutputsInput = {
    create?: XOR<ProcessStepCreateWithoutOutputsInput, ProcessStepUncheckedCreateWithoutOutputsInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutOutputsInput
    connect?: ProcessStepWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutTransportSystemInput = {
    create?: XOR<InventoryCreateWithoutTransportSystemInput, InventoryUncheckedCreateWithoutTransportSystemInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutTransportSystemInput
    connect?: InventoryWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutTransportSystemsInput = {
    create?: XOR<OrderCreateWithoutTransportSystemsInput, OrderUncheckedCreateWithoutTransportSystemsInput> | OrderCreateWithoutTransportSystemsInput[] | OrderUncheckedCreateWithoutTransportSystemsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTransportSystemsInput | OrderCreateOrConnectWithoutTransportSystemsInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type FilterCreateNestedOneWithoutTransportSystemInput = {
    create?: XOR<FilterCreateWithoutTransportSystemInput, FilterUncheckedCreateWithoutTransportSystemInput>
    connectOrCreate?: FilterCreateOrConnectWithoutTransportSystemInput
    connect?: FilterWhereUniqueInput
  }

  export type SensorCreateNestedManyWithoutTransportSystemInput = {
    create?: XOR<SensorCreateWithoutTransportSystemInput, SensorUncheckedCreateWithoutTransportSystemInput> | SensorCreateWithoutTransportSystemInput[] | SensorUncheckedCreateWithoutTransportSystemInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutTransportSystemInput | SensorCreateOrConnectWithoutTransportSystemInput[]
    createMany?: SensorCreateManyTransportSystemInputEnvelope
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
  }

  export type ResourceCreateNestedManyWithoutTransportSystemInput = {
    create?: XOR<ResourceCreateWithoutTransportSystemInput, ResourceUncheckedCreateWithoutTransportSystemInput> | ResourceCreateWithoutTransportSystemInput[] | ResourceUncheckedCreateWithoutTransportSystemInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutTransportSystemInput | ResourceCreateOrConnectWithoutTransportSystemInput[]
    createMany?: ResourceCreateManyTransportSystemInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutTransportSystemsInput = {
    create?: XOR<OrderCreateWithoutTransportSystemsInput, OrderUncheckedCreateWithoutTransportSystemsInput> | OrderCreateWithoutTransportSystemsInput[] | OrderUncheckedCreateWithoutTransportSystemsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTransportSystemsInput | OrderCreateOrConnectWithoutTransportSystemsInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type FilterUncheckedCreateNestedOneWithoutTransportSystemInput = {
    create?: XOR<FilterCreateWithoutTransportSystemInput, FilterUncheckedCreateWithoutTransportSystemInput>
    connectOrCreate?: FilterCreateOrConnectWithoutTransportSystemInput
    connect?: FilterWhereUniqueInput
  }

  export type SensorUncheckedCreateNestedManyWithoutTransportSystemInput = {
    create?: XOR<SensorCreateWithoutTransportSystemInput, SensorUncheckedCreateWithoutTransportSystemInput> | SensorCreateWithoutTransportSystemInput[] | SensorUncheckedCreateWithoutTransportSystemInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutTransportSystemInput | SensorCreateOrConnectWithoutTransportSystemInput[]
    createMany?: SensorCreateManyTransportSystemInputEnvelope
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutTransportSystemInput = {
    create?: XOR<ResourceCreateWithoutTransportSystemInput, ResourceUncheckedCreateWithoutTransportSystemInput> | ResourceCreateWithoutTransportSystemInput[] | ResourceUncheckedCreateWithoutTransportSystemInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutTransportSystemInput | ResourceCreateOrConnectWithoutTransportSystemInput[]
    createMany?: ResourceCreateManyTransportSystemInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type ProcessStepUpdateOneWithoutInputsNestedInput = {
    create?: XOR<ProcessStepCreateWithoutInputsInput, ProcessStepUncheckedCreateWithoutInputsInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutInputsInput
    upsert?: ProcessStepUpsertWithoutInputsInput
    disconnect?: ProcessStepWhereInput | boolean
    delete?: ProcessStepWhereInput | boolean
    connect?: ProcessStepWhereUniqueInput
    update?: XOR<XOR<ProcessStepUpdateToOneWithWhereWithoutInputsInput, ProcessStepUpdateWithoutInputsInput>, ProcessStepUncheckedUpdateWithoutInputsInput>
  }

  export type ProcessStepUpdateOneWithoutOutputsNestedInput = {
    create?: XOR<ProcessStepCreateWithoutOutputsInput, ProcessStepUncheckedCreateWithoutOutputsInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutOutputsInput
    upsert?: ProcessStepUpsertWithoutOutputsInput
    disconnect?: ProcessStepWhereInput | boolean
    delete?: ProcessStepWhereInput | boolean
    connect?: ProcessStepWhereUniqueInput
    update?: XOR<XOR<ProcessStepUpdateToOneWithWhereWithoutOutputsInput, ProcessStepUpdateWithoutOutputsInput>, ProcessStepUncheckedUpdateWithoutOutputsInput>
  }

  export type InventoryUpdateOneRequiredWithoutTransportSystemNestedInput = {
    create?: XOR<InventoryCreateWithoutTransportSystemInput, InventoryUncheckedCreateWithoutTransportSystemInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutTransportSystemInput
    upsert?: InventoryUpsertWithoutTransportSystemInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutTransportSystemInput, InventoryUpdateWithoutTransportSystemInput>, InventoryUncheckedUpdateWithoutTransportSystemInput>
  }

  export type OrderUpdateManyWithoutTransportSystemsNestedInput = {
    create?: XOR<OrderCreateWithoutTransportSystemsInput, OrderUncheckedCreateWithoutTransportSystemsInput> | OrderCreateWithoutTransportSystemsInput[] | OrderUncheckedCreateWithoutTransportSystemsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTransportSystemsInput | OrderCreateOrConnectWithoutTransportSystemsInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutTransportSystemsInput | OrderUpsertWithWhereUniqueWithoutTransportSystemsInput[]
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutTransportSystemsInput | OrderUpdateWithWhereUniqueWithoutTransportSystemsInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutTransportSystemsInput | OrderUpdateManyWithWhereWithoutTransportSystemsInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type FilterUpdateOneWithoutTransportSystemNestedInput = {
    create?: XOR<FilterCreateWithoutTransportSystemInput, FilterUncheckedCreateWithoutTransportSystemInput>
    connectOrCreate?: FilterCreateOrConnectWithoutTransportSystemInput
    upsert?: FilterUpsertWithoutTransportSystemInput
    disconnect?: FilterWhereInput | boolean
    delete?: FilterWhereInput | boolean
    connect?: FilterWhereUniqueInput
    update?: XOR<XOR<FilterUpdateToOneWithWhereWithoutTransportSystemInput, FilterUpdateWithoutTransportSystemInput>, FilterUncheckedUpdateWithoutTransportSystemInput>
  }

  export type SensorUpdateManyWithoutTransportSystemNestedInput = {
    create?: XOR<SensorCreateWithoutTransportSystemInput, SensorUncheckedCreateWithoutTransportSystemInput> | SensorCreateWithoutTransportSystemInput[] | SensorUncheckedCreateWithoutTransportSystemInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutTransportSystemInput | SensorCreateOrConnectWithoutTransportSystemInput[]
    upsert?: SensorUpsertWithWhereUniqueWithoutTransportSystemInput | SensorUpsertWithWhereUniqueWithoutTransportSystemInput[]
    createMany?: SensorCreateManyTransportSystemInputEnvelope
    set?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    disconnect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    delete?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    update?: SensorUpdateWithWhereUniqueWithoutTransportSystemInput | SensorUpdateWithWhereUniqueWithoutTransportSystemInput[]
    updateMany?: SensorUpdateManyWithWhereWithoutTransportSystemInput | SensorUpdateManyWithWhereWithoutTransportSystemInput[]
    deleteMany?: SensorScalarWhereInput | SensorScalarWhereInput[]
  }

  export type ResourceUpdateManyWithoutTransportSystemNestedInput = {
    create?: XOR<ResourceCreateWithoutTransportSystemInput, ResourceUncheckedCreateWithoutTransportSystemInput> | ResourceCreateWithoutTransportSystemInput[] | ResourceUncheckedCreateWithoutTransportSystemInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutTransportSystemInput | ResourceCreateOrConnectWithoutTransportSystemInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutTransportSystemInput | ResourceUpsertWithWhereUniqueWithoutTransportSystemInput[]
    createMany?: ResourceCreateManyTransportSystemInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutTransportSystemInput | ResourceUpdateWithWhereUniqueWithoutTransportSystemInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutTransportSystemInput | ResourceUpdateManyWithWhereWithoutTransportSystemInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutTransportSystemsNestedInput = {
    create?: XOR<OrderCreateWithoutTransportSystemsInput, OrderUncheckedCreateWithoutTransportSystemsInput> | OrderCreateWithoutTransportSystemsInput[] | OrderUncheckedCreateWithoutTransportSystemsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTransportSystemsInput | OrderCreateOrConnectWithoutTransportSystemsInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutTransportSystemsInput | OrderUpsertWithWhereUniqueWithoutTransportSystemsInput[]
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutTransportSystemsInput | OrderUpdateWithWhereUniqueWithoutTransportSystemsInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutTransportSystemsInput | OrderUpdateManyWithWhereWithoutTransportSystemsInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type FilterUncheckedUpdateOneWithoutTransportSystemNestedInput = {
    create?: XOR<FilterCreateWithoutTransportSystemInput, FilterUncheckedCreateWithoutTransportSystemInput>
    connectOrCreate?: FilterCreateOrConnectWithoutTransportSystemInput
    upsert?: FilterUpsertWithoutTransportSystemInput
    disconnect?: FilterWhereInput | boolean
    delete?: FilterWhereInput | boolean
    connect?: FilterWhereUniqueInput
    update?: XOR<XOR<FilterUpdateToOneWithWhereWithoutTransportSystemInput, FilterUpdateWithoutTransportSystemInput>, FilterUncheckedUpdateWithoutTransportSystemInput>
  }

  export type SensorUncheckedUpdateManyWithoutTransportSystemNestedInput = {
    create?: XOR<SensorCreateWithoutTransportSystemInput, SensorUncheckedCreateWithoutTransportSystemInput> | SensorCreateWithoutTransportSystemInput[] | SensorUncheckedCreateWithoutTransportSystemInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutTransportSystemInput | SensorCreateOrConnectWithoutTransportSystemInput[]
    upsert?: SensorUpsertWithWhereUniqueWithoutTransportSystemInput | SensorUpsertWithWhereUniqueWithoutTransportSystemInput[]
    createMany?: SensorCreateManyTransportSystemInputEnvelope
    set?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    disconnect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    delete?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    update?: SensorUpdateWithWhereUniqueWithoutTransportSystemInput | SensorUpdateWithWhereUniqueWithoutTransportSystemInput[]
    updateMany?: SensorUpdateManyWithWhereWithoutTransportSystemInput | SensorUpdateManyWithWhereWithoutTransportSystemInput[]
    deleteMany?: SensorScalarWhereInput | SensorScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutTransportSystemNestedInput = {
    create?: XOR<ResourceCreateWithoutTransportSystemInput, ResourceUncheckedCreateWithoutTransportSystemInput> | ResourceCreateWithoutTransportSystemInput[] | ResourceUncheckedCreateWithoutTransportSystemInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutTransportSystemInput | ResourceCreateOrConnectWithoutTransportSystemInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutTransportSystemInput | ResourceUpsertWithWhereUniqueWithoutTransportSystemInput[]
    createMany?: ResourceCreateManyTransportSystemInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutTransportSystemInput | ResourceUpdateWithWhereUniqueWithoutTransportSystemInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutTransportSystemInput | ResourceUpdateManyWithWhereWithoutTransportSystemInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type InventoryEntryCreateNestedManyWithoutOrderInput = {
    create?: XOR<InventoryEntryCreateWithoutOrderInput, InventoryEntryUncheckedCreateWithoutOrderInput> | InventoryEntryCreateWithoutOrderInput[] | InventoryEntryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InventoryEntryCreateOrConnectWithoutOrderInput | InventoryEntryCreateOrConnectWithoutOrderInput[]
    createMany?: InventoryEntryCreateManyOrderInputEnvelope
    connect?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
  }

  export type ProcessStepCreateNestedManyWithoutOrdersInput = {
    create?: XOR<ProcessStepCreateWithoutOrdersInput, ProcessStepUncheckedCreateWithoutOrdersInput> | ProcessStepCreateWithoutOrdersInput[] | ProcessStepUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutOrdersInput | ProcessStepCreateOrConnectWithoutOrdersInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
  }

  export type TransportSystemCreateNestedManyWithoutOrdersInput = {
    create?: XOR<TransportSystemCreateWithoutOrdersInput, TransportSystemUncheckedCreateWithoutOrdersInput> | TransportSystemCreateWithoutOrdersInput[] | TransportSystemUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: TransportSystemCreateOrConnectWithoutOrdersInput | TransportSystemCreateOrConnectWithoutOrdersInput[]
    connect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
  }

  export type InventoryEntryUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<InventoryEntryCreateWithoutOrderInput, InventoryEntryUncheckedCreateWithoutOrderInput> | InventoryEntryCreateWithoutOrderInput[] | InventoryEntryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InventoryEntryCreateOrConnectWithoutOrderInput | InventoryEntryCreateOrConnectWithoutOrderInput[]
    createMany?: InventoryEntryCreateManyOrderInputEnvelope
    connect?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
  }

  export type ProcessStepUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<ProcessStepCreateWithoutOrdersInput, ProcessStepUncheckedCreateWithoutOrdersInput> | ProcessStepCreateWithoutOrdersInput[] | ProcessStepUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutOrdersInput | ProcessStepCreateOrConnectWithoutOrdersInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
  }

  export type TransportSystemUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<TransportSystemCreateWithoutOrdersInput, TransportSystemUncheckedCreateWithoutOrdersInput> | TransportSystemCreateWithoutOrdersInput[] | TransportSystemUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: TransportSystemCreateOrConnectWithoutOrdersInput | TransportSystemCreateOrConnectWithoutOrdersInput[]
    connect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type InventoryEntryUpdateManyWithoutOrderNestedInput = {
    create?: XOR<InventoryEntryCreateWithoutOrderInput, InventoryEntryUncheckedCreateWithoutOrderInput> | InventoryEntryCreateWithoutOrderInput[] | InventoryEntryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InventoryEntryCreateOrConnectWithoutOrderInput | InventoryEntryCreateOrConnectWithoutOrderInput[]
    upsert?: InventoryEntryUpsertWithWhereUniqueWithoutOrderInput | InventoryEntryUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: InventoryEntryCreateManyOrderInputEnvelope
    set?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    disconnect?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    delete?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    connect?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    update?: InventoryEntryUpdateWithWhereUniqueWithoutOrderInput | InventoryEntryUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: InventoryEntryUpdateManyWithWhereWithoutOrderInput | InventoryEntryUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: InventoryEntryScalarWhereInput | InventoryEntryScalarWhereInput[]
  }

  export type ProcessStepUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<ProcessStepCreateWithoutOrdersInput, ProcessStepUncheckedCreateWithoutOrdersInput> | ProcessStepCreateWithoutOrdersInput[] | ProcessStepUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutOrdersInput | ProcessStepCreateOrConnectWithoutOrdersInput[]
    upsert?: ProcessStepUpsertWithWhereUniqueWithoutOrdersInput | ProcessStepUpsertWithWhereUniqueWithoutOrdersInput[]
    set?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    disconnect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    delete?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    update?: ProcessStepUpdateWithWhereUniqueWithoutOrdersInput | ProcessStepUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: ProcessStepUpdateManyWithWhereWithoutOrdersInput | ProcessStepUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
  }

  export type TransportSystemUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<TransportSystemCreateWithoutOrdersInput, TransportSystemUncheckedCreateWithoutOrdersInput> | TransportSystemCreateWithoutOrdersInput[] | TransportSystemUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: TransportSystemCreateOrConnectWithoutOrdersInput | TransportSystemCreateOrConnectWithoutOrdersInput[]
    upsert?: TransportSystemUpsertWithWhereUniqueWithoutOrdersInput | TransportSystemUpsertWithWhereUniqueWithoutOrdersInput[]
    set?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    disconnect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    delete?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    connect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    update?: TransportSystemUpdateWithWhereUniqueWithoutOrdersInput | TransportSystemUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: TransportSystemUpdateManyWithWhereWithoutOrdersInput | TransportSystemUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: TransportSystemScalarWhereInput | TransportSystemScalarWhereInput[]
  }

  export type InventoryEntryUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<InventoryEntryCreateWithoutOrderInput, InventoryEntryUncheckedCreateWithoutOrderInput> | InventoryEntryCreateWithoutOrderInput[] | InventoryEntryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InventoryEntryCreateOrConnectWithoutOrderInput | InventoryEntryCreateOrConnectWithoutOrderInput[]
    upsert?: InventoryEntryUpsertWithWhereUniqueWithoutOrderInput | InventoryEntryUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: InventoryEntryCreateManyOrderInputEnvelope
    set?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    disconnect?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    delete?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    connect?: InventoryEntryWhereUniqueInput | InventoryEntryWhereUniqueInput[]
    update?: InventoryEntryUpdateWithWhereUniqueWithoutOrderInput | InventoryEntryUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: InventoryEntryUpdateManyWithWhereWithoutOrderInput | InventoryEntryUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: InventoryEntryScalarWhereInput | InventoryEntryScalarWhereInput[]
  }

  export type ProcessStepUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<ProcessStepCreateWithoutOrdersInput, ProcessStepUncheckedCreateWithoutOrdersInput> | ProcessStepCreateWithoutOrdersInput[] | ProcessStepUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutOrdersInput | ProcessStepCreateOrConnectWithoutOrdersInput[]
    upsert?: ProcessStepUpsertWithWhereUniqueWithoutOrdersInput | ProcessStepUpsertWithWhereUniqueWithoutOrdersInput[]
    set?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    disconnect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    delete?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    update?: ProcessStepUpdateWithWhereUniqueWithoutOrdersInput | ProcessStepUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: ProcessStepUpdateManyWithWhereWithoutOrdersInput | ProcessStepUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
  }

  export type TransportSystemUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<TransportSystemCreateWithoutOrdersInput, TransportSystemUncheckedCreateWithoutOrdersInput> | TransportSystemCreateWithoutOrdersInput[] | TransportSystemUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: TransportSystemCreateOrConnectWithoutOrdersInput | TransportSystemCreateOrConnectWithoutOrdersInput[]
    upsert?: TransportSystemUpsertWithWhereUniqueWithoutOrdersInput | TransportSystemUpsertWithWhereUniqueWithoutOrdersInput[]
    set?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    disconnect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    delete?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    connect?: TransportSystemWhereUniqueInput | TransportSystemWhereUniqueInput[]
    update?: TransportSystemUpdateWithWhereUniqueWithoutOrdersInput | TransportSystemUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: TransportSystemUpdateManyWithWhereWithoutOrdersInput | TransportSystemUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: TransportSystemScalarWhereInput | TransportSystemScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type KpiRecordCreateWithoutSimulationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    key: string
    value: number
    name?: string | null
  }

  export type KpiRecordUncheckedCreateWithoutSimulationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    key: string
    value: number
    name?: string | null
  }

  export type KpiRecordCreateOrConnectWithoutSimulationInput = {
    where: KpiRecordWhereUniqueInput
    create: XOR<KpiRecordCreateWithoutSimulationInput, KpiRecordUncheckedCreateWithoutSimulationInput>
  }

  export type KpiRecordCreateManySimulationInputEnvelope = {
    data: KpiRecordCreateManySimulationInput | KpiRecordCreateManySimulationInput[]
  }

  export type KpiRecordUpsertWithWhereUniqueWithoutSimulationInput = {
    where: KpiRecordWhereUniqueInput
    update: XOR<KpiRecordUpdateWithoutSimulationInput, KpiRecordUncheckedUpdateWithoutSimulationInput>
    create: XOR<KpiRecordCreateWithoutSimulationInput, KpiRecordUncheckedCreateWithoutSimulationInput>
  }

  export type KpiRecordUpdateWithWhereUniqueWithoutSimulationInput = {
    where: KpiRecordWhereUniqueInput
    data: XOR<KpiRecordUpdateWithoutSimulationInput, KpiRecordUncheckedUpdateWithoutSimulationInput>
  }

  export type KpiRecordUpdateManyWithWhereWithoutSimulationInput = {
    where: KpiRecordScalarWhereInput
    data: XOR<KpiRecordUpdateManyMutationInput, KpiRecordUncheckedUpdateManyWithoutSimulationInput>
  }

  export type KpiRecordScalarWhereInput = {
    AND?: KpiRecordScalarWhereInput | KpiRecordScalarWhereInput[]
    OR?: KpiRecordScalarWhereInput[]
    NOT?: KpiRecordScalarWhereInput | KpiRecordScalarWhereInput[]
    id?: IntFilter<"KpiRecord"> | number
    createdAt?: DateTimeFilter<"KpiRecord"> | Date | string
    updatedAt?: DateTimeFilter<"KpiRecord"> | Date | string
    key?: StringFilter<"KpiRecord"> | string
    value?: FloatFilter<"KpiRecord"> | number
    name?: StringNullableFilter<"KpiRecord"> | string | null
    simulationId?: IntFilter<"KpiRecord"> | number
  }

  export type SimulationRecordCreateWithoutKpisInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
  }

  export type SimulationRecordUncheckedCreateWithoutKpisInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
  }

  export type SimulationRecordCreateOrConnectWithoutKpisInput = {
    where: SimulationRecordWhereUniqueInput
    create: XOR<SimulationRecordCreateWithoutKpisInput, SimulationRecordUncheckedCreateWithoutKpisInput>
  }

  export type SimulationRecordUpsertWithoutKpisInput = {
    update: XOR<SimulationRecordUpdateWithoutKpisInput, SimulationRecordUncheckedUpdateWithoutKpisInput>
    create: XOR<SimulationRecordCreateWithoutKpisInput, SimulationRecordUncheckedCreateWithoutKpisInput>
    where?: SimulationRecordWhereInput
  }

  export type SimulationRecordUpdateToOneWithWhereWithoutKpisInput = {
    where?: SimulationRecordWhereInput
    data: XOR<SimulationRecordUpdateWithoutKpisInput, SimulationRecordUncheckedUpdateWithoutKpisInput>
  }

  export type SimulationRecordUpdateWithoutKpisInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SimulationRecordUncheckedUpdateWithoutKpisInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MachineCreateWithoutResourceInput = {

  }

  export type MachineUncheckedCreateWithoutResourceInput = {
    id?: number
  }

  export type MachineCreateOrConnectWithoutResourceInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutResourceInput, MachineUncheckedCreateWithoutResourceInput>
  }

  export type ProcessStepCreateWithoutResourcesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    errorRate?: number | null
    orders?: OrderCreateNestedManyWithoutProcessStepsInput
    recipe?: RecipeCreateNestedOneWithoutProcessStepsInput
    inventory: InventoryCreateNestedOneWithoutProcessStepInput
    location: LocationCreateNestedOneWithoutProcessStepsInput
    sensors?: SensorCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemCreateNestedManyWithoutEndStepInput
    outputs?: TransportSystemCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepUncheckedCreateWithoutResourcesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    locationId: number
    inventoryId: number
    recipeId?: number | null
    errorRate?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutProcessStepsInput
    sensors?: SensorUncheckedCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemUncheckedCreateNestedManyWithoutEndStepInput
    outputs?: TransportSystemUncheckedCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepCreateOrConnectWithoutResourcesInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutResourcesInput, ProcessStepUncheckedCreateWithoutResourcesInput>
  }

  export type TransportSystemCreateWithoutResourcesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    minQuantity?: number | null
    transportDelay?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    endStep?: ProcessStepCreateNestedOneWithoutInputsInput
    startStep?: ProcessStepCreateNestedOneWithoutOutputsInput
    inventory: InventoryCreateNestedOneWithoutTransportSystemInput
    orders?: OrderCreateNestedManyWithoutTransportSystemsInput
    filter?: FilterCreateNestedOneWithoutTransportSystemInput
    sensors?: SensorCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemUncheckedCreateWithoutResourcesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    inventoryId: number
    minQuantity?: number | null
    transportDelay?: number | null
    startStepId?: number | null
    endStepId?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutTransportSystemsInput
    filter?: FilterUncheckedCreateNestedOneWithoutTransportSystemInput
    sensors?: SensorUncheckedCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemCreateOrConnectWithoutResourcesInput = {
    where: TransportSystemWhereUniqueInput
    create: XOR<TransportSystemCreateWithoutResourcesInput, TransportSystemUncheckedCreateWithoutResourcesInput>
  }

  export type LocationCreateWithoutResourcesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    processSteps?: ProcessStepCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutResourcesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutResourcesInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutResourcesInput, LocationUncheckedCreateWithoutResourcesInput>
  }

  export type WorkerCreateWithoutResourceInput = {
    workerNumber: string
    fullName: string
    address: string
    workerRoles?: WorkerRoleCreateNestedManyWithoutWorkersInput
  }

  export type WorkerUncheckedCreateWithoutResourceInput = {
    id?: number
    workerNumber: string
    fullName: string
    address: string
    workerRoles?: WorkerRoleUncheckedCreateNestedManyWithoutWorkersInput
  }

  export type WorkerCreateOrConnectWithoutResourceInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutResourceInput, WorkerUncheckedCreateWithoutResourceInput>
  }

  export type MachineUpsertWithoutResourceInput = {
    update: XOR<MachineUpdateWithoutResourceInput, MachineUncheckedUpdateWithoutResourceInput>
    create: XOR<MachineCreateWithoutResourceInput, MachineUncheckedCreateWithoutResourceInput>
    where?: MachineWhereInput
  }

  export type MachineUpdateToOneWithWhereWithoutResourceInput = {
    where?: MachineWhereInput
    data: XOR<MachineUpdateWithoutResourceInput, MachineUncheckedUpdateWithoutResourceInput>
  }

  export type MachineUpdateWithoutResourceInput = {

  }

  export type MachineUncheckedUpdateWithoutResourceInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessStepUpsertWithoutResourcesInput = {
    update: XOR<ProcessStepUpdateWithoutResourcesInput, ProcessStepUncheckedUpdateWithoutResourcesInput>
    create: XOR<ProcessStepCreateWithoutResourcesInput, ProcessStepUncheckedCreateWithoutResourcesInput>
    where?: ProcessStepWhereInput
  }

  export type ProcessStepUpdateToOneWithWhereWithoutResourcesInput = {
    where?: ProcessStepWhereInput
    data: XOR<ProcessStepUpdateWithoutResourcesInput, ProcessStepUncheckedUpdateWithoutResourcesInput>
  }

  export type ProcessStepUpdateWithoutResourcesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUpdateManyWithoutProcessStepsNestedInput
    recipe?: RecipeUpdateOneWithoutProcessStepsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutProcessStepNestedInput
    location?: LocationUpdateOneRequiredWithoutProcessStepsNestedInput
    sensors?: SensorUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUpdateManyWithoutEndStepNestedInput
    outputs?: TransportSystemUpdateManyWithoutStartStepNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutProcessStepsNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUncheckedUpdateManyWithoutEndStepNestedInput
    outputs?: TransportSystemUncheckedUpdateManyWithoutStartStepNestedInput
  }

  export type TransportSystemUpsertWithoutResourcesInput = {
    update: XOR<TransportSystemUpdateWithoutResourcesInput, TransportSystemUncheckedUpdateWithoutResourcesInput>
    create: XOR<TransportSystemCreateWithoutResourcesInput, TransportSystemUncheckedCreateWithoutResourcesInput>
    where?: TransportSystemWhereInput
  }

  export type TransportSystemUpdateToOneWithWhereWithoutResourcesInput = {
    where?: TransportSystemWhereInput
    data: XOR<TransportSystemUpdateWithoutResourcesInput, TransportSystemUncheckedUpdateWithoutResourcesInput>
  }

  export type TransportSystemUpdateWithoutResourcesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endStep?: ProcessStepUpdateOneWithoutInputsNestedInput
    startStep?: ProcessStepUpdateOneWithoutOutputsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutTransportSystemNestedInput
    orders?: OrderUpdateManyWithoutTransportSystemsNestedInput
    filter?: FilterUpdateOneWithoutTransportSystemNestedInput
    sensors?: SensorUpdateManyWithoutTransportSystemNestedInput
  }

  export type TransportSystemUncheckedUpdateWithoutResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    startStepId?: NullableIntFieldUpdateOperationsInput | number | null
    endStepId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutTransportSystemsNestedInput
    filter?: FilterUncheckedUpdateOneWithoutTransportSystemNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutTransportSystemNestedInput
  }

  export type LocationUpsertWithoutResourcesInput = {
    update: XOR<LocationUpdateWithoutResourcesInput, LocationUncheckedUpdateWithoutResourcesInput>
    create: XOR<LocationCreateWithoutResourcesInput, LocationUncheckedCreateWithoutResourcesInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutResourcesInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutResourcesInput, LocationUncheckedUpdateWithoutResourcesInput>
  }

  export type LocationUpdateWithoutResourcesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processSteps?: ProcessStepUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processSteps?: ProcessStepUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type WorkerUpsertWithoutResourceInput = {
    update: XOR<WorkerUpdateWithoutResourceInput, WorkerUncheckedUpdateWithoutResourceInput>
    create: XOR<WorkerCreateWithoutResourceInput, WorkerUncheckedCreateWithoutResourceInput>
    where?: WorkerWhereInput
  }

  export type WorkerUpdateToOneWithWhereWithoutResourceInput = {
    where?: WorkerWhereInput
    data: XOR<WorkerUpdateWithoutResourceInput, WorkerUncheckedUpdateWithoutResourceInput>
  }

  export type WorkerUpdateWithoutResourceInput = {
    workerNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    workerRoles?: WorkerRoleUpdateManyWithoutWorkersNestedInput
  }

  export type WorkerUncheckedUpdateWithoutResourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    workerNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    workerRoles?: WorkerRoleUncheckedUpdateManyWithoutWorkersNestedInput
  }

  export type ResourceCreateWithoutMachineInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    faulty?: boolean | null
    faultyRate?: number
    processStep?: ProcessStepCreateNestedOneWithoutResourcesInput
    transportSystem?: TransportSystemCreateNestedOneWithoutResourcesInput
    location: LocationCreateNestedOneWithoutResourcesInput
    Worker?: WorkerCreateNestedOneWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutMachineInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    locationId: number
    processStepId?: number | null
    transportSystemId?: number | null
    faulty?: boolean | null
    faultyRate?: number
    Worker?: WorkerUncheckedCreateNestedOneWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutMachineInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutMachineInput, ResourceUncheckedCreateWithoutMachineInput>
  }

  export type ResourceUpsertWithoutMachineInput = {
    update: XOR<ResourceUpdateWithoutMachineInput, ResourceUncheckedUpdateWithoutMachineInput>
    create: XOR<ResourceCreateWithoutMachineInput, ResourceUncheckedCreateWithoutMachineInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutMachineInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutMachineInput, ResourceUncheckedUpdateWithoutMachineInput>
  }

  export type ResourceUpdateWithoutMachineInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
    processStep?: ProcessStepUpdateOneWithoutResourcesNestedInput
    transportSystem?: TransportSystemUpdateOneWithoutResourcesNestedInput
    location?: LocationUpdateOneRequiredWithoutResourcesNestedInput
    Worker?: WorkerUpdateOneWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    locationId?: IntFieldUpdateOperationsInput | number
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
    Worker?: WorkerUncheckedUpdateOneWithoutResourceNestedInput
  }

  export type ResourceCreateWithoutWorkerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    faulty?: boolean | null
    faultyRate?: number
    Machine?: MachineCreateNestedOneWithoutResourceInput
    processStep?: ProcessStepCreateNestedOneWithoutResourcesInput
    transportSystem?: TransportSystemCreateNestedOneWithoutResourcesInput
    location: LocationCreateNestedOneWithoutResourcesInput
  }

  export type ResourceUncheckedCreateWithoutWorkerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    locationId: number
    processStepId?: number | null
    transportSystemId?: number | null
    faulty?: boolean | null
    faultyRate?: number
    Machine?: MachineUncheckedCreateNestedOneWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutWorkerInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutWorkerInput, ResourceUncheckedCreateWithoutWorkerInput>
  }

  export type WorkerRoleCreateWithoutWorkersInput = {
    name: string
    description?: string | null
  }

  export type WorkerRoleUncheckedCreateWithoutWorkersInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type WorkerRoleCreateOrConnectWithoutWorkersInput = {
    where: WorkerRoleWhereUniqueInput
    create: XOR<WorkerRoleCreateWithoutWorkersInput, WorkerRoleUncheckedCreateWithoutWorkersInput>
  }

  export type ResourceUpsertWithoutWorkerInput = {
    update: XOR<ResourceUpdateWithoutWorkerInput, ResourceUncheckedUpdateWithoutWorkerInput>
    create: XOR<ResourceCreateWithoutWorkerInput, ResourceUncheckedCreateWithoutWorkerInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutWorkerInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutWorkerInput, ResourceUncheckedUpdateWithoutWorkerInput>
  }

  export type ResourceUpdateWithoutWorkerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
    Machine?: MachineUpdateOneWithoutResourceNestedInput
    processStep?: ProcessStepUpdateOneWithoutResourcesNestedInput
    transportSystem?: TransportSystemUpdateOneWithoutResourcesNestedInput
    location?: LocationUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type ResourceUncheckedUpdateWithoutWorkerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    locationId?: IntFieldUpdateOperationsInput | number
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
    Machine?: MachineUncheckedUpdateOneWithoutResourceNestedInput
  }

  export type WorkerRoleUpsertWithWhereUniqueWithoutWorkersInput = {
    where: WorkerRoleWhereUniqueInput
    update: XOR<WorkerRoleUpdateWithoutWorkersInput, WorkerRoleUncheckedUpdateWithoutWorkersInput>
    create: XOR<WorkerRoleCreateWithoutWorkersInput, WorkerRoleUncheckedCreateWithoutWorkersInput>
  }

  export type WorkerRoleUpdateWithWhereUniqueWithoutWorkersInput = {
    where: WorkerRoleWhereUniqueInput
    data: XOR<WorkerRoleUpdateWithoutWorkersInput, WorkerRoleUncheckedUpdateWithoutWorkersInput>
  }

  export type WorkerRoleUpdateManyWithWhereWithoutWorkersInput = {
    where: WorkerRoleScalarWhereInput
    data: XOR<WorkerRoleUpdateManyMutationInput, WorkerRoleUncheckedUpdateManyWithoutWorkersInput>
  }

  export type WorkerRoleScalarWhereInput = {
    AND?: WorkerRoleScalarWhereInput | WorkerRoleScalarWhereInput[]
    OR?: WorkerRoleScalarWhereInput[]
    NOT?: WorkerRoleScalarWhereInput | WorkerRoleScalarWhereInput[]
    id?: IntFilter<"WorkerRole"> | number
    name?: StringFilter<"WorkerRole"> | string
    description?: StringNullableFilter<"WorkerRole"> | string | null
  }

  export type WorkerCreateWithoutWorkerRolesInput = {
    workerNumber: string
    fullName: string
    address: string
    resource: ResourceCreateNestedOneWithoutWorkerInput
  }

  export type WorkerUncheckedCreateWithoutWorkerRolesInput = {
    id?: number
    workerNumber: string
    fullName: string
    address: string
    resourceId: number
  }

  export type WorkerCreateOrConnectWithoutWorkerRolesInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutWorkerRolesInput, WorkerUncheckedCreateWithoutWorkerRolesInput>
  }

  export type WorkerUpsertWithWhereUniqueWithoutWorkerRolesInput = {
    where: WorkerWhereUniqueInput
    update: XOR<WorkerUpdateWithoutWorkerRolesInput, WorkerUncheckedUpdateWithoutWorkerRolesInput>
    create: XOR<WorkerCreateWithoutWorkerRolesInput, WorkerUncheckedCreateWithoutWorkerRolesInput>
  }

  export type WorkerUpdateWithWhereUniqueWithoutWorkerRolesInput = {
    where: WorkerWhereUniqueInput
    data: XOR<WorkerUpdateWithoutWorkerRolesInput, WorkerUncheckedUpdateWithoutWorkerRolesInput>
  }

  export type WorkerUpdateManyWithWhereWithoutWorkerRolesInput = {
    where: WorkerScalarWhereInput
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyWithoutWorkerRolesInput>
  }

  export type WorkerScalarWhereInput = {
    AND?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
    OR?: WorkerScalarWhereInput[]
    NOT?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
    id?: IntFilter<"Worker"> | number
    workerNumber?: StringFilter<"Worker"> | string
    fullName?: StringFilter<"Worker"> | string
    address?: StringFilter<"Worker"> | string
    resourceId?: IntFilter<"Worker"> | number
  }

  export type InventoryEntryCreateWithoutInventoryInput = {
    addedAt?: Date | string
    material: string
    Order?: OrderCreateNestedOneWithoutInventoryEntriesInput
  }

  export type InventoryEntryUncheckedCreateWithoutInventoryInput = {
    id?: number
    addedAt?: Date | string
    material: string
    orderId?: number | null
  }

  export type InventoryEntryCreateOrConnectWithoutInventoryInput = {
    where: InventoryEntryWhereUniqueInput
    create: XOR<InventoryEntryCreateWithoutInventoryInput, InventoryEntryUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryEntryCreateManyInventoryInputEnvelope = {
    data: InventoryEntryCreateManyInventoryInput | InventoryEntryCreateManyInventoryInput[]
  }

  export type ProcessStepCreateWithoutInventoryInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    errorRate?: number | null
    orders?: OrderCreateNestedManyWithoutProcessStepsInput
    recipe?: RecipeCreateNestedOneWithoutProcessStepsInput
    location: LocationCreateNestedOneWithoutProcessStepsInput
    resources?: ResourceCreateNestedManyWithoutProcessStepInput
    sensors?: SensorCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemCreateNestedManyWithoutEndStepInput
    outputs?: TransportSystemCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepUncheckedCreateWithoutInventoryInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    locationId: number
    recipeId?: number | null
    errorRate?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutProcessStepsInput
    resources?: ResourceUncheckedCreateNestedManyWithoutProcessStepInput
    sensors?: SensorUncheckedCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemUncheckedCreateNestedManyWithoutEndStepInput
    outputs?: TransportSystemUncheckedCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepCreateOrConnectWithoutInventoryInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutInventoryInput, ProcessStepUncheckedCreateWithoutInventoryInput>
  }

  export type TransportSystemCreateWithoutInventoryInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    minQuantity?: number | null
    transportDelay?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    endStep?: ProcessStepCreateNestedOneWithoutInputsInput
    startStep?: ProcessStepCreateNestedOneWithoutOutputsInput
    orders?: OrderCreateNestedManyWithoutTransportSystemsInput
    filter?: FilterCreateNestedOneWithoutTransportSystemInput
    sensors?: SensorCreateNestedManyWithoutTransportSystemInput
    resources?: ResourceCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemUncheckedCreateWithoutInventoryInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    minQuantity?: number | null
    transportDelay?: number | null
    startStepId?: number | null
    endStepId?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutTransportSystemsInput
    filter?: FilterUncheckedCreateNestedOneWithoutTransportSystemInput
    sensors?: SensorUncheckedCreateNestedManyWithoutTransportSystemInput
    resources?: ResourceUncheckedCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemCreateOrConnectWithoutInventoryInput = {
    where: TransportSystemWhereUniqueInput
    create: XOR<TransportSystemCreateWithoutInventoryInput, TransportSystemUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryEntryUpsertWithWhereUniqueWithoutInventoryInput = {
    where: InventoryEntryWhereUniqueInput
    update: XOR<InventoryEntryUpdateWithoutInventoryInput, InventoryEntryUncheckedUpdateWithoutInventoryInput>
    create: XOR<InventoryEntryCreateWithoutInventoryInput, InventoryEntryUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryEntryUpdateWithWhereUniqueWithoutInventoryInput = {
    where: InventoryEntryWhereUniqueInput
    data: XOR<InventoryEntryUpdateWithoutInventoryInput, InventoryEntryUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryEntryUpdateManyWithWhereWithoutInventoryInput = {
    where: InventoryEntryScalarWhereInput
    data: XOR<InventoryEntryUpdateManyMutationInput, InventoryEntryUncheckedUpdateManyWithoutInventoryInput>
  }

  export type InventoryEntryScalarWhereInput = {
    AND?: InventoryEntryScalarWhereInput | InventoryEntryScalarWhereInput[]
    OR?: InventoryEntryScalarWhereInput[]
    NOT?: InventoryEntryScalarWhereInput | InventoryEntryScalarWhereInput[]
    id?: IntFilter<"InventoryEntry"> | number
    addedAt?: DateTimeFilter<"InventoryEntry"> | Date | string
    material?: StringFilter<"InventoryEntry"> | string
    inventoryId?: IntFilter<"InventoryEntry"> | number
    orderId?: IntNullableFilter<"InventoryEntry"> | number | null
  }

  export type ProcessStepUpsertWithoutInventoryInput = {
    update: XOR<ProcessStepUpdateWithoutInventoryInput, ProcessStepUncheckedUpdateWithoutInventoryInput>
    create: XOR<ProcessStepCreateWithoutInventoryInput, ProcessStepUncheckedCreateWithoutInventoryInput>
    where?: ProcessStepWhereInput
  }

  export type ProcessStepUpdateToOneWithWhereWithoutInventoryInput = {
    where?: ProcessStepWhereInput
    data: XOR<ProcessStepUpdateWithoutInventoryInput, ProcessStepUncheckedUpdateWithoutInventoryInput>
  }

  export type ProcessStepUpdateWithoutInventoryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUpdateManyWithoutProcessStepsNestedInput
    recipe?: RecipeUpdateOneWithoutProcessStepsNestedInput
    location?: LocationUpdateOneRequiredWithoutProcessStepsNestedInput
    resources?: ResourceUpdateManyWithoutProcessStepNestedInput
    sensors?: SensorUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUpdateManyWithoutEndStepNestedInput
    outputs?: TransportSystemUpdateManyWithoutStartStepNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutProcessStepsNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutProcessStepNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUncheckedUpdateManyWithoutEndStepNestedInput
    outputs?: TransportSystemUncheckedUpdateManyWithoutStartStepNestedInput
  }

  export type TransportSystemUpsertWithoutInventoryInput = {
    update: XOR<TransportSystemUpdateWithoutInventoryInput, TransportSystemUncheckedUpdateWithoutInventoryInput>
    create: XOR<TransportSystemCreateWithoutInventoryInput, TransportSystemUncheckedCreateWithoutInventoryInput>
    where?: TransportSystemWhereInput
  }

  export type TransportSystemUpdateToOneWithWhereWithoutInventoryInput = {
    where?: TransportSystemWhereInput
    data: XOR<TransportSystemUpdateWithoutInventoryInput, TransportSystemUncheckedUpdateWithoutInventoryInput>
  }

  export type TransportSystemUpdateWithoutInventoryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endStep?: ProcessStepUpdateOneWithoutInputsNestedInput
    startStep?: ProcessStepUpdateOneWithoutOutputsNestedInput
    orders?: OrderUpdateManyWithoutTransportSystemsNestedInput
    filter?: FilterUpdateOneWithoutTransportSystemNestedInput
    sensors?: SensorUpdateManyWithoutTransportSystemNestedInput
    resources?: ResourceUpdateManyWithoutTransportSystemNestedInput
  }

  export type TransportSystemUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    startStepId?: NullableIntFieldUpdateOperationsInput | number | null
    endStepId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutTransportSystemsNestedInput
    filter?: FilterUncheckedUpdateOneWithoutTransportSystemNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutTransportSystemNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutTransportSystemNestedInput
  }

  export type InventoryCreateWithoutEntriesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    limit: number
    processStep?: ProcessStepCreateNestedOneWithoutInventoryInput
    transportSystem?: TransportSystemCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutEntriesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    limit: number
    processStep?: ProcessStepUncheckedCreateNestedOneWithoutInventoryInput
    transportSystem?: TransportSystemUncheckedCreateNestedOneWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutEntriesInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutEntriesInput, InventoryUncheckedCreateWithoutEntriesInput>
  }

  export type OrderCreateWithoutInventoryEntriesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    priority?: number
    dueDate?: Date | string | null
    description?: string | null
    quantity?: number
    startedAt?: Date | string | null
    startedTick?: number | null
    completedTick?: number | null
    completedAt?: Date | string | null
    canceledAt?: Date | string | null
    processSteps?: ProcessStepCreateNestedManyWithoutOrdersInput
    transportSystems?: TransportSystemCreateNestedManyWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutInventoryEntriesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    priority?: number
    dueDate?: Date | string | null
    description?: string | null
    quantity?: number
    startedAt?: Date | string | null
    startedTick?: number | null
    completedTick?: number | null
    completedAt?: Date | string | null
    canceledAt?: Date | string | null
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutOrdersInput
    transportSystems?: TransportSystemUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrderCreateOrConnectWithoutInventoryEntriesInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutInventoryEntriesInput, OrderUncheckedCreateWithoutInventoryEntriesInput>
  }

  export type InventoryUpsertWithoutEntriesInput = {
    update: XOR<InventoryUpdateWithoutEntriesInput, InventoryUncheckedUpdateWithoutEntriesInput>
    create: XOR<InventoryCreateWithoutEntriesInput, InventoryUncheckedCreateWithoutEntriesInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutEntriesInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutEntriesInput, InventoryUncheckedUpdateWithoutEntriesInput>
  }

  export type InventoryUpdateWithoutEntriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    limit?: IntFieldUpdateOperationsInput | number
    processStep?: ProcessStepUpdateOneWithoutInventoryNestedInput
    transportSystem?: TransportSystemUpdateOneWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    limit?: IntFieldUpdateOperationsInput | number
    processStep?: ProcessStepUncheckedUpdateOneWithoutInventoryNestedInput
    transportSystem?: TransportSystemUncheckedUpdateOneWithoutInventoryNestedInput
  }

  export type OrderUpsertWithoutInventoryEntriesInput = {
    update: XOR<OrderUpdateWithoutInventoryEntriesInput, OrderUncheckedUpdateWithoutInventoryEntriesInput>
    create: XOR<OrderCreateWithoutInventoryEntriesInput, OrderUncheckedCreateWithoutInventoryEntriesInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutInventoryEntriesInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutInventoryEntriesInput, OrderUncheckedUpdateWithoutInventoryEntriesInput>
  }

  export type OrderUpdateWithoutInventoryEntriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processSteps?: ProcessStepUpdateManyWithoutOrdersNestedInput
    transportSystems?: TransportSystemUpdateManyWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutInventoryEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processSteps?: ProcessStepUncheckedUpdateManyWithoutOrdersNestedInput
    transportSystems?: TransportSystemUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type ProcessStepCreateWithoutLocationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    errorRate?: number | null
    orders?: OrderCreateNestedManyWithoutProcessStepsInput
    recipe?: RecipeCreateNestedOneWithoutProcessStepsInput
    inventory: InventoryCreateNestedOneWithoutProcessStepInput
    resources?: ResourceCreateNestedManyWithoutProcessStepInput
    sensors?: SensorCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemCreateNestedManyWithoutEndStepInput
    outputs?: TransportSystemCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepUncheckedCreateWithoutLocationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    inventoryId: number
    recipeId?: number | null
    errorRate?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutProcessStepsInput
    resources?: ResourceUncheckedCreateNestedManyWithoutProcessStepInput
    sensors?: SensorUncheckedCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemUncheckedCreateNestedManyWithoutEndStepInput
    outputs?: TransportSystemUncheckedCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepCreateOrConnectWithoutLocationInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutLocationInput, ProcessStepUncheckedCreateWithoutLocationInput>
  }

  export type ProcessStepCreateManyLocationInputEnvelope = {
    data: ProcessStepCreateManyLocationInput | ProcessStepCreateManyLocationInput[]
  }

  export type ResourceCreateWithoutLocationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    faulty?: boolean | null
    faultyRate?: number
    Machine?: MachineCreateNestedOneWithoutResourceInput
    processStep?: ProcessStepCreateNestedOneWithoutResourcesInput
    transportSystem?: TransportSystemCreateNestedOneWithoutResourcesInput
    Worker?: WorkerCreateNestedOneWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutLocationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    processStepId?: number | null
    transportSystemId?: number | null
    faulty?: boolean | null
    faultyRate?: number
    Machine?: MachineUncheckedCreateNestedOneWithoutResourceInput
    Worker?: WorkerUncheckedCreateNestedOneWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutLocationInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutLocationInput, ResourceUncheckedCreateWithoutLocationInput>
  }

  export type ResourceCreateManyLocationInputEnvelope = {
    data: ResourceCreateManyLocationInput | ResourceCreateManyLocationInput[]
  }

  export type ProcessStepUpsertWithWhereUniqueWithoutLocationInput = {
    where: ProcessStepWhereUniqueInput
    update: XOR<ProcessStepUpdateWithoutLocationInput, ProcessStepUncheckedUpdateWithoutLocationInput>
    create: XOR<ProcessStepCreateWithoutLocationInput, ProcessStepUncheckedCreateWithoutLocationInput>
  }

  export type ProcessStepUpdateWithWhereUniqueWithoutLocationInput = {
    where: ProcessStepWhereUniqueInput
    data: XOR<ProcessStepUpdateWithoutLocationInput, ProcessStepUncheckedUpdateWithoutLocationInput>
  }

  export type ProcessStepUpdateManyWithWhereWithoutLocationInput = {
    where: ProcessStepScalarWhereInput
    data: XOR<ProcessStepUpdateManyMutationInput, ProcessStepUncheckedUpdateManyWithoutLocationInput>
  }

  export type ProcessStepScalarWhereInput = {
    AND?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
    OR?: ProcessStepScalarWhereInput[]
    NOT?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
    id?: IntFilter<"ProcessStep"> | number
    createdAt?: DateTimeFilter<"ProcessStep"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessStep"> | Date | string
    name?: StringFilter<"ProcessStep"> | string
    status?: StringFilter<"ProcessStep"> | string
    active?: BoolFilter<"ProcessStep"> | boolean
    inputSpeed?: IntFilter<"ProcessStep"> | number
    outputSpeed?: IntFilter<"ProcessStep"> | number
    recipeRate?: IntFilter<"ProcessStep"> | number
    duration?: IntFilter<"ProcessStep"> | number
    locationId?: IntFilter<"ProcessStep"> | number
    inventoryId?: IntFilter<"ProcessStep"> | number
    recipeId?: IntNullableFilter<"ProcessStep"> | number | null
    errorRate?: FloatNullableFilter<"ProcessStep"> | number | null
  }

  export type ResourceUpsertWithWhereUniqueWithoutLocationInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutLocationInput, ResourceUncheckedUpdateWithoutLocationInput>
    create: XOR<ResourceCreateWithoutLocationInput, ResourceUncheckedCreateWithoutLocationInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutLocationInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutLocationInput, ResourceUncheckedUpdateWithoutLocationInput>
  }

  export type ResourceUpdateManyWithWhereWithoutLocationInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutLocationInput>
  }

  export type ResourceScalarWhereInput = {
    AND?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    OR?: ResourceScalarWhereInput[]
    NOT?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    id?: IntFilter<"Resource"> | number
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    name?: StringNullableFilter<"Resource"> | string | null
    active?: BoolFilter<"Resource"> | boolean
    mandatory?: BoolFilter<"Resource"> | boolean
    productionResource?: BoolFilter<"Resource"> | boolean
    inventoryResource?: BoolFilter<"Resource"> | boolean
    locationId?: IntFilter<"Resource"> | number
    processStepId?: IntNullableFilter<"Resource"> | number | null
    transportSystemId?: IntNullableFilter<"Resource"> | number | null
    faulty?: BoolNullableFilter<"Resource"> | boolean | null
    faultyRate?: FloatFilter<"Resource"> | number
  }

  export type OrderCreateWithoutProcessStepsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    priority?: number
    dueDate?: Date | string | null
    description?: string | null
    quantity?: number
    startedAt?: Date | string | null
    startedTick?: number | null
    completedTick?: number | null
    completedAt?: Date | string | null
    canceledAt?: Date | string | null
    inventoryEntries?: InventoryEntryCreateNestedManyWithoutOrderInput
    transportSystems?: TransportSystemCreateNestedManyWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutProcessStepsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    priority?: number
    dueDate?: Date | string | null
    description?: string | null
    quantity?: number
    startedAt?: Date | string | null
    startedTick?: number | null
    completedTick?: number | null
    completedAt?: Date | string | null
    canceledAt?: Date | string | null
    inventoryEntries?: InventoryEntryUncheckedCreateNestedManyWithoutOrderInput
    transportSystems?: TransportSystemUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrderCreateOrConnectWithoutProcessStepsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutProcessStepsInput, OrderUncheckedCreateWithoutProcessStepsInput>
  }

  export type RecipeCreateWithoutProcessStepsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    inputs?: RecipeInputCreateNestedManyWithoutRecipeInput
    outputs?: RecipeOutputCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutProcessStepsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    inputs?: RecipeInputUncheckedCreateNestedManyWithoutRecipeInput
    outputs?: RecipeOutputUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutProcessStepsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutProcessStepsInput, RecipeUncheckedCreateWithoutProcessStepsInput>
  }

  export type InventoryCreateWithoutProcessStepInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    limit: number
    entries?: InventoryEntryCreateNestedManyWithoutInventoryInput
    transportSystem?: TransportSystemCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutProcessStepInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    limit: number
    entries?: InventoryEntryUncheckedCreateNestedManyWithoutInventoryInput
    transportSystem?: TransportSystemUncheckedCreateNestedOneWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutProcessStepInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutProcessStepInput, InventoryUncheckedCreateWithoutProcessStepInput>
  }

  export type LocationCreateWithoutProcessStepsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    resources?: ResourceCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutProcessStepsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    resources?: ResourceUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutProcessStepsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutProcessStepsInput, LocationUncheckedCreateWithoutProcessStepsInput>
  }

  export type ResourceCreateWithoutProcessStepInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    faulty?: boolean | null
    faultyRate?: number
    Machine?: MachineCreateNestedOneWithoutResourceInput
    transportSystem?: TransportSystemCreateNestedOneWithoutResourcesInput
    location: LocationCreateNestedOneWithoutResourcesInput
    Worker?: WorkerCreateNestedOneWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutProcessStepInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    locationId: number
    transportSystemId?: number | null
    faulty?: boolean | null
    faultyRate?: number
    Machine?: MachineUncheckedCreateNestedOneWithoutResourceInput
    Worker?: WorkerUncheckedCreateNestedOneWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutProcessStepInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutProcessStepInput, ResourceUncheckedCreateWithoutProcessStepInput>
  }

  export type ResourceCreateManyProcessStepInputEnvelope = {
    data: ResourceCreateManyProcessStepInput | ResourceCreateManyProcessStepInput[]
  }

  export type SensorCreateWithoutProcessStepInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: string
    value?: number
    sensorDelay?: number
    active?: boolean
    transportSystem?: TransportSystemCreateNestedOneWithoutSensorsInput
    logEntries?: LogEntryCreateNestedManyWithoutSensorInput
  }

  export type SensorUncheckedCreateWithoutProcessStepInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: string
    value?: number
    sensorDelay?: number
    active?: boolean
    transportSystemId?: number | null
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutSensorInput
  }

  export type SensorCreateOrConnectWithoutProcessStepInput = {
    where: SensorWhereUniqueInput
    create: XOR<SensorCreateWithoutProcessStepInput, SensorUncheckedCreateWithoutProcessStepInput>
  }

  export type SensorCreateManyProcessStepInputEnvelope = {
    data: SensorCreateManyProcessStepInput | SensorCreateManyProcessStepInput[]
  }

  export type TransportSystemCreateWithoutEndStepInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    minQuantity?: number | null
    transportDelay?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    startStep?: ProcessStepCreateNestedOneWithoutOutputsInput
    inventory: InventoryCreateNestedOneWithoutTransportSystemInput
    orders?: OrderCreateNestedManyWithoutTransportSystemsInput
    filter?: FilterCreateNestedOneWithoutTransportSystemInput
    sensors?: SensorCreateNestedManyWithoutTransportSystemInput
    resources?: ResourceCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemUncheckedCreateWithoutEndStepInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    inventoryId: number
    minQuantity?: number | null
    transportDelay?: number | null
    startStepId?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutTransportSystemsInput
    filter?: FilterUncheckedCreateNestedOneWithoutTransportSystemInput
    sensors?: SensorUncheckedCreateNestedManyWithoutTransportSystemInput
    resources?: ResourceUncheckedCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemCreateOrConnectWithoutEndStepInput = {
    where: TransportSystemWhereUniqueInput
    create: XOR<TransportSystemCreateWithoutEndStepInput, TransportSystemUncheckedCreateWithoutEndStepInput>
  }

  export type TransportSystemCreateManyEndStepInputEnvelope = {
    data: TransportSystemCreateManyEndStepInput | TransportSystemCreateManyEndStepInput[]
  }

  export type TransportSystemCreateWithoutStartStepInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    minQuantity?: number | null
    transportDelay?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    endStep?: ProcessStepCreateNestedOneWithoutInputsInput
    inventory: InventoryCreateNestedOneWithoutTransportSystemInput
    orders?: OrderCreateNestedManyWithoutTransportSystemsInput
    filter?: FilterCreateNestedOneWithoutTransportSystemInput
    sensors?: SensorCreateNestedManyWithoutTransportSystemInput
    resources?: ResourceCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemUncheckedCreateWithoutStartStepInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    inventoryId: number
    minQuantity?: number | null
    transportDelay?: number | null
    endStepId?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutTransportSystemsInput
    filter?: FilterUncheckedCreateNestedOneWithoutTransportSystemInput
    sensors?: SensorUncheckedCreateNestedManyWithoutTransportSystemInput
    resources?: ResourceUncheckedCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemCreateOrConnectWithoutStartStepInput = {
    where: TransportSystemWhereUniqueInput
    create: XOR<TransportSystemCreateWithoutStartStepInput, TransportSystemUncheckedCreateWithoutStartStepInput>
  }

  export type TransportSystemCreateManyStartStepInputEnvelope = {
    data: TransportSystemCreateManyStartStepInput | TransportSystemCreateManyStartStepInput[]
  }

  export type OrderUpsertWithWhereUniqueWithoutProcessStepsInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutProcessStepsInput, OrderUncheckedUpdateWithoutProcessStepsInput>
    create: XOR<OrderCreateWithoutProcessStepsInput, OrderUncheckedCreateWithoutProcessStepsInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutProcessStepsInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutProcessStepsInput, OrderUncheckedUpdateWithoutProcessStepsInput>
  }

  export type OrderUpdateManyWithWhereWithoutProcessStepsInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutProcessStepsInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    status?: StringFilter<"Order"> | string
    priority?: IntFilter<"Order"> | number
    dueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    description?: StringNullableFilter<"Order"> | string | null
    quantity?: IntFilter<"Order"> | number
    startedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    startedTick?: IntNullableFilter<"Order"> | number | null
    completedTick?: IntNullableFilter<"Order"> | number | null
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
  }

  export type RecipeUpsertWithoutProcessStepsInput = {
    update: XOR<RecipeUpdateWithoutProcessStepsInput, RecipeUncheckedUpdateWithoutProcessStepsInput>
    create: XOR<RecipeCreateWithoutProcessStepsInput, RecipeUncheckedCreateWithoutProcessStepsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutProcessStepsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutProcessStepsInput, RecipeUncheckedUpdateWithoutProcessStepsInput>
  }

  export type RecipeUpdateWithoutProcessStepsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    inputs?: RecipeInputUpdateManyWithoutRecipeNestedInput
    outputs?: RecipeOutputUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutProcessStepsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    inputs?: RecipeInputUncheckedUpdateManyWithoutRecipeNestedInput
    outputs?: RecipeOutputUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type InventoryUpsertWithoutProcessStepInput = {
    update: XOR<InventoryUpdateWithoutProcessStepInput, InventoryUncheckedUpdateWithoutProcessStepInput>
    create: XOR<InventoryCreateWithoutProcessStepInput, InventoryUncheckedCreateWithoutProcessStepInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutProcessStepInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutProcessStepInput, InventoryUncheckedUpdateWithoutProcessStepInput>
  }

  export type InventoryUpdateWithoutProcessStepInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    limit?: IntFieldUpdateOperationsInput | number
    entries?: InventoryEntryUpdateManyWithoutInventoryNestedInput
    transportSystem?: TransportSystemUpdateOneWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutProcessStepInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    limit?: IntFieldUpdateOperationsInput | number
    entries?: InventoryEntryUncheckedUpdateManyWithoutInventoryNestedInput
    transportSystem?: TransportSystemUncheckedUpdateOneWithoutInventoryNestedInput
  }

  export type LocationUpsertWithoutProcessStepsInput = {
    update: XOR<LocationUpdateWithoutProcessStepsInput, LocationUncheckedUpdateWithoutProcessStepsInput>
    create: XOR<LocationCreateWithoutProcessStepsInput, LocationUncheckedCreateWithoutProcessStepsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutProcessStepsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutProcessStepsInput, LocationUncheckedUpdateWithoutProcessStepsInput>
  }

  export type LocationUpdateWithoutProcessStepsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: ResourceUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutProcessStepsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: ResourceUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type ResourceUpsertWithWhereUniqueWithoutProcessStepInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutProcessStepInput, ResourceUncheckedUpdateWithoutProcessStepInput>
    create: XOR<ResourceCreateWithoutProcessStepInput, ResourceUncheckedCreateWithoutProcessStepInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutProcessStepInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutProcessStepInput, ResourceUncheckedUpdateWithoutProcessStepInput>
  }

  export type ResourceUpdateManyWithWhereWithoutProcessStepInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutProcessStepInput>
  }

  export type SensorUpsertWithWhereUniqueWithoutProcessStepInput = {
    where: SensorWhereUniqueInput
    update: XOR<SensorUpdateWithoutProcessStepInput, SensorUncheckedUpdateWithoutProcessStepInput>
    create: XOR<SensorCreateWithoutProcessStepInput, SensorUncheckedCreateWithoutProcessStepInput>
  }

  export type SensorUpdateWithWhereUniqueWithoutProcessStepInput = {
    where: SensorWhereUniqueInput
    data: XOR<SensorUpdateWithoutProcessStepInput, SensorUncheckedUpdateWithoutProcessStepInput>
  }

  export type SensorUpdateManyWithWhereWithoutProcessStepInput = {
    where: SensorScalarWhereInput
    data: XOR<SensorUpdateManyMutationInput, SensorUncheckedUpdateManyWithoutProcessStepInput>
  }

  export type SensorScalarWhereInput = {
    AND?: SensorScalarWhereInput | SensorScalarWhereInput[]
    OR?: SensorScalarWhereInput[]
    NOT?: SensorScalarWhereInput | SensorScalarWhereInput[]
    id?: IntFilter<"Sensor"> | number
    createdAt?: DateTimeFilter<"Sensor"> | Date | string
    updatedAt?: DateTimeFilter<"Sensor"> | Date | string
    name?: StringFilter<"Sensor"> | string
    type?: StringFilter<"Sensor"> | string
    value?: IntFilter<"Sensor"> | number
    sensorDelay?: IntFilter<"Sensor"> | number
    active?: BoolFilter<"Sensor"> | boolean
    processStepId?: IntNullableFilter<"Sensor"> | number | null
    transportSystemId?: IntNullableFilter<"Sensor"> | number | null
  }

  export type TransportSystemUpsertWithWhereUniqueWithoutEndStepInput = {
    where: TransportSystemWhereUniqueInput
    update: XOR<TransportSystemUpdateWithoutEndStepInput, TransportSystemUncheckedUpdateWithoutEndStepInput>
    create: XOR<TransportSystemCreateWithoutEndStepInput, TransportSystemUncheckedCreateWithoutEndStepInput>
  }

  export type TransportSystemUpdateWithWhereUniqueWithoutEndStepInput = {
    where: TransportSystemWhereUniqueInput
    data: XOR<TransportSystemUpdateWithoutEndStepInput, TransportSystemUncheckedUpdateWithoutEndStepInput>
  }

  export type TransportSystemUpdateManyWithWhereWithoutEndStepInput = {
    where: TransportSystemScalarWhereInput
    data: XOR<TransportSystemUpdateManyMutationInput, TransportSystemUncheckedUpdateManyWithoutEndStepInput>
  }

  export type TransportSystemScalarWhereInput = {
    AND?: TransportSystemScalarWhereInput | TransportSystemScalarWhereInput[]
    OR?: TransportSystemScalarWhereInput[]
    NOT?: TransportSystemScalarWhereInput | TransportSystemScalarWhereInput[]
    id?: IntFilter<"TransportSystem"> | number
    createdAt?: DateTimeFilter<"TransportSystem"> | Date | string
    updatedAt?: DateTimeFilter<"TransportSystem"> | Date | string
    active?: BoolFilter<"TransportSystem"> | boolean
    name?: StringFilter<"TransportSystem"> | string
    inputSpeed?: IntFilter<"TransportSystem"> | number
    outputSpeed?: IntFilter<"TransportSystem"> | number
    inventoryId?: IntFilter<"TransportSystem"> | number
    minQuantity?: IntNullableFilter<"TransportSystem"> | number | null
    transportDelay?: IntNullableFilter<"TransportSystem"> | number | null
    startStepId?: IntNullableFilter<"TransportSystem"> | number | null
    endStepId?: IntNullableFilter<"TransportSystem"> | number | null
    type?: StringFilter<"TransportSystem"> | string
    startTSId?: IntNullableFilter<"TransportSystem"> | number | null
    endTSId?: IntNullableFilter<"TransportSystem"> | number | null
  }

  export type TransportSystemUpsertWithWhereUniqueWithoutStartStepInput = {
    where: TransportSystemWhereUniqueInput
    update: XOR<TransportSystemUpdateWithoutStartStepInput, TransportSystemUncheckedUpdateWithoutStartStepInput>
    create: XOR<TransportSystemCreateWithoutStartStepInput, TransportSystemUncheckedCreateWithoutStartStepInput>
  }

  export type TransportSystemUpdateWithWhereUniqueWithoutStartStepInput = {
    where: TransportSystemWhereUniqueInput
    data: XOR<TransportSystemUpdateWithoutStartStepInput, TransportSystemUncheckedUpdateWithoutStartStepInput>
  }

  export type TransportSystemUpdateManyWithWhereWithoutStartStepInput = {
    where: TransportSystemScalarWhereInput
    data: XOR<TransportSystemUpdateManyMutationInput, TransportSystemUncheckedUpdateManyWithoutStartStepInput>
  }

  export type ProcessStepCreateWithoutRecipeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    errorRate?: number | null
    orders?: OrderCreateNestedManyWithoutProcessStepsInput
    inventory: InventoryCreateNestedOneWithoutProcessStepInput
    location: LocationCreateNestedOneWithoutProcessStepsInput
    resources?: ResourceCreateNestedManyWithoutProcessStepInput
    sensors?: SensorCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemCreateNestedManyWithoutEndStepInput
    outputs?: TransportSystemCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepUncheckedCreateWithoutRecipeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    locationId: number
    inventoryId: number
    errorRate?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutProcessStepsInput
    resources?: ResourceUncheckedCreateNestedManyWithoutProcessStepInput
    sensors?: SensorUncheckedCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemUncheckedCreateNestedManyWithoutEndStepInput
    outputs?: TransportSystemUncheckedCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepCreateOrConnectWithoutRecipeInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutRecipeInput, ProcessStepUncheckedCreateWithoutRecipeInput>
  }

  export type ProcessStepCreateManyRecipeInputEnvelope = {
    data: ProcessStepCreateManyRecipeInput | ProcessStepCreateManyRecipeInput[]
  }

  export type RecipeInputCreateWithoutRecipeInput = {
    material: string
    quantity: number
  }

  export type RecipeInputUncheckedCreateWithoutRecipeInput = {
    id?: number
    material: string
    quantity: number
  }

  export type RecipeInputCreateOrConnectWithoutRecipeInput = {
    where: RecipeInputWhereUniqueInput
    create: XOR<RecipeInputCreateWithoutRecipeInput, RecipeInputUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeInputCreateManyRecipeInputEnvelope = {
    data: RecipeInputCreateManyRecipeInput | RecipeInputCreateManyRecipeInput[]
  }

  export type RecipeOutputCreateWithoutRecipeInput = {
    material: string
    quantity: number
  }

  export type RecipeOutputUncheckedCreateWithoutRecipeInput = {
    id?: number
    material: string
    quantity: number
  }

  export type RecipeOutputCreateOrConnectWithoutRecipeInput = {
    where: RecipeOutputWhereUniqueInput
    create: XOR<RecipeOutputCreateWithoutRecipeInput, RecipeOutputUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeOutputCreateManyRecipeInputEnvelope = {
    data: RecipeOutputCreateManyRecipeInput | RecipeOutputCreateManyRecipeInput[]
  }

  export type ProcessStepUpsertWithWhereUniqueWithoutRecipeInput = {
    where: ProcessStepWhereUniqueInput
    update: XOR<ProcessStepUpdateWithoutRecipeInput, ProcessStepUncheckedUpdateWithoutRecipeInput>
    create: XOR<ProcessStepCreateWithoutRecipeInput, ProcessStepUncheckedCreateWithoutRecipeInput>
  }

  export type ProcessStepUpdateWithWhereUniqueWithoutRecipeInput = {
    where: ProcessStepWhereUniqueInput
    data: XOR<ProcessStepUpdateWithoutRecipeInput, ProcessStepUncheckedUpdateWithoutRecipeInput>
  }

  export type ProcessStepUpdateManyWithWhereWithoutRecipeInput = {
    where: ProcessStepScalarWhereInput
    data: XOR<ProcessStepUpdateManyMutationInput, ProcessStepUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeInputUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeInputWhereUniqueInput
    update: XOR<RecipeInputUpdateWithoutRecipeInput, RecipeInputUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeInputCreateWithoutRecipeInput, RecipeInputUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeInputUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeInputWhereUniqueInput
    data: XOR<RecipeInputUpdateWithoutRecipeInput, RecipeInputUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeInputUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeInputScalarWhereInput
    data: XOR<RecipeInputUpdateManyMutationInput, RecipeInputUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeInputScalarWhereInput = {
    AND?: RecipeInputScalarWhereInput | RecipeInputScalarWhereInput[]
    OR?: RecipeInputScalarWhereInput[]
    NOT?: RecipeInputScalarWhereInput | RecipeInputScalarWhereInput[]
    id?: IntFilter<"RecipeInput"> | number
    material?: StringFilter<"RecipeInput"> | string
    quantity?: IntFilter<"RecipeInput"> | number
    recipeId?: IntNullableFilter<"RecipeInput"> | number | null
  }

  export type RecipeOutputUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeOutputWhereUniqueInput
    update: XOR<RecipeOutputUpdateWithoutRecipeInput, RecipeOutputUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeOutputCreateWithoutRecipeInput, RecipeOutputUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeOutputUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeOutputWhereUniqueInput
    data: XOR<RecipeOutputUpdateWithoutRecipeInput, RecipeOutputUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeOutputUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeOutputScalarWhereInput
    data: XOR<RecipeOutputUpdateManyMutationInput, RecipeOutputUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeOutputScalarWhereInput = {
    AND?: RecipeOutputScalarWhereInput | RecipeOutputScalarWhereInput[]
    OR?: RecipeOutputScalarWhereInput[]
    NOT?: RecipeOutputScalarWhereInput | RecipeOutputScalarWhereInput[]
    id?: IntFilter<"RecipeOutput"> | number
    material?: StringFilter<"RecipeOutput"> | string
    quantity?: IntFilter<"RecipeOutput"> | number
    recipeId?: IntNullableFilter<"RecipeOutput"> | number | null
  }

  export type RecipeCreateWithoutInputsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    processSteps?: ProcessStepCreateNestedManyWithoutRecipeInput
    outputs?: RecipeOutputCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutInputsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutRecipeInput
    outputs?: RecipeOutputUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutInputsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutInputsInput, RecipeUncheckedCreateWithoutInputsInput>
  }

  export type RecipeUpsertWithoutInputsInput = {
    update: XOR<RecipeUpdateWithoutInputsInput, RecipeUncheckedUpdateWithoutInputsInput>
    create: XOR<RecipeCreateWithoutInputsInput, RecipeUncheckedCreateWithoutInputsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutInputsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutInputsInput, RecipeUncheckedUpdateWithoutInputsInput>
  }

  export type RecipeUpdateWithoutInputsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    processSteps?: ProcessStepUpdateManyWithoutRecipeNestedInput
    outputs?: RecipeOutputUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutInputsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    processSteps?: ProcessStepUncheckedUpdateManyWithoutRecipeNestedInput
    outputs?: RecipeOutputUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateWithoutOutputsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    processSteps?: ProcessStepCreateNestedManyWithoutRecipeInput
    inputs?: RecipeInputCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutOutputsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutRecipeInput
    inputs?: RecipeInputUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutOutputsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutOutputsInput, RecipeUncheckedCreateWithoutOutputsInput>
  }

  export type RecipeUpsertWithoutOutputsInput = {
    update: XOR<RecipeUpdateWithoutOutputsInput, RecipeUncheckedUpdateWithoutOutputsInput>
    create: XOR<RecipeCreateWithoutOutputsInput, RecipeUncheckedCreateWithoutOutputsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutOutputsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutOutputsInput, RecipeUncheckedUpdateWithoutOutputsInput>
  }

  export type RecipeUpdateWithoutOutputsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    processSteps?: ProcessStepUpdateManyWithoutRecipeNestedInput
    inputs?: RecipeInputUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutOutputsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    processSteps?: ProcessStepUncheckedUpdateManyWithoutRecipeNestedInput
    inputs?: RecipeInputUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type SensorCreateWithoutLogEntriesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: string
    value?: number
    sensorDelay?: number
    active?: boolean
    processStep?: ProcessStepCreateNestedOneWithoutSensorsInput
    transportSystem?: TransportSystemCreateNestedOneWithoutSensorsInput
  }

  export type SensorUncheckedCreateWithoutLogEntriesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: string
    value?: number
    sensorDelay?: number
    active?: boolean
    processStepId?: number | null
    transportSystemId?: number | null
  }

  export type SensorCreateOrConnectWithoutLogEntriesInput = {
    where: SensorWhereUniqueInput
    create: XOR<SensorCreateWithoutLogEntriesInput, SensorUncheckedCreateWithoutLogEntriesInput>
  }

  export type SensorUpsertWithoutLogEntriesInput = {
    update: XOR<SensorUpdateWithoutLogEntriesInput, SensorUncheckedUpdateWithoutLogEntriesInput>
    create: XOR<SensorCreateWithoutLogEntriesInput, SensorUncheckedCreateWithoutLogEntriesInput>
    where?: SensorWhereInput
  }

  export type SensorUpdateToOneWithWhereWithoutLogEntriesInput = {
    where?: SensorWhereInput
    data: XOR<SensorUpdateWithoutLogEntriesInput, SensorUncheckedUpdateWithoutLogEntriesInput>
  }

  export type SensorUpdateWithoutLogEntriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sensorDelay?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    processStep?: ProcessStepUpdateOneWithoutSensorsNestedInput
    transportSystem?: TransportSystemUpdateOneWithoutSensorsNestedInput
  }

  export type SensorUncheckedUpdateWithoutLogEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sensorDelay?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProcessStepCreateWithoutSensorsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    errorRate?: number | null
    orders?: OrderCreateNestedManyWithoutProcessStepsInput
    recipe?: RecipeCreateNestedOneWithoutProcessStepsInput
    inventory: InventoryCreateNestedOneWithoutProcessStepInput
    location: LocationCreateNestedOneWithoutProcessStepsInput
    resources?: ResourceCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemCreateNestedManyWithoutEndStepInput
    outputs?: TransportSystemCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepUncheckedCreateWithoutSensorsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    locationId: number
    inventoryId: number
    recipeId?: number | null
    errorRate?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutProcessStepsInput
    resources?: ResourceUncheckedCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemUncheckedCreateNestedManyWithoutEndStepInput
    outputs?: TransportSystemUncheckedCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepCreateOrConnectWithoutSensorsInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutSensorsInput, ProcessStepUncheckedCreateWithoutSensorsInput>
  }

  export type TransportSystemCreateWithoutSensorsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    minQuantity?: number | null
    transportDelay?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    endStep?: ProcessStepCreateNestedOneWithoutInputsInput
    startStep?: ProcessStepCreateNestedOneWithoutOutputsInput
    inventory: InventoryCreateNestedOneWithoutTransportSystemInput
    orders?: OrderCreateNestedManyWithoutTransportSystemsInput
    filter?: FilterCreateNestedOneWithoutTransportSystemInput
    resources?: ResourceCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemUncheckedCreateWithoutSensorsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    inventoryId: number
    minQuantity?: number | null
    transportDelay?: number | null
    startStepId?: number | null
    endStepId?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutTransportSystemsInput
    filter?: FilterUncheckedCreateNestedOneWithoutTransportSystemInput
    resources?: ResourceUncheckedCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemCreateOrConnectWithoutSensorsInput = {
    where: TransportSystemWhereUniqueInput
    create: XOR<TransportSystemCreateWithoutSensorsInput, TransportSystemUncheckedCreateWithoutSensorsInput>
  }

  export type LogEntryCreateWithoutSensorInput = {
    createdAt?: Date | string
    inputType: string
    materialId: number
    materialName: string
    processStepId?: number | null
    transportSystemId?: number | null
  }

  export type LogEntryUncheckedCreateWithoutSensorInput = {
    id?: number
    createdAt?: Date | string
    inputType: string
    materialId: number
    materialName: string
    processStepId?: number | null
    transportSystemId?: number | null
  }

  export type LogEntryCreateOrConnectWithoutSensorInput = {
    where: LogEntryWhereUniqueInput
    create: XOR<LogEntryCreateWithoutSensorInput, LogEntryUncheckedCreateWithoutSensorInput>
  }

  export type LogEntryCreateManySensorInputEnvelope = {
    data: LogEntryCreateManySensorInput | LogEntryCreateManySensorInput[]
  }

  export type ProcessStepUpsertWithoutSensorsInput = {
    update: XOR<ProcessStepUpdateWithoutSensorsInput, ProcessStepUncheckedUpdateWithoutSensorsInput>
    create: XOR<ProcessStepCreateWithoutSensorsInput, ProcessStepUncheckedCreateWithoutSensorsInput>
    where?: ProcessStepWhereInput
  }

  export type ProcessStepUpdateToOneWithWhereWithoutSensorsInput = {
    where?: ProcessStepWhereInput
    data: XOR<ProcessStepUpdateWithoutSensorsInput, ProcessStepUncheckedUpdateWithoutSensorsInput>
  }

  export type ProcessStepUpdateWithoutSensorsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUpdateManyWithoutProcessStepsNestedInput
    recipe?: RecipeUpdateOneWithoutProcessStepsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutProcessStepNestedInput
    location?: LocationUpdateOneRequiredWithoutProcessStepsNestedInput
    resources?: ResourceUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUpdateManyWithoutEndStepNestedInput
    outputs?: TransportSystemUpdateManyWithoutStartStepNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutSensorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutProcessStepsNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUncheckedUpdateManyWithoutEndStepNestedInput
    outputs?: TransportSystemUncheckedUpdateManyWithoutStartStepNestedInput
  }

  export type TransportSystemUpsertWithoutSensorsInput = {
    update: XOR<TransportSystemUpdateWithoutSensorsInput, TransportSystemUncheckedUpdateWithoutSensorsInput>
    create: XOR<TransportSystemCreateWithoutSensorsInput, TransportSystemUncheckedCreateWithoutSensorsInput>
    where?: TransportSystemWhereInput
  }

  export type TransportSystemUpdateToOneWithWhereWithoutSensorsInput = {
    where?: TransportSystemWhereInput
    data: XOR<TransportSystemUpdateWithoutSensorsInput, TransportSystemUncheckedUpdateWithoutSensorsInput>
  }

  export type TransportSystemUpdateWithoutSensorsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endStep?: ProcessStepUpdateOneWithoutInputsNestedInput
    startStep?: ProcessStepUpdateOneWithoutOutputsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutTransportSystemNestedInput
    orders?: OrderUpdateManyWithoutTransportSystemsNestedInput
    filter?: FilterUpdateOneWithoutTransportSystemNestedInput
    resources?: ResourceUpdateManyWithoutTransportSystemNestedInput
  }

  export type TransportSystemUncheckedUpdateWithoutSensorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    startStepId?: NullableIntFieldUpdateOperationsInput | number | null
    endStepId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutTransportSystemsNestedInput
    filter?: FilterUncheckedUpdateOneWithoutTransportSystemNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutTransportSystemNestedInput
  }

  export type LogEntryUpsertWithWhereUniqueWithoutSensorInput = {
    where: LogEntryWhereUniqueInput
    update: XOR<LogEntryUpdateWithoutSensorInput, LogEntryUncheckedUpdateWithoutSensorInput>
    create: XOR<LogEntryCreateWithoutSensorInput, LogEntryUncheckedCreateWithoutSensorInput>
  }

  export type LogEntryUpdateWithWhereUniqueWithoutSensorInput = {
    where: LogEntryWhereUniqueInput
    data: XOR<LogEntryUpdateWithoutSensorInput, LogEntryUncheckedUpdateWithoutSensorInput>
  }

  export type LogEntryUpdateManyWithWhereWithoutSensorInput = {
    where: LogEntryScalarWhereInput
    data: XOR<LogEntryUpdateManyMutationInput, LogEntryUncheckedUpdateManyWithoutSensorInput>
  }

  export type LogEntryScalarWhereInput = {
    AND?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
    OR?: LogEntryScalarWhereInput[]
    NOT?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
    id?: IntFilter<"LogEntry"> | number
    createdAt?: DateTimeFilter<"LogEntry"> | Date | string
    inputType?: StringFilter<"LogEntry"> | string
    sensorId?: IntNullableFilter<"LogEntry"> | number | null
    materialId?: IntFilter<"LogEntry"> | number
    materialName?: StringFilter<"LogEntry"> | string
    processStepId?: IntNullableFilter<"LogEntry"> | number | null
    transportSystemId?: IntNullableFilter<"LogEntry"> | number | null
  }

  export type FilterCreateWithoutEntriesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId?: number | null
    transportSystem: TransportSystemCreateNestedOneWithoutFilterInput
  }

  export type FilterUncheckedCreateWithoutEntriesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transportSystemId: number
    orderId?: number | null
  }

  export type FilterCreateOrConnectWithoutEntriesInput = {
    where: FilterWhereUniqueInput
    create: XOR<FilterCreateWithoutEntriesInput, FilterUncheckedCreateWithoutEntriesInput>
  }

  export type FilterUpsertWithoutEntriesInput = {
    update: XOR<FilterUpdateWithoutEntriesInput, FilterUncheckedUpdateWithoutEntriesInput>
    create: XOR<FilterCreateWithoutEntriesInput, FilterUncheckedCreateWithoutEntriesInput>
    where?: FilterWhereInput
  }

  export type FilterUpdateToOneWithWhereWithoutEntriesInput = {
    where?: FilterWhereInput
    data: XOR<FilterUpdateWithoutEntriesInput, FilterUncheckedUpdateWithoutEntriesInput>
  }

  export type FilterUpdateWithoutEntriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystem?: TransportSystemUpdateOneRequiredWithoutFilterNestedInput
  }

  export type FilterUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transportSystemId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransportSystemCreateWithoutFilterInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    minQuantity?: number | null
    transportDelay?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    endStep?: ProcessStepCreateNestedOneWithoutInputsInput
    startStep?: ProcessStepCreateNestedOneWithoutOutputsInput
    inventory: InventoryCreateNestedOneWithoutTransportSystemInput
    orders?: OrderCreateNestedManyWithoutTransportSystemsInput
    sensors?: SensorCreateNestedManyWithoutTransportSystemInput
    resources?: ResourceCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemUncheckedCreateWithoutFilterInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    inventoryId: number
    minQuantity?: number | null
    transportDelay?: number | null
    startStepId?: number | null
    endStepId?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutTransportSystemsInput
    sensors?: SensorUncheckedCreateNestedManyWithoutTransportSystemInput
    resources?: ResourceUncheckedCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemCreateOrConnectWithoutFilterInput = {
    where: TransportSystemWhereUniqueInput
    create: XOR<TransportSystemCreateWithoutFilterInput, TransportSystemUncheckedCreateWithoutFilterInput>
  }

  export type FilterEntryCreateWithoutFilterInput = {
    addedAt?: Date | string
    material: string
  }

  export type FilterEntryUncheckedCreateWithoutFilterInput = {
    id?: number
    addedAt?: Date | string
    material: string
  }

  export type FilterEntryCreateOrConnectWithoutFilterInput = {
    where: FilterEntryWhereUniqueInput
    create: XOR<FilterEntryCreateWithoutFilterInput, FilterEntryUncheckedCreateWithoutFilterInput>
  }

  export type FilterEntryCreateManyFilterInputEnvelope = {
    data: FilterEntryCreateManyFilterInput | FilterEntryCreateManyFilterInput[]
  }

  export type TransportSystemUpsertWithoutFilterInput = {
    update: XOR<TransportSystemUpdateWithoutFilterInput, TransportSystemUncheckedUpdateWithoutFilterInput>
    create: XOR<TransportSystemCreateWithoutFilterInput, TransportSystemUncheckedCreateWithoutFilterInput>
    where?: TransportSystemWhereInput
  }

  export type TransportSystemUpdateToOneWithWhereWithoutFilterInput = {
    where?: TransportSystemWhereInput
    data: XOR<TransportSystemUpdateWithoutFilterInput, TransportSystemUncheckedUpdateWithoutFilterInput>
  }

  export type TransportSystemUpdateWithoutFilterInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endStep?: ProcessStepUpdateOneWithoutInputsNestedInput
    startStep?: ProcessStepUpdateOneWithoutOutputsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutTransportSystemNestedInput
    orders?: OrderUpdateManyWithoutTransportSystemsNestedInput
    sensors?: SensorUpdateManyWithoutTransportSystemNestedInput
    resources?: ResourceUpdateManyWithoutTransportSystemNestedInput
  }

  export type TransportSystemUncheckedUpdateWithoutFilterInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    startStepId?: NullableIntFieldUpdateOperationsInput | number | null
    endStepId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutTransportSystemsNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutTransportSystemNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutTransportSystemNestedInput
  }

  export type FilterEntryUpsertWithWhereUniqueWithoutFilterInput = {
    where: FilterEntryWhereUniqueInput
    update: XOR<FilterEntryUpdateWithoutFilterInput, FilterEntryUncheckedUpdateWithoutFilterInput>
    create: XOR<FilterEntryCreateWithoutFilterInput, FilterEntryUncheckedCreateWithoutFilterInput>
  }

  export type FilterEntryUpdateWithWhereUniqueWithoutFilterInput = {
    where: FilterEntryWhereUniqueInput
    data: XOR<FilterEntryUpdateWithoutFilterInput, FilterEntryUncheckedUpdateWithoutFilterInput>
  }

  export type FilterEntryUpdateManyWithWhereWithoutFilterInput = {
    where: FilterEntryScalarWhereInput
    data: XOR<FilterEntryUpdateManyMutationInput, FilterEntryUncheckedUpdateManyWithoutFilterInput>
  }

  export type FilterEntryScalarWhereInput = {
    AND?: FilterEntryScalarWhereInput | FilterEntryScalarWhereInput[]
    OR?: FilterEntryScalarWhereInput[]
    NOT?: FilterEntryScalarWhereInput | FilterEntryScalarWhereInput[]
    id?: IntFilter<"FilterEntry"> | number
    addedAt?: DateTimeFilter<"FilterEntry"> | Date | string
    material?: StringFilter<"FilterEntry"> | string
    filterId?: IntFilter<"FilterEntry"> | number
  }

  export type ProcessStepCreateWithoutInputsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    errorRate?: number | null
    orders?: OrderCreateNestedManyWithoutProcessStepsInput
    recipe?: RecipeCreateNestedOneWithoutProcessStepsInput
    inventory: InventoryCreateNestedOneWithoutProcessStepInput
    location: LocationCreateNestedOneWithoutProcessStepsInput
    resources?: ResourceCreateNestedManyWithoutProcessStepInput
    sensors?: SensorCreateNestedManyWithoutProcessStepInput
    outputs?: TransportSystemCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepUncheckedCreateWithoutInputsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    locationId: number
    inventoryId: number
    recipeId?: number | null
    errorRate?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutProcessStepsInput
    resources?: ResourceUncheckedCreateNestedManyWithoutProcessStepInput
    sensors?: SensorUncheckedCreateNestedManyWithoutProcessStepInput
    outputs?: TransportSystemUncheckedCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepCreateOrConnectWithoutInputsInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutInputsInput, ProcessStepUncheckedCreateWithoutInputsInput>
  }

  export type ProcessStepCreateWithoutOutputsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    errorRate?: number | null
    orders?: OrderCreateNestedManyWithoutProcessStepsInput
    recipe?: RecipeCreateNestedOneWithoutProcessStepsInput
    inventory: InventoryCreateNestedOneWithoutProcessStepInput
    location: LocationCreateNestedOneWithoutProcessStepsInput
    resources?: ResourceCreateNestedManyWithoutProcessStepInput
    sensors?: SensorCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemCreateNestedManyWithoutEndStepInput
  }

  export type ProcessStepUncheckedCreateWithoutOutputsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    locationId: number
    inventoryId: number
    recipeId?: number | null
    errorRate?: number | null
    orders?: OrderUncheckedCreateNestedManyWithoutProcessStepsInput
    resources?: ResourceUncheckedCreateNestedManyWithoutProcessStepInput
    sensors?: SensorUncheckedCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemUncheckedCreateNestedManyWithoutEndStepInput
  }

  export type ProcessStepCreateOrConnectWithoutOutputsInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutOutputsInput, ProcessStepUncheckedCreateWithoutOutputsInput>
  }

  export type InventoryCreateWithoutTransportSystemInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    limit: number
    entries?: InventoryEntryCreateNestedManyWithoutInventoryInput
    processStep?: ProcessStepCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutTransportSystemInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: string
    limit: number
    entries?: InventoryEntryUncheckedCreateNestedManyWithoutInventoryInput
    processStep?: ProcessStepUncheckedCreateNestedOneWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutTransportSystemInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutTransportSystemInput, InventoryUncheckedCreateWithoutTransportSystemInput>
  }

  export type OrderCreateWithoutTransportSystemsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    priority?: number
    dueDate?: Date | string | null
    description?: string | null
    quantity?: number
    startedAt?: Date | string | null
    startedTick?: number | null
    completedTick?: number | null
    completedAt?: Date | string | null
    canceledAt?: Date | string | null
    inventoryEntries?: InventoryEntryCreateNestedManyWithoutOrderInput
    processSteps?: ProcessStepCreateNestedManyWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutTransportSystemsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    priority?: number
    dueDate?: Date | string | null
    description?: string | null
    quantity?: number
    startedAt?: Date | string | null
    startedTick?: number | null
    completedTick?: number | null
    completedAt?: Date | string | null
    canceledAt?: Date | string | null
    inventoryEntries?: InventoryEntryUncheckedCreateNestedManyWithoutOrderInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrderCreateOrConnectWithoutTransportSystemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutTransportSystemsInput, OrderUncheckedCreateWithoutTransportSystemsInput>
  }

  export type FilterCreateWithoutTransportSystemInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId?: number | null
    entries?: FilterEntryCreateNestedManyWithoutFilterInput
  }

  export type FilterUncheckedCreateWithoutTransportSystemInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId?: number | null
    entries?: FilterEntryUncheckedCreateNestedManyWithoutFilterInput
  }

  export type FilterCreateOrConnectWithoutTransportSystemInput = {
    where: FilterWhereUniqueInput
    create: XOR<FilterCreateWithoutTransportSystemInput, FilterUncheckedCreateWithoutTransportSystemInput>
  }

  export type SensorCreateWithoutTransportSystemInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: string
    value?: number
    sensorDelay?: number
    active?: boolean
    processStep?: ProcessStepCreateNestedOneWithoutSensorsInput
    logEntries?: LogEntryCreateNestedManyWithoutSensorInput
  }

  export type SensorUncheckedCreateWithoutTransportSystemInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: string
    value?: number
    sensorDelay?: number
    active?: boolean
    processStepId?: number | null
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutSensorInput
  }

  export type SensorCreateOrConnectWithoutTransportSystemInput = {
    where: SensorWhereUniqueInput
    create: XOR<SensorCreateWithoutTransportSystemInput, SensorUncheckedCreateWithoutTransportSystemInput>
  }

  export type SensorCreateManyTransportSystemInputEnvelope = {
    data: SensorCreateManyTransportSystemInput | SensorCreateManyTransportSystemInput[]
  }

  export type ResourceCreateWithoutTransportSystemInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    faulty?: boolean | null
    faultyRate?: number
    Machine?: MachineCreateNestedOneWithoutResourceInput
    processStep?: ProcessStepCreateNestedOneWithoutResourcesInput
    location: LocationCreateNestedOneWithoutResourcesInput
    Worker?: WorkerCreateNestedOneWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutTransportSystemInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    locationId: number
    processStepId?: number | null
    faulty?: boolean | null
    faultyRate?: number
    Machine?: MachineUncheckedCreateNestedOneWithoutResourceInput
    Worker?: WorkerUncheckedCreateNestedOneWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutTransportSystemInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutTransportSystemInput, ResourceUncheckedCreateWithoutTransportSystemInput>
  }

  export type ResourceCreateManyTransportSystemInputEnvelope = {
    data: ResourceCreateManyTransportSystemInput | ResourceCreateManyTransportSystemInput[]
  }

  export type ProcessStepUpsertWithoutInputsInput = {
    update: XOR<ProcessStepUpdateWithoutInputsInput, ProcessStepUncheckedUpdateWithoutInputsInput>
    create: XOR<ProcessStepCreateWithoutInputsInput, ProcessStepUncheckedCreateWithoutInputsInput>
    where?: ProcessStepWhereInput
  }

  export type ProcessStepUpdateToOneWithWhereWithoutInputsInput = {
    where?: ProcessStepWhereInput
    data: XOR<ProcessStepUpdateWithoutInputsInput, ProcessStepUncheckedUpdateWithoutInputsInput>
  }

  export type ProcessStepUpdateWithoutInputsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUpdateManyWithoutProcessStepsNestedInput
    recipe?: RecipeUpdateOneWithoutProcessStepsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutProcessStepNestedInput
    location?: LocationUpdateOneRequiredWithoutProcessStepsNestedInput
    resources?: ResourceUpdateManyWithoutProcessStepNestedInput
    sensors?: SensorUpdateManyWithoutProcessStepNestedInput
    outputs?: TransportSystemUpdateManyWithoutStartStepNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutInputsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutProcessStepsNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutProcessStepNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutProcessStepNestedInput
    outputs?: TransportSystemUncheckedUpdateManyWithoutStartStepNestedInput
  }

  export type ProcessStepUpsertWithoutOutputsInput = {
    update: XOR<ProcessStepUpdateWithoutOutputsInput, ProcessStepUncheckedUpdateWithoutOutputsInput>
    create: XOR<ProcessStepCreateWithoutOutputsInput, ProcessStepUncheckedCreateWithoutOutputsInput>
    where?: ProcessStepWhereInput
  }

  export type ProcessStepUpdateToOneWithWhereWithoutOutputsInput = {
    where?: ProcessStepWhereInput
    data: XOR<ProcessStepUpdateWithoutOutputsInput, ProcessStepUncheckedUpdateWithoutOutputsInput>
  }

  export type ProcessStepUpdateWithoutOutputsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUpdateManyWithoutProcessStepsNestedInput
    recipe?: RecipeUpdateOneWithoutProcessStepsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutProcessStepNestedInput
    location?: LocationUpdateOneRequiredWithoutProcessStepsNestedInput
    resources?: ResourceUpdateManyWithoutProcessStepNestedInput
    sensors?: SensorUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUpdateManyWithoutEndStepNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutOutputsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutProcessStepsNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutProcessStepNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUncheckedUpdateManyWithoutEndStepNestedInput
  }

  export type InventoryUpsertWithoutTransportSystemInput = {
    update: XOR<InventoryUpdateWithoutTransportSystemInput, InventoryUncheckedUpdateWithoutTransportSystemInput>
    create: XOR<InventoryCreateWithoutTransportSystemInput, InventoryUncheckedCreateWithoutTransportSystemInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutTransportSystemInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutTransportSystemInput, InventoryUncheckedUpdateWithoutTransportSystemInput>
  }

  export type InventoryUpdateWithoutTransportSystemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    limit?: IntFieldUpdateOperationsInput | number
    entries?: InventoryEntryUpdateManyWithoutInventoryNestedInput
    processStep?: ProcessStepUpdateOneWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutTransportSystemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    limit?: IntFieldUpdateOperationsInput | number
    entries?: InventoryEntryUncheckedUpdateManyWithoutInventoryNestedInput
    processStep?: ProcessStepUncheckedUpdateOneWithoutInventoryNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutTransportSystemsInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutTransportSystemsInput, OrderUncheckedUpdateWithoutTransportSystemsInput>
    create: XOR<OrderCreateWithoutTransportSystemsInput, OrderUncheckedCreateWithoutTransportSystemsInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutTransportSystemsInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutTransportSystemsInput, OrderUncheckedUpdateWithoutTransportSystemsInput>
  }

  export type OrderUpdateManyWithWhereWithoutTransportSystemsInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutTransportSystemsInput>
  }

  export type FilterUpsertWithoutTransportSystemInput = {
    update: XOR<FilterUpdateWithoutTransportSystemInput, FilterUncheckedUpdateWithoutTransportSystemInput>
    create: XOR<FilterCreateWithoutTransportSystemInput, FilterUncheckedCreateWithoutTransportSystemInput>
    where?: FilterWhereInput
  }

  export type FilterUpdateToOneWithWhereWithoutTransportSystemInput = {
    where?: FilterWhereInput
    data: XOR<FilterUpdateWithoutTransportSystemInput, FilterUncheckedUpdateWithoutTransportSystemInput>
  }

  export type FilterUpdateWithoutTransportSystemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    entries?: FilterEntryUpdateManyWithoutFilterNestedInput
  }

  export type FilterUncheckedUpdateWithoutTransportSystemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    entries?: FilterEntryUncheckedUpdateManyWithoutFilterNestedInput
  }

  export type SensorUpsertWithWhereUniqueWithoutTransportSystemInput = {
    where: SensorWhereUniqueInput
    update: XOR<SensorUpdateWithoutTransportSystemInput, SensorUncheckedUpdateWithoutTransportSystemInput>
    create: XOR<SensorCreateWithoutTransportSystemInput, SensorUncheckedCreateWithoutTransportSystemInput>
  }

  export type SensorUpdateWithWhereUniqueWithoutTransportSystemInput = {
    where: SensorWhereUniqueInput
    data: XOR<SensorUpdateWithoutTransportSystemInput, SensorUncheckedUpdateWithoutTransportSystemInput>
  }

  export type SensorUpdateManyWithWhereWithoutTransportSystemInput = {
    where: SensorScalarWhereInput
    data: XOR<SensorUpdateManyMutationInput, SensorUncheckedUpdateManyWithoutTransportSystemInput>
  }

  export type ResourceUpsertWithWhereUniqueWithoutTransportSystemInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutTransportSystemInput, ResourceUncheckedUpdateWithoutTransportSystemInput>
    create: XOR<ResourceCreateWithoutTransportSystemInput, ResourceUncheckedCreateWithoutTransportSystemInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutTransportSystemInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutTransportSystemInput, ResourceUncheckedUpdateWithoutTransportSystemInput>
  }

  export type ResourceUpdateManyWithWhereWithoutTransportSystemInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutTransportSystemInput>
  }

  export type InventoryEntryCreateWithoutOrderInput = {
    addedAt?: Date | string
    material: string
    inventory: InventoryCreateNestedOneWithoutEntriesInput
  }

  export type InventoryEntryUncheckedCreateWithoutOrderInput = {
    id?: number
    addedAt?: Date | string
    material: string
    inventoryId: number
  }

  export type InventoryEntryCreateOrConnectWithoutOrderInput = {
    where: InventoryEntryWhereUniqueInput
    create: XOR<InventoryEntryCreateWithoutOrderInput, InventoryEntryUncheckedCreateWithoutOrderInput>
  }

  export type InventoryEntryCreateManyOrderInputEnvelope = {
    data: InventoryEntryCreateManyOrderInput | InventoryEntryCreateManyOrderInput[]
  }

  export type ProcessStepCreateWithoutOrdersInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    errorRate?: number | null
    recipe?: RecipeCreateNestedOneWithoutProcessStepsInput
    inventory: InventoryCreateNestedOneWithoutProcessStepInput
    location: LocationCreateNestedOneWithoutProcessStepsInput
    resources?: ResourceCreateNestedManyWithoutProcessStepInput
    sensors?: SensorCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemCreateNestedManyWithoutEndStepInput
    outputs?: TransportSystemCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepUncheckedCreateWithoutOrdersInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    locationId: number
    inventoryId: number
    recipeId?: number | null
    errorRate?: number | null
    resources?: ResourceUncheckedCreateNestedManyWithoutProcessStepInput
    sensors?: SensorUncheckedCreateNestedManyWithoutProcessStepInput
    inputs?: TransportSystemUncheckedCreateNestedManyWithoutEndStepInput
    outputs?: TransportSystemUncheckedCreateNestedManyWithoutStartStepInput
  }

  export type ProcessStepCreateOrConnectWithoutOrdersInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutOrdersInput, ProcessStepUncheckedCreateWithoutOrdersInput>
  }

  export type TransportSystemCreateWithoutOrdersInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    minQuantity?: number | null
    transportDelay?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    endStep?: ProcessStepCreateNestedOneWithoutInputsInput
    startStep?: ProcessStepCreateNestedOneWithoutOutputsInput
    inventory: InventoryCreateNestedOneWithoutTransportSystemInput
    filter?: FilterCreateNestedOneWithoutTransportSystemInput
    sensors?: SensorCreateNestedManyWithoutTransportSystemInput
    resources?: ResourceCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemUncheckedCreateWithoutOrdersInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    inventoryId: number
    minQuantity?: number | null
    transportDelay?: number | null
    startStepId?: number | null
    endStepId?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
    filter?: FilterUncheckedCreateNestedOneWithoutTransportSystemInput
    sensors?: SensorUncheckedCreateNestedManyWithoutTransportSystemInput
    resources?: ResourceUncheckedCreateNestedManyWithoutTransportSystemInput
  }

  export type TransportSystemCreateOrConnectWithoutOrdersInput = {
    where: TransportSystemWhereUniqueInput
    create: XOR<TransportSystemCreateWithoutOrdersInput, TransportSystemUncheckedCreateWithoutOrdersInput>
  }

  export type InventoryEntryUpsertWithWhereUniqueWithoutOrderInput = {
    where: InventoryEntryWhereUniqueInput
    update: XOR<InventoryEntryUpdateWithoutOrderInput, InventoryEntryUncheckedUpdateWithoutOrderInput>
    create: XOR<InventoryEntryCreateWithoutOrderInput, InventoryEntryUncheckedCreateWithoutOrderInput>
  }

  export type InventoryEntryUpdateWithWhereUniqueWithoutOrderInput = {
    where: InventoryEntryWhereUniqueInput
    data: XOR<InventoryEntryUpdateWithoutOrderInput, InventoryEntryUncheckedUpdateWithoutOrderInput>
  }

  export type InventoryEntryUpdateManyWithWhereWithoutOrderInput = {
    where: InventoryEntryScalarWhereInput
    data: XOR<InventoryEntryUpdateManyMutationInput, InventoryEntryUncheckedUpdateManyWithoutOrderInput>
  }

  export type ProcessStepUpsertWithWhereUniqueWithoutOrdersInput = {
    where: ProcessStepWhereUniqueInput
    update: XOR<ProcessStepUpdateWithoutOrdersInput, ProcessStepUncheckedUpdateWithoutOrdersInput>
    create: XOR<ProcessStepCreateWithoutOrdersInput, ProcessStepUncheckedCreateWithoutOrdersInput>
  }

  export type ProcessStepUpdateWithWhereUniqueWithoutOrdersInput = {
    where: ProcessStepWhereUniqueInput
    data: XOR<ProcessStepUpdateWithoutOrdersInput, ProcessStepUncheckedUpdateWithoutOrdersInput>
  }

  export type ProcessStepUpdateManyWithWhereWithoutOrdersInput = {
    where: ProcessStepScalarWhereInput
    data: XOR<ProcessStepUpdateManyMutationInput, ProcessStepUncheckedUpdateManyWithoutOrdersInput>
  }

  export type TransportSystemUpsertWithWhereUniqueWithoutOrdersInput = {
    where: TransportSystemWhereUniqueInput
    update: XOR<TransportSystemUpdateWithoutOrdersInput, TransportSystemUncheckedUpdateWithoutOrdersInput>
    create: XOR<TransportSystemCreateWithoutOrdersInput, TransportSystemUncheckedCreateWithoutOrdersInput>
  }

  export type TransportSystemUpdateWithWhereUniqueWithoutOrdersInput = {
    where: TransportSystemWhereUniqueInput
    data: XOR<TransportSystemUpdateWithoutOrdersInput, TransportSystemUncheckedUpdateWithoutOrdersInput>
  }

  export type TransportSystemUpdateManyWithWhereWithoutOrdersInput = {
    where: TransportSystemScalarWhereInput
    data: XOR<TransportSystemUpdateManyMutationInput, TransportSystemUncheckedUpdateManyWithoutOrdersInput>
  }

  export type KpiRecordCreateManySimulationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    key: string
    value: number
    name?: string | null
  }

  export type KpiRecordUpdateWithoutSimulationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KpiRecordUncheckedUpdateWithoutSimulationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KpiRecordUncheckedUpdateManyWithoutSimulationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkerRoleUpdateWithoutWorkersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkerRoleUncheckedUpdateWithoutWorkersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkerRoleUncheckedUpdateManyWithoutWorkersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkerUpdateWithoutWorkerRolesInput = {
    workerNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    resource?: ResourceUpdateOneRequiredWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateWithoutWorkerRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    workerNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    resourceId?: IntFieldUpdateOperationsInput | number
  }

  export type WorkerUncheckedUpdateManyWithoutWorkerRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    workerNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    resourceId?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryEntryCreateManyInventoryInput = {
    id?: number
    addedAt?: Date | string
    material: string
    orderId?: number | null
  }

  export type InventoryEntryUpdateWithoutInventoryInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
    Order?: OrderUpdateOneWithoutInventoryEntriesNestedInput
  }

  export type InventoryEntryUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventoryEntryUncheckedUpdateManyWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProcessStepCreateManyLocationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    inventoryId: number
    recipeId?: number | null
    errorRate?: number | null
  }

  export type ResourceCreateManyLocationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    processStepId?: number | null
    transportSystemId?: number | null
    faulty?: boolean | null
    faultyRate?: number
  }

  export type ProcessStepUpdateWithoutLocationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUpdateManyWithoutProcessStepsNestedInput
    recipe?: RecipeUpdateOneWithoutProcessStepsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutProcessStepNestedInput
    resources?: ResourceUpdateManyWithoutProcessStepNestedInput
    sensors?: SensorUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUpdateManyWithoutEndStepNestedInput
    outputs?: TransportSystemUpdateManyWithoutStartStepNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutProcessStepsNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutProcessStepNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUncheckedUpdateManyWithoutEndStepNestedInput
    outputs?: TransportSystemUncheckedUpdateManyWithoutStartStepNestedInput
  }

  export type ProcessStepUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ResourceUpdateWithoutLocationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
    Machine?: MachineUpdateOneWithoutResourceNestedInput
    processStep?: ProcessStepUpdateOneWithoutResourcesNestedInput
    transportSystem?: TransportSystemUpdateOneWithoutResourcesNestedInput
    Worker?: WorkerUpdateOneWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
    Machine?: MachineUncheckedUpdateOneWithoutResourceNestedInput
    Worker?: WorkerUncheckedUpdateOneWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
  }

  export type ResourceCreateManyProcessStepInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    locationId: number
    transportSystemId?: number | null
    faulty?: boolean | null
    faultyRate?: number
  }

  export type SensorCreateManyProcessStepInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: string
    value?: number
    sensorDelay?: number
    active?: boolean
    transportSystemId?: number | null
  }

  export type TransportSystemCreateManyEndStepInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    inventoryId: number
    minQuantity?: number | null
    transportDelay?: number | null
    startStepId?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
  }

  export type TransportSystemCreateManyStartStepInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    name: string
    inputSpeed: number
    outputSpeed: number
    inventoryId: number
    minQuantity?: number | null
    transportDelay?: number | null
    endStepId?: number | null
    type: string
    startTSId?: number | null
    endTSId?: number | null
  }

  export type OrderUpdateWithoutProcessStepsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryEntries?: InventoryEntryUpdateManyWithoutOrderNestedInput
    transportSystems?: TransportSystemUpdateManyWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutProcessStepsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryEntries?: InventoryEntryUncheckedUpdateManyWithoutOrderNestedInput
    transportSystems?: TransportSystemUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutProcessStepsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResourceUpdateWithoutProcessStepInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
    Machine?: MachineUpdateOneWithoutResourceNestedInput
    transportSystem?: TransportSystemUpdateOneWithoutResourcesNestedInput
    location?: LocationUpdateOneRequiredWithoutResourcesNestedInput
    Worker?: WorkerUpdateOneWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutProcessStepInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    locationId?: IntFieldUpdateOperationsInput | number
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
    Machine?: MachineUncheckedUpdateOneWithoutResourceNestedInput
    Worker?: WorkerUncheckedUpdateOneWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateManyWithoutProcessStepInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    locationId?: IntFieldUpdateOperationsInput | number
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
  }

  export type SensorUpdateWithoutProcessStepInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sensorDelay?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    transportSystem?: TransportSystemUpdateOneWithoutSensorsNestedInput
    logEntries?: LogEntryUpdateManyWithoutSensorNestedInput
  }

  export type SensorUncheckedUpdateWithoutProcessStepInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sensorDelay?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    logEntries?: LogEntryUncheckedUpdateManyWithoutSensorNestedInput
  }

  export type SensorUncheckedUpdateManyWithoutProcessStepInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sensorDelay?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransportSystemUpdateWithoutEndStepInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    startStep?: ProcessStepUpdateOneWithoutOutputsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutTransportSystemNestedInput
    orders?: OrderUpdateManyWithoutTransportSystemsNestedInput
    filter?: FilterUpdateOneWithoutTransportSystemNestedInput
    sensors?: SensorUpdateManyWithoutTransportSystemNestedInput
    resources?: ResourceUpdateManyWithoutTransportSystemNestedInput
  }

  export type TransportSystemUncheckedUpdateWithoutEndStepInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    startStepId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutTransportSystemsNestedInput
    filter?: FilterUncheckedUpdateOneWithoutTransportSystemNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutTransportSystemNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutTransportSystemNestedInput
  }

  export type TransportSystemUncheckedUpdateManyWithoutEndStepInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    startStepId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransportSystemUpdateWithoutStartStepInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endStep?: ProcessStepUpdateOneWithoutInputsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutTransportSystemNestedInput
    orders?: OrderUpdateManyWithoutTransportSystemsNestedInput
    filter?: FilterUpdateOneWithoutTransportSystemNestedInput
    sensors?: SensorUpdateManyWithoutTransportSystemNestedInput
    resources?: ResourceUpdateManyWithoutTransportSystemNestedInput
  }

  export type TransportSystemUncheckedUpdateWithoutStartStepInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    endStepId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutTransportSystemsNestedInput
    filter?: FilterUncheckedUpdateOneWithoutTransportSystemNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutTransportSystemNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutTransportSystemNestedInput
  }

  export type TransportSystemUncheckedUpdateManyWithoutStartStepInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    endStepId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProcessStepCreateManyRecipeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: string
    active?: boolean
    inputSpeed: number
    outputSpeed: number
    recipeRate?: number
    duration?: number
    locationId: number
    inventoryId: number
    errorRate?: number | null
  }

  export type RecipeInputCreateManyRecipeInput = {
    id?: number
    material: string
    quantity: number
  }

  export type RecipeOutputCreateManyRecipeInput = {
    id?: number
    material: string
    quantity: number
  }

  export type ProcessStepUpdateWithoutRecipeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUpdateManyWithoutProcessStepsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutProcessStepNestedInput
    location?: LocationUpdateOneRequiredWithoutProcessStepsNestedInput
    resources?: ResourceUpdateManyWithoutProcessStepNestedInput
    sensors?: SensorUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUpdateManyWithoutEndStepNestedInput
    outputs?: TransportSystemUpdateManyWithoutStartStepNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: OrderUncheckedUpdateManyWithoutProcessStepsNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutProcessStepNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUncheckedUpdateManyWithoutEndStepNestedInput
    outputs?: TransportSystemUncheckedUpdateManyWithoutStartStepNestedInput
  }

  export type ProcessStepUncheckedUpdateManyWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RecipeInputUpdateWithoutRecipeInput = {
    material?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeInputUncheckedUpdateWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeInputUncheckedUpdateManyWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeOutputUpdateWithoutRecipeInput = {
    material?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeOutputUncheckedUpdateWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeOutputUncheckedUpdateManyWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type LogEntryCreateManySensorInput = {
    id?: number
    createdAt?: Date | string
    inputType: string
    materialId: number
    materialName: string
    processStepId?: number | null
    transportSystemId?: number | null
  }

  export type LogEntryUpdateWithoutSensorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputType?: StringFieldUpdateOperationsInput | string
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LogEntryUncheckedUpdateWithoutSensorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputType?: StringFieldUpdateOperationsInput | string
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LogEntryUncheckedUpdateManyWithoutSensorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputType?: StringFieldUpdateOperationsInput | string
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    transportSystemId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FilterEntryCreateManyFilterInput = {
    id?: number
    addedAt?: Date | string
    material: string
  }

  export type FilterEntryUpdateWithoutFilterInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
  }

  export type FilterEntryUncheckedUpdateWithoutFilterInput = {
    id?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
  }

  export type FilterEntryUncheckedUpdateManyWithoutFilterInput = {
    id?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
  }

  export type SensorCreateManyTransportSystemInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: string
    value?: number
    sensorDelay?: number
    active?: boolean
    processStepId?: number | null
  }

  export type ResourceCreateManyTransportSystemInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    active?: boolean
    mandatory?: boolean
    productionResource?: boolean
    inventoryResource?: boolean
    locationId: number
    processStepId?: number | null
    faulty?: boolean | null
    faultyRate?: number
  }

  export type OrderUpdateWithoutTransportSystemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryEntries?: InventoryEntryUpdateManyWithoutOrderNestedInput
    processSteps?: ProcessStepUpdateManyWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutTransportSystemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryEntries?: InventoryEntryUncheckedUpdateManyWithoutOrderNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutTransportSystemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedTick?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SensorUpdateWithoutTransportSystemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sensorDelay?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    processStep?: ProcessStepUpdateOneWithoutSensorsNestedInput
    logEntries?: LogEntryUpdateManyWithoutSensorNestedInput
  }

  export type SensorUncheckedUpdateWithoutTransportSystemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sensorDelay?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    logEntries?: LogEntryUncheckedUpdateManyWithoutSensorNestedInput
  }

  export type SensorUncheckedUpdateManyWithoutTransportSystemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sensorDelay?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ResourceUpdateWithoutTransportSystemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
    Machine?: MachineUpdateOneWithoutResourceNestedInput
    processStep?: ProcessStepUpdateOneWithoutResourcesNestedInput
    location?: LocationUpdateOneRequiredWithoutResourcesNestedInput
    Worker?: WorkerUpdateOneWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutTransportSystemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    locationId?: IntFieldUpdateOperationsInput | number
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
    Machine?: MachineUncheckedUpdateOneWithoutResourceNestedInput
    Worker?: WorkerUncheckedUpdateOneWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateManyWithoutTransportSystemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    productionResource?: BoolFieldUpdateOperationsInput | boolean
    inventoryResource?: BoolFieldUpdateOperationsInput | boolean
    locationId?: IntFieldUpdateOperationsInput | number
    processStepId?: NullableIntFieldUpdateOperationsInput | number | null
    faulty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faultyRate?: FloatFieldUpdateOperationsInput | number
  }

  export type InventoryEntryCreateManyOrderInput = {
    id?: number
    addedAt?: Date | string
    material: string
    inventoryId: number
  }

  export type InventoryEntryUpdateWithoutOrderInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
    inventory?: InventoryUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type InventoryEntryUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
    inventoryId?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryEntryUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: StringFieldUpdateOperationsInput | string
    inventoryId?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessStepUpdateWithoutOrdersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    recipe?: RecipeUpdateOneWithoutProcessStepsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutProcessStepNestedInput
    location?: LocationUpdateOneRequiredWithoutProcessStepsNestedInput
    resources?: ResourceUpdateManyWithoutProcessStepNestedInput
    sensors?: SensorUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUpdateManyWithoutEndStepNestedInput
    outputs?: TransportSystemUpdateManyWithoutStartStepNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    resources?: ResourceUncheckedUpdateManyWithoutProcessStepNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutProcessStepNestedInput
    inputs?: TransportSystemUncheckedUpdateManyWithoutEndStepNestedInput
    outputs?: TransportSystemUncheckedUpdateManyWithoutStartStepNestedInput
  }

  export type ProcessStepUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    recipeRate?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransportSystemUpdateWithoutOrdersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endStep?: ProcessStepUpdateOneWithoutInputsNestedInput
    startStep?: ProcessStepUpdateOneWithoutOutputsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutTransportSystemNestedInput
    filter?: FilterUpdateOneWithoutTransportSystemNestedInput
    sensors?: SensorUpdateManyWithoutTransportSystemNestedInput
    resources?: ResourceUpdateManyWithoutTransportSystemNestedInput
  }

  export type TransportSystemUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    startStepId?: NullableIntFieldUpdateOperationsInput | number | null
    endStepId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
    filter?: FilterUncheckedUpdateOneWithoutTransportSystemNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutTransportSystemNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutTransportSystemNestedInput
  }

  export type TransportSystemUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    inputSpeed?: IntFieldUpdateOperationsInput | number
    outputSpeed?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    transportDelay?: NullableIntFieldUpdateOperationsInput | number | null
    startStepId?: NullableIntFieldUpdateOperationsInput | number | null
    endStepId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    startTSId?: NullableIntFieldUpdateOperationsInput | number | null
    endTSId?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use SimulationRecordCountOutputTypeDefaultArgs instead
     */
    export type SimulationRecordCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SimulationRecordCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkerCountOutputTypeDefaultArgs instead
     */
    export type WorkerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkerRoleCountOutputTypeDefaultArgs instead
     */
    export type WorkerRoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkerRoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryCountOutputTypeDefaultArgs instead
     */
    export type InventoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationCountOutputTypeDefaultArgs instead
     */
    export type LocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessStepCountOutputTypeDefaultArgs instead
     */
    export type ProcessStepCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessStepCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeCountOutputTypeDefaultArgs instead
     */
    export type RecipeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SensorCountOutputTypeDefaultArgs instead
     */
    export type SensorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SensorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FilterCountOutputTypeDefaultArgs instead
     */
    export type FilterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FilterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransportSystemCountOutputTypeDefaultArgs instead
     */
    export type TransportSystemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransportSystemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SimulationRecordDefaultArgs instead
     */
    export type SimulationRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SimulationRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KpiRecordDefaultArgs instead
     */
    export type KpiRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KpiRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResourceDefaultArgs instead
     */
    export type ResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MachineDefaultArgs instead
     */
    export type MachineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MachineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkerDefaultArgs instead
     */
    export type WorkerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkerRoleDefaultArgs instead
     */
    export type WorkerRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkerRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryDefaultArgs instead
     */
    export type InventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryEntryDefaultArgs instead
     */
    export type InventoryEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationDefaultArgs instead
     */
    export type LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessStepDefaultArgs instead
     */
    export type ProcessStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessStepDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeDefaultArgs instead
     */
    export type RecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeInputDefaultArgs instead
     */
    export type RecipeInputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeInputDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeOutputDefaultArgs instead
     */
    export type RecipeOutputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeOutputDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogEntryDefaultArgs instead
     */
    export type LogEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SensorDefaultArgs instead
     */
    export type SensorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SensorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FilterEntryDefaultArgs instead
     */
    export type FilterEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FilterEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FilterDefaultArgs instead
     */
    export type FilterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FilterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransportSystemDefaultArgs instead
     */
    export type TransportSystemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransportSystemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}